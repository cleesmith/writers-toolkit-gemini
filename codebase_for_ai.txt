# TABLE OF CONTENTS

1. adjective-adverb-optimizer.js
2. api-settings.js
3. base-tool.js
4. brainstorm.js
5. chapter-writer.js
6. character-analyzer.js
7. claude_client.js
8. client.js
9. cls_proofreader-mechanical.js
10. cls_tokens-words-counter.js
11. code-consolidator-cli.js
12. conflict-analyzer.js
13. copy-editing.js
14. crowding-leaping-evaluator.js
15. dangling-modifier-checker.js
16. developmental-editing.js
17. docx-comments.js
18. drunk-claude.js
19. editor-dialog.js
20. editor-main.js
21. editor-preload.js
22. epub-converter.js
23. file-cache.js
24. file-utils.js
25. foreshadowing-tracker.js
26. forge.config.js
27. gemini-file-manager.js
28. gemini25.js
29. hattie_gemini25.js
30. kdp-publishing-prep.js
31. line-editing.js
32. main.js
33. manuscript-analyzer.js
34. manuscript-extractor-tool.js
35. manuscript-to-outline-characters-world.js
36. narrative-integrity.js
37. nonstreaming-example.js
38. outline-writer.js
39. plot-thread-tracker.js
40. preload.js
41. project-dialog.js
42. proofreader_cached_gemini25.js
43. proofreader_gemini25.js
44. proofreader-mechanical.js
45. proofreader-plot-consistency.js
46. punctuation-auditor.js
47. registry.js
48. renderer.js
49. renderer/app.js
50. renderer/editor/renderer.js
51. rhythm-analyzer.js
52. sdk-with-headers.js
53. state.js
54. streaming_example.js
55. tense-consistency-checker.js
56. test_open_app.js
57. test.js
58. textProcessor.js
59. thinking_gemini25pro.js
60. token-limit-test.js
61. tokens-words-counter.js
62. tool-general-template.js
63. tool-setup-run.js
64. tool-system.js
65. upload_gemini25.js
66. world-writer.js
67. api-settings.html
68. editor-dialog.html
69. index.html
70. project-dialog.html
71. renderer/editor/index.html
72. tool-setup-run.html
73. renderer/editor/editor-specific.css
74. styles.css
75. package.json




============================================================
FILE: adjective-adverb-optimizer.js
SIZE: 17366 bytes
LANGUAGE: JS
============================================================

// adjective-adverb-optimizer.js
const BaseTool = require('./base-tool');
const path = require('path');
const fileCache = require('./file-cache');
const appState = require('./state.js');
const fs = require('fs/promises');

/**
 * Adjective Adverb Optimizer Tool
 * Analyzes manuscript for adjective and adverb usage using the Claude API.
 * Identifies unnecessary modifiers, overused qualifiers, and suggests stronger verbs/nouns
 * to replace adjective-heavy descriptions, following Ursula K. Le Guin's writing advice.
 */
class AdjectiveAdverbOptimizer extends BaseTool {
  /**
   * Constructor
   * @param {Object} GeminiAPIService - Claude API service
   * @param {Object} config - Tool configuration
   */
  constructor(GeminiAPIService, config = {}) {
    super('adjective_adverb_optimizer', config);
    this.GeminiAPIService = GeminiAPIService;
  }
  
  /**
   * Execute the tool
   * @param {Object} options - Tool options
   * @returns {Promise<Object>} - Execution result
   */
  async execute(options) {
    console.log('Executing AdjectiveAdverbOptimizer with options:', options);
    
    // Extract options
    let manuscriptFile = options.manuscript_file;
    const analysisLevel = options.analysis_level || 'standard';
    const focusAreas = options.focus_areas || ['qualifiers', 'adverbs', 'adjectives', 'imagery'];
    const saveDir = options.save_dir || appState.CURRENT_PROJECT_PATH;
    
    if (!saveDir) {
      const errorMsg = 'Error: No save directory specified and no current project selected.\n' +
                      'Please select a project or specify a save directory.';
      this.emitOutput(errorMsg);
      throw new Error('No save directory available');
    }

    // Ensure file paths are absolute
    manuscriptFile = this.ensureAbsolutePath(manuscriptFile, saveDir);
    
    // Log the full paths for debugging
    console.log('Using full paths:');
    console.log(`Manuscript: ${manuscriptFile}`);

    const outputFiles = [];
    
    try {
      // Read the input files
      this.emitOutput(`Reading files...\n`);

      // Read the manuscript file
      this.emitOutput(`Reading manuscript file: ${manuscriptFile}\n`);
      const manuscriptContent = await this.readInputFile(manuscriptFile);
      
      // Create the prompt
      const prompt = this.createModifierAnalysisPrompt(manuscriptContent, analysisLevel, focusAreas);

      // Count tokens in the prompt
      this.emitOutput(`Counting tokens in prompt...\n`);
      const promptTokens = await this.GeminiAPIService.countTokens(prompt);

      // Call the shared token budget calculator
      const tokenBudgets = this.GeminiAPIService.calculateTokenBudgets(promptTokens);

      // Handle logging based on the returned values
      this.emitOutput(`\nToken stats:\n`);
      this.emitOutput(`Max AI model context window: [${tokenBudgets.contextWindow}] tokens\n`);
      this.emitOutput(`Input prompt tokens: [${tokenBudgets.promptTokens}] ...\n`);
      this.emitOutput(`                     = manuscript + prompt instructions\n`);
      this.emitOutput(`Available tokens: [${tokenBudgets.availableTokens}]  = ${tokenBudgets.contextWindow} - ${tokenBudgets.promptTokens} = context_window - prompt\n`);
      this.emitOutput(`Desired output tokens: [${tokenBudgets.desiredOutputTokens}]\n`);
      this.emitOutput(`AI model thinking budget: [${tokenBudgets.thinkingBudget}] tokens\n`);
      this.emitOutput(`Max output tokens: [${tokenBudgets.maxTokens}] tokens\n`);

      // Check for special conditions
      if (tokenBudgets.capThinkingBudget) {
        this.emitOutput(`Warning: thinking budget is larger than 32K, set to 32K.\n`);
      }

      // Check if the prompt is too large
      if (tokenBudgets.isPromptTooLarge) {
        this.emitOutput(`Error: prompt is too large to have a ${tokenBudgets.configuredThinkingBudget} thinking budget!\n`);
        this.emitOutput(`Run aborted!\n`);
        throw new Error(`Prompt is too large for ${tokenBudgets.configuredThinkingBudget} thinking budget - run aborted`);
      }
      
      // Call Claude API with streaming
      this.emitOutput(`Sending request to Claude API (streaming)...\n`);

      // Add a message about waiting
      this.emitOutput(`****************************************************************************\n`);
      this.emitOutput(`*  Analyzing adjectives and adverbs in your manuscript...                  \n`);
      this.emitOutput(`*  This process typically takes several minutes.                           \n`);
      this.emitOutput(`*                                                                          \n`);
      this.emitOutput(`*  It's recommended to keep this window the sole 'focus'                   \n`);
      this.emitOutput(`*  and to avoid browsing online or running other apps, as these API        \n`);
      this.emitOutput(`*  network connections are often flakey, like delicate echoes of whispers. \n`);
      this.emitOutput(`*                                                                          \n`);
      this.emitOutput(`*  So breathe, remove eye glasses, stretch, relax, and be like water 🥋 🧘🏽‍♀️\n`);
      this.emitOutput(`****************************************************************************\n\n`);
      
      const startTime = Date.now();
      let fullResponse = "";
      let thinkingContent = "";
      
      // Create system prompt to avoid markdown
      const systemPrompt = "CRITICAL INSTRUCTION: NO Markdown formatting of ANY kind. Never use headers, bullets, or any formatting symbols. Plain text only with standard punctuation.";

      // Use the calculated values in the API call
      try {
        await this.GeminiAPIService.streamWithThinking(
          prompt,
          {
            model: "claude-3-7-sonnet-20250219",
            system: systemPrompt,
            max_tokens: tokenBudgets.maxTokens,
            thinking: {
              type: "enabled",
              budget_tokens: tokenBudgets.thinkingBudget
            },
            betas: ["output-128k-2025-02-19"]
          },
          // Callback for thinking content
          (thinkingDelta) => {
            thinkingContent += thinkingDelta;
          },
          // Callback for response text
          (textDelta) => {
            fullResponse += textDelta;
          }
        );
      } catch (error) {
        this.emitOutput(`\nAPI Error: ${error.message}\n`);
        throw error;
      }

      const elapsed = (Date.now() - startTime) / 1000;
      const minutes = Math.floor(elapsed / 60);
      const seconds = elapsed % 60;
      
      this.emitOutput(`\nCompleted in ${minutes}m ${seconds.toFixed(2)}s.\n`);
      
      // Count words in response
      const wordCount = this.countWords(fullResponse);
      this.emitOutput(`Report has approximately ${wordCount} words.\n`);
      
      // Count tokens in response
      const responseTokens = await this.GeminiAPIService.countTokens(fullResponse);
      this.emitOutput(`Response token count: ${responseTokens}\n`);

      // Remove any markdown formatting
      fullResponse = this.removeMarkdown(fullResponse);

      // Save the report
      const outputFile = await this.saveReport(
        analysisLevel,
        focusAreas,
        fullResponse,
        thinkingContent,
        promptTokens,
        responseTokens,
        saveDir
      );
      
      // Add all output files to the result
      outputFiles.push(...outputFile);
      
      // Add files to the cache
      const toolName = 'adjective_adverb_optimizer';
      outputFiles.forEach(file => {
        fileCache.addFile(toolName, file);
      });
      
      // Return the result
      return {
        success: true,
        outputFiles,
        stats: {
          wordCount,
          tokenCount: responseTokens,
          elapsedTime: `${minutes}m ${seconds.toFixed(2)}s`,
          analysisLevel,
          focusAreas
        }
      };
    } catch (error) {
      console.error('Error in AdjectiveAdverbOptimizer:', error);
      this.emitOutput(`\nError: ${error.message}\n`);
      throw error;
    }
  }
  
  /**
   * Create modifier analysis prompt
   * @param {string} manuscriptContent - Manuscript content
   * @param {string} analysisLevel - Analysis level (basic, standard, detailed)
   * @param {Array} focusAreas - Areas to focus on
   * @returns {string} - Prompt for Claude API
   */
  createModifierAnalysisPrompt(manuscriptContent, analysisLevel = "standard", focusAreas = ["qualifiers", "adverbs", "adjectives", "imagery"]) {
    // Build instruction section based on analysis level
    const basicInstructions = `
1. ADJECTIVE AND ADVERB OVERVIEW:
   - Identify patterns of adjective and adverb usage in the manuscript
   - Highlight the most common qualifiers (very, rather, just, quite, etc.)
   - Note any recurring descriptive patterns

2. MODIFIER OPTIMIZATION OPPORTUNITIES:
   - Identify passages with unnecessary or weak modifiers
   - Point out adverbs that could be replaced with stronger verbs
   - Highlight adjective clusters that could be simplified
   - Suggest specific improvements with examples

3. RECOMMENDATIONS:
   - Provide practical suggestions for strengthening descriptive language
   - Suggest specific verb replacements for adverb+verb combinations
   - Recommend stronger nouns to replace adjective+noun pairs where appropriate
`;

    const standardInstructions = basicInstructions + `
4. QUALIFIER ANALYSIS:
   - List overused qualifiers and weakening words (e.g., very, just, quite, really, kind of, sort of)
   - Analyze frequency and impact of these qualifiers on prose strength
   - Identify dialogue vs. narrative patterns in qualifier usage
   - Suggest specific alternatives or eliminations

5. SENSORY LANGUAGE ASSESSMENT:
   - Evaluate balance between different sensory descriptors (visual, auditory, tactile, etc.)
   - Identify opportunities to replace abstract descriptions with concrete sensory details
   - Suggest ways to make descriptions more immediate and vivid
`;

    const detailedInstructions = standardInstructions + `
6. CHARACTER-SPECIFIC MODIFIER PATTERNS:
   - For each major character, analyze distinctive modifier patterns in their dialogue or POV sections
   - Identify if modifier usage helps differentiate character voices
   - Suggest improvements to make character voices more distinct through modifier choices

7. STYLISTIC IMPACT ANALYSIS:
   - Assess how current modifier usage affects pace, tone, and atmosphere
   - Identify sections where modifier reduction could improve flow
   - Note sections where additional sensory detail might enrich the prose
   - Compare modifier patterns across different scene types (action, dialogue, description)

8. ADVANCED REPLACEMENT STRATEGIES:
   - Provide examples of metaphor or imagery that could replace adjective-heavy descriptions
   - Suggest specialized vocabulary or domain-specific terms that could replace generic descriptions
   - Offer alternative sentence structures to eliminate dependence on modifiers
`;

    // Choose the appropriate instruction level
    let instructionSet;
    if (analysisLevel === "basic") {
      instructionSet = basicInstructions;
    } else if (analysisLevel === "detailed") {
      instructionSet = detailedInstructions;
    } else {  // standard
      instructionSet = standardInstructions;
    }

    // Construct focus area text
    // const focusAreaText = focusAreas.join(", ");
    const focusAreaText = Array.isArray(focusAreas) ? focusAreas.join(', ') : String(focusAreas || '');

    // Construct the full prompt
    const instructions = `IMPORTANT: NO Markdown formatting

You are an expert literary editor specializing in prose improvement and optimization. Your task is to analyze the provided manuscript for adjective and adverb usage, focusing particularly on: ${focusAreaText}.

Follow Ursula K. Le Guin's principle from "Steering the Craft" that "when the quality that the adverb indicates can be put in the verb itself... the prose will be cleaner, more intense, more vivid." Look for opportunities to replace weak verb+adverb combinations with strong verbs, and generic noun+adjective pairs with specific, evocative nouns.

Pay special attention to:
1. Overused qualifiers that weaken prose (very, rather, quite, just, really, somewhat, etc.)
2. Adverbs that could be eliminated by choosing stronger verbs
3. Generic adjectives that add little value (nice, good, bad, etc.)
4. Places where multiple adjectives could be replaced with one precise descriptor or a stronger noun
5. Abstract descriptions that could be made more concrete and sensory

For each issue you identify, provide:
- The original passage
- What makes it less effective
- A specific recommendation for improvement

Create a comprehensive modifier analysis with these sections:
${instructionSet}

Format your analysis as a clear, organized report with sections and subsections. Use plain text formatting only (NO Markdown). Use numbered or bulleted lists where appropriate for clarity.

Be specific in your examples and suggestions, showing how prose can be strengthened without changing the author's voice or intention. Focus on practical changes that will make the writing more vivid, clear, and powerful.
`;

    // Combine all sections
    return `=== MANUSCRIPT ===\n${manuscriptContent}\n=== END MANUSCRIPT ===\n\n${instructions}`;
  }

  /**
   * Count words in text
   * @param {string} text - Text to count words in
   * @returns {number} - Word count
   */
  countWords(text) {
    return text.split(/\s+/).filter(word => word.length > 0).length;
  }
  
  /**
   * Ensure file path is absolute
   * @param {string} filePath - File path (may be relative or absolute)
   * @param {string} basePath - Base path to prepend for relative paths
   * @returns {string} - Absolute file path
   */
  ensureAbsolutePath(filePath, basePath) {
    if (!filePath) return filePath;
    
    // Check if the path is already absolute
    if (path.isAbsolute(filePath)) {
      return filePath;
    }
    
    // Make the path absolute by joining with the base path
    return path.join(basePath, filePath);
  }
  
  /**
   * Save report and thinking content to files
   * @param {string} analysisLevel - Analysis level (basic, standard, detailed)
   * @param {Array} focusAreas - Areas to focus on
   * @param {string} content - Response content
   * @param {string} thinking - Thinking content
   * @param {number} promptTokens - Prompt token count
   * @param {number} responseTokens - Response token count
   * @param {string} saveDir - Directory to save to
   * @returns {Promise<string[]>} - Array of paths to saved files
   */
  async saveReport(
    analysisLevel,
    focusAreas,
    content,
    thinking,
    promptTokens,
    responseTokens,
    saveDir
  ) {
    try {
      const formatter = new Intl.DateTimeFormat('en-US', {
        weekday: 'long',
        month: 'long',
        day: 'numeric',
        year: 'numeric',
        hour: 'numeric',
        minute: '2-digit',
        hour12: true
      });
      const dateTimeStr = formatter.format(new Date());

      // Create timestamp for filename
      const timestamp = new Date().toISOString().replace(/[-:.]/g, '').substring(0, 15);
      
      // Create descriptive filename
      const level = analysisLevel !== 'standard' ? `_${analysisLevel}` : '';
      const baseFilename = `adjective_adverb_optimizer${level}_${timestamp}`;
      
      // Array to collect all saved file paths
      const savedFilePaths = [];
      
      // Format focusAreas for stats
      const focusAreasStr = Array.isArray(focusAreas) ? focusAreas.join(', ') : focusAreas;
      
      // Create stats for thinking file
      const stats = `
Details:  ${dateTimeStr}
Analysis type: Adjective and adverb optimization
Analysis level: ${analysisLevel}
Focus areas: ${focusAreasStr}
Max request timeout: ${this.config.request_timeout} seconds
Max AI model context window: ${this.config.context_window} tokens
AI model thinking budget: ${this.config.thinking_budget_tokens} tokens
Desired output tokens: ${this.config.desired_output_tokens} tokens

Input tokens: ${promptTokens}
Output tokens: ${responseTokens}
`;
      
      // Save full response
      const reportFilename = `${baseFilename}.txt`;
      const reportPath = path.join(saveDir, reportFilename);
      await this.writeOutputFile(content, saveDir, reportFilename);
      savedFilePaths.push(reportPath);
      
      // Save thinking content if available and not skipped
      if (thinking) {
        const thinkingFilename = `${baseFilename}_thinking.txt`;
        const thinkingPath = path.join(saveDir, thinkingFilename);
        const thinkingContent = `=== ADJECTIVE AND ADVERB OPTIMIZATION ANALYSIS ===

=== AI'S THINKING PROCESS ===

${thinking}

=== END AI'S THINKING PROCESS ===
${stats}`;
        
        await this.writeOutputFile(thinkingContent, saveDir, thinkingFilename);
        this.emitOutput(`AI thinking saved to: ${thinkingPath}\n`);
        savedFilePaths.push(thinkingPath);
      }

      this.emitOutput(`Report saved to: ${reportPath}\n`);
      return savedFilePaths;
    } catch (error) {
      console.error(`Error saving report:`, error);
      this.emitOutput(`Error saving report: ${error.message}\n`);
      throw error;
    }
  }
}

module.exports = AdjectiveAdverbOptimizer;

============================================================
FILE: api-settings.js
SIZE: 9568 bytes
LANGUAGE: JS
============================================================

// Get references to DOM elements
const settingsContainer = document.getElementById('settings-container');
const cancelBtn = document.getElementById('cancel-btn');
const saveBtn = document.getElementById('save-btn');

// Store the settings schema and values
let settingsSchema = [];
let settingsValues = {};
let settingInputs = {};

// When the page loads, fetch the current API settings schema and values
document.addEventListener('DOMContentLoaded', async () => {
  try {
    // Get API settings from the main process
    const result = await window.electronAPI.getClaudeApiSettings();
    
    if (result && result.schema && result.values) {
      // Store the schema and values
      settingsSchema = result.schema;
      settingsValues = result.values;
      
      // Render the settings form
      renderSettingsForm(settingsSchema, settingsValues);
    } else {
      showError('Failed to load API settings schema or values');
    }
  } catch (error) {
    console.error('Error fetching API settings:', error);
    showError('Failed to load API settings. Please try again.');
  }
  
  // Default to dark mode until we receive theme from main process
  document.body.classList.add('dark-mode');
});

// Render the settings form based on the schema
function renderSettingsForm(schema, values) {
  // Clear loading message
  settingsContainer.innerHTML = '';
  
  // Loop through each setting in the schema
  schema.forEach(setting => {
    // Create a setting group
    const settingGroup = document.createElement('div');
    settingGroup.className = 'setting-group';
    
    // Create label
    const label = document.createElement('label');
    label.className = 'setting-label';
    label.textContent = setting.label || setting.name;
    settingGroup.appendChild(label);
    
    // Create appropriate input based on setting type
    let input;
    switch (setting.type) {
      case 'number':
        input = document.createElement('input');
        input.type = 'number';
        input.min = setting.min !== undefined ? setting.min : '';
        input.max = setting.max !== undefined ? setting.max : '';
        input.step = setting.step || 1;
        input.value = values[setting.name] !== undefined ? values[setting.name] : (setting.default || '');
        break;
        
      case 'select':
        input = document.createElement('select');
        if (setting.options) {
          setting.options.forEach(option => {
            const optElement = document.createElement('option');
            optElement.value = option.value;
            optElement.textContent = option.label || option.value;
            input.appendChild(optElement);
          });
        }
        input.value = values[setting.name] !== undefined ? values[setting.name] : (setting.default || '');
        break;
        
      case 'boolean':
        // For boolean, we use a select with Yes/No options
        input = document.createElement('select');
        const trueOption = document.createElement('option');
        trueOption.value = 'true';
        trueOption.textContent = 'Yes';
        input.appendChild(trueOption);
        
        const falseOption = document.createElement('option');
        falseOption.value = 'false';
        falseOption.textContent = 'No';
        input.appendChild(falseOption);
        
        input.value = (values[setting.name] === true || values[setting.name] === 'true') ? 'true' : 'false';
        break;
        
      default: // Default to text input
        input = document.createElement('input');
        input.type = 'text';
        input.value = values[setting.name] !== undefined ? values[setting.name] : (setting.default || '');
    }
    
    // Add common properties
    input.id = `setting-${setting.name}`;
    input.setAttribute('data-setting-name', setting.name);
    input.setAttribute('data-setting-type', setting.type);
    settingGroup.appendChild(input);
    
    // Add validation error message container
    const errorText = document.createElement('div');
    errorText.id = `error-${setting.name}`;
    errorText.className = 'error-text';
    settingGroup.appendChild(errorText);
    
    // Add description if provided
    if (setting.description) {
      const description = document.createElement('div');
      description.className = 'setting-description';
      description.textContent = setting.description;
      description.style.fontSize = '12px';
      
      // Apply color based on current theme
      const isLightMode = document.body.classList.contains('light-mode');
      description.style.color = isLightMode ? '#666666' : '#888888';
      
      description.style.marginTop = '-10px';
      description.style.marginBottom = '15px';
      settingGroup.appendChild(description);
    }
    
    // Store reference to the input
    settingInputs[setting.name] = {
      element: input,
      errorElement: errorText,
      schema: setting
    };
    
    // Add the setting group to the container
    settingsContainer.appendChild(settingGroup);
  });
}

// Handle save button click
saveBtn.addEventListener('click', async () => {
  // Validate inputs
  if (!validateAllInputs()) {
    return;
  }
  
  try {
    // Collect values from form
    const settings = {};
    
    for (const settingName in settingInputs) {
      const input = settingInputs[settingName].element;
      const schema = settingInputs[settingName].schema;
      
      // Process the value based on setting type
      let value = input.value;
      
      switch (schema.type) {
        case 'number':
          value = parseFloat(value);
          // Convert to integer if step is 1
          if (schema.step === 1 || !schema.step) {
            value = Math.round(value);
          }
          break;
          
        case 'boolean':
          value = value === 'true';
          break;
          
        // Add other type conversions as needed
      }
      
      settings[settingName] = value;
    }
    
    // Save settings through main process
    const result = await window.electronAPI.saveClaudeApiSettings(settings);
    
    if (result && result.success) {
      // Close the dialog with success action
      window.electronAPI.closeApiSettingsDialog('saved', settings);
    } else {
      showError(result.message || 'Failed to save API settings');
    }
  } catch (error) {
    console.error('Error saving API settings:', error);
    showError('An error occurred while saving API settings');
  }
});

// Handle cancel button click
cancelBtn.addEventListener('click', () => {
  window.electronAPI.closeApiSettingsDialog('cancelled');
});

// Validate all inputs
function validateAllInputs() {
  let isValid = true;
  
  for (const settingName in settingInputs) {
    const input = settingInputs[settingName].element;
    const errorElement = settingInputs[settingName].errorElement;
    const schema = settingInputs[settingName].schema;
    
    // Reset error state
    errorElement.style.display = 'none';
    
    // Get value
    let value = input.value;
    
    // Check if required
    if (schema.required && (!value || value.trim() === '')) {
      showInputError(errorElement, 'This field is required');
      isValid = false;
      continue;
    }
    
    // Validate based on type
    switch (schema.type) {
      case 'number':
        value = parseFloat(value);
        
        if (isNaN(value)) {
          showInputError(errorElement, 'Please enter a valid number');
          isValid = false;
          break;
        }
        
        if (schema.min !== undefined && value < schema.min) {
          showInputError(errorElement, `Value must be at least ${schema.min}`);
          isValid = false;
          break;
        }
        
        if (schema.max !== undefined && value > schema.max) {
          showInputError(errorElement, `Value must be at most ${schema.max}`);
          isValid = false;
          break;
        }
        break;
        
      // Add other validation types as needed
    }
  }
  
  return isValid;
}

// Show error for a specific input
function showInputError(errorElement, message) {
  errorElement.textContent = message;
  errorElement.style.display = 'block';
}

// Helper function to show general errors
function showError(message) {
  // Create a simple error notification
  const notification = document.createElement('div');
  notification.textContent = message;
  notification.style.cssText = `
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    background-color: #f44336;
    color: white;
    padding: 12px 24px;
    border-radius: 4px;
    z-index: 1000;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
  `;
  
  document.body.appendChild(notification);
  
  // Remove after 3 seconds
  setTimeout(() => {
    notification.style.opacity = '0';
    notification.style.transition = 'opacity 0.5s';
    setTimeout(() => {
      document.body.removeChild(notification);
    }, 500);
  }, 3000);
}

// Listen for theme messages from the main process
window.electronAPI.onSetTheme((theme) => {
  // Remove all theme classes first
  document.body.classList.remove('light-mode', 'dark-mode');
  
  // Apply the appropriate theme class
  if (theme === 'light') {
    document.body.classList.add('light-mode');
  } else {
    document.body.classList.add('dark-mode');
  }
  
  // Update setting descriptions color based on theme
  const descriptions = document.querySelectorAll('.setting-description');
  descriptions.forEach(desc => {
    desc.style.color = theme === 'light' ? '#666666' : '#888888';
  });
  
});


============================================================
FILE: base-tool.js
SIZE: 5796 bytes
LANGUAGE: JS
============================================================

// base-tool.js
const fs = require('fs/promises');
const path = require('path');

/**
 * Base class for all tools
 */
class BaseTool {

  /**
   * Constructor
   * @param {string} name - Tool name
   * @param {object} config - Tool configuration
   */
  constructor(name, config = {}) {
    this.name = name;
    this.config = config;
    // console.log(`BaseTool initialized: ${name}`);
  }
  
  /**
   * Execute the tool - must be implemented by subclasses
   * @param {object} options - Tool options
   * @returns {Promise<object>} - Tool execution result
   */
  async execute(options) {
    throw new Error(`Tool ${this.name} must implement execute method`);
  }
  
  /**
   * Read a file
   * @param {string} filePath - Path to file
   * @param {string} encoding - File encoding
   * @returns {Promise<string>} - File content
   */
  async readInputFile(filePath, encoding = 'utf-8') {
    try {
      // Handle relative paths by resolving against the current project path
      let resolvedPath = filePath;
      
      // If path is not absolute and doesn't start with ~/ (which will be expanded by Node)
      if (!path.isAbsolute(filePath) && !filePath.startsWith('~/')) {
        // Get current project path from appState
        const projectPath = this.config.save_dir || appState.CURRENT_PROJECT_PATH;
        
        if (projectPath) {
          resolvedPath = path.join(projectPath, filePath);
          console.log(`Resolved relative path "${filePath}" to: "${resolvedPath}"`);
        }
      }
      
      // Read file with resolved path
      const content = await fs.readFile(resolvedPath, encoding);
      if (!content.trim()) {
        throw new Error(`File is empty: ${resolvedPath}`);
      }
      return content;
    } catch (error) {
      if (error.code === 'ENOENT') {
        throw new Error(`File not found: ${filePath}`);
      }
      throw error;
    }
  }  

  /**
   * Write content to a file
   * @param {string} content - Content to write
   * @param {string} saveDir - Directory to save to
   * @param {string} fileName - File name
   * @returns {Promise<string>} - Path to the saved file
   */
  async writeOutputFile(content, saveDir, fileName) {
    try {
      // Ensure the directory exists
      await fs.mkdir(saveDir, { recursive: true });
      
      // Path to the output file
      const outputPath = path.join(saveDir, fileName);
      
      // Write the file
      await fs.writeFile(outputPath, content, 'utf-8');
      
      // Return the absolute path to the file
      return path.resolve(outputPath);
    } catch (error) {
      console.error(`Error writing file ${fileName}:`, error);
      throw error;
    }
  }
  
  /**
   * Emit output to be displayed in the UI
   * This will be overridden by the tool runner
   * @param {string} text - Text to emit
   */
  emitOutput(text) {
    // console.log(text);
  }

  /**
   * Remove Markdown formatting from text
   * @param {string} text - Text with Markdown formatting
   * @returns {string} - Plain text without Markdown
   */
  removeMarkdown(text) {
    const options = {
      listUnicodeChar: false,
      stripListLeaders: true,
      gfm: true,
      useImgAltText: true,
      preserveBlockSpacing: true
    };
    
    let output = text || '';
    // Remove horizontal rules
    output = output.replace(/^(-\s*?|\*\s*?|_\s*?){3,}\s*$/gm, '');
    try {
      // Handle list markers
      if (options.stripListLeaders) {
        if (options.listUnicodeChar) {
          output = output.replace(/^([\s\t]*)([\*\-\+]|\d+\.)\s+/gm, options.listUnicodeChar + ' $1');
        } else {
          output = output.replace(/^([\s\t]*)([\*\-\+]|\d+\.)\s+/gm, '$1');
        }
      }
      // Handle GitHub Flavored Markdown features
      if (options.gfm) {
        output = output
          .replace(/\n={2,}/g, '\n')
          .replace(/~{3}.*\n/g, '')
          // Improved code block handling
          .replace(/(`{3,})([\s\S]*?)\1/gm, function(match, p1, p2) {
            return p2.trim() + '%%CODEBLOCK_END%%\n';
          })
          .replace(/~~/g, '');
      }
      // Process main markdown elements
      output = output
        // Remove HTML tags
        .replace(/<[^>]*>/g, '')
        // Remove setext headers
        .replace(/^[=\-]{2,}\s*$/g, '')
        // Remove footnotes
        .replace(/\[\^.+?\](\: .*?$)?/g, '')
        .replace(/\s{0,2}\[.*?\]: .*?$/g, '')
        // Handle images and links
        .replace(/\!\[(.*?)\][\[\(].*?[\]\)]/g, options.useImgAltText ? '$1' : '')
        .replace(/\[(.*?)\][\[\(].*?[\]\)]/g, '$1')
        // Better blockquote handling with spacing
        .replace(/^\s*>+\s?/gm, function(match) {
          return options.preserveBlockSpacing ? '\n' : '';
        })
        // Remove list markers again (thorough cleanup)
        .replace(/^([\s\t]*)([\*\-\+]|\d+\.)\s+/gm, '$1')
        // Remove reference links
        .replace(/^\s{1,2}\[(.*?)\]: (\S+)( ".*?")?\s*$/g, '')
        // Remove headers
        .replace(/^(\n)?\s{0,}#{1,6}\s+| {0,}(\n)?\s{0,}#{0,} {0,}(\n)?\s{0,}$/gm, '$1$2$3')
        // Remove emphasis
        .replace(/([\*_]{1,3})(\S.*?\S{0,1})\1/g, '$2')
        .replace(/([\*_]{1,3})(\S.*?\S{0,1})\1/g, '$2')
        // Remove code markers
        .replace(/`(.+?)`/g, '$1');
      // Final cleanup and spacing
      output = output
        // Replace code block markers with proper spacing
        .replace(/%%CODEBLOCK_END%%\n/g, '\n\n\n')
        // Normalize multiple newlines while preserving block spacing
        .replace(/\n{4,}/g, '\n\n\n')
        .replace(/\n{3}/g, '\n\n')
        // Clean up any trailing whitespace
        .trim();
    } catch(e) {
      console.error('Error removing Markdown:', e);
      return text;
    }
    return output;
  }

}

module.exports = BaseTool;


============================================================
FILE: brainstorm.js
SIZE: 18863 bytes
LANGUAGE: JS
============================================================

// brainstorm.js
const BaseTool = require('./base-tool');
const path = require('path');
const fileCache = require('./file-cache');
const appState = require('./state.js');
const fs = require('fs/promises');

/**
 * Brainstorm Tool
 * Helps generate initial story ideas, prompts, and creative angles.
 * Appends more ideas to the existing 'ideas.txt' file.
 */
class BrainstormTool extends BaseTool {
  /**
   * Constructor
   * @param {Object} GeminiAPIService - Claude API service
   * @param {Object} config - Tool configuration
   */
  constructor(GeminiAPIService, config = {}) {
    super('brainstorm', config);
    this.GeminiAPIService = GeminiAPIService;
  }
  
  /**
   * Execute the tool
   * @param {Object} options - Tool options
   * @returns {Promise<Object>} - Execution result
   */
  async execute(options) {
    // Clear the cache for this tool
    const toolName = 'brainstorm';
    fileCache.clear(toolName);
    
    // Extract options
    const ideasFile = options.ideas_file;
    const outputFiles = [];
    const conceptOnly = options.concept_only || false;
    const charactersOnly = options.characters_only || false;
    let saveDir = options.save_dir || appState.CURRENT_PROJECT_PATH;
    
    // Validate save directory
    if (!saveDir) {
      const errorMsg = 'Error: No save directory specified and no current project selected.\n' +
                      'Please select a project or specify a save directory.';
      this.emitOutput(errorMsg);
      throw new Error('No save directory available');
    }
    
    // Ensure file paths are absolute
    const absoluteIdeasFile = this.ensureAbsolutePath(ideasFile, saveDir);
    
    try {
      // Read ideas file
      this.emitOutput(`Reading ideas file: ${absoluteIdeasFile}\n`);
      const ideasContent = await this.readIdeasFile(absoluteIdeasFile);
      
      // Generate concept and/or characters based on options
      if (charactersOnly) {
        const outputFile = await this.generateAndAppend("characters", ideasContent, absoluteIdeasFile, saveDir, options);
        outputFiles.push(outputFile);
      } else if (conceptOnly) {
        const outputFile = await this.generateAndAppend("concept", ideasContent, absoluteIdeasFile, saveDir, options);
        outputFiles.push(outputFile);
      } else {
        // Generate both by default
        this.emitOutput("Generating both concept and characters...\n");
        const conceptFile = await this.generateAndAppend("concept", ideasContent, absoluteIdeasFile, saveDir, options);
        outputFiles.push(conceptFile);
        
        // Read updated ideas file after concept generation
        const updatedIdeasContent = await this.readIdeasFile(absoluteIdeasFile);
        const charactersFile = await this.generateAndAppend("characters", updatedIdeasContent, absoluteIdeasFile, saveDir, options);
        outputFiles.push(charactersFile);
      }
      
      this.emitOutput("\nGeneration complete!\n");
      this.emitOutput(`All content has been appended to: ${absoluteIdeasFile}\n`);
      this.emitOutput(`To continue developing this story, use the --continue option with this tool.\n`);
      
      // Return the result
      return {
        success: true,
        outputFiles,
        stats: {
          ideasFile: absoluteIdeasFile
        }
      };
      
    } catch (error) {
      console.error('Error in Brainstorm Tool:', error);
      this.emitOutput(`\nError: ${error.message}\n`);
      throw error;
    }
  }
  
  /**
   * Read ideas file
   * @param {string} filepath - Path to ideas file
   * @returns {Promise<string>} - File content
   */
  async readIdeasFile(filepath) {
    try {
      const content = await this.readInputFile(filepath);
      return content.trim();
    } catch (error) {
      this.emitOutput(`Error: Ideas file '${filepath}' not found or couldn't be read.\n`);
      this.emitOutput(`Please specify an existing ideas file with the ideas_file parameter.\n`);
      throw error;
    }
  }
  
  /**
   * Generate content and append to ideas file
   * @param {string} promptType - Type of prompt ("concept" or "characters")
   * @param {string} ideasContent - Content of ideas file
   * @param {string} ideasFile - Path to ideas file
   * @param {string} saveDir - Directory to save output
   * @param {Object} options - Tool options
   * @returns {Promise<string>} - Path to saved file
   */
  async generateAndAppend(promptType, ideasContent, ideasFile, saveDir, options) {
    // Create appropriate prompt
    let prompt;
    if (promptType === "concept") {
      prompt = this.createConceptPrompt(ideasContent, options);
    } else { // characters
      prompt = this.createCharacterPrompt(ideasContent, options);
    }

    this.emitOutput(`\n*** Working on: ${promptType}.txt file...\n`);

    // Count tokens in the prompt
    this.emitOutput(`Counting tokens in prompt...\n`);
    const promptTokens = await this.GeminiAPIService.countTokens(prompt);

    // Call the shared token budget calculator
    const tokenBudgets = this.GeminiAPIService.calculateTokenBudgets(promptTokens);

    // Handle logging based on the returned values
    this.emitOutput(`Token stats:\n`);
    this.emitOutput(`Max AI model context window: [${tokenBudgets.contextWindow}] tokens\n`);
    this.emitOutput(`Input prompt tokens: [${tokenBudgets.promptTokens}] ...\n`);
    this.emitOutput(`Available tokens: [${tokenBudgets.availableTokens}]  = ${tokenBudgets.contextWindow} - ${tokenBudgets.promptTokens} = context_window - prompt\n`);
    this.emitOutput(`Desired output tokens: [${tokenBudgets.desiredOutputTokens}]\n`);
    this.emitOutput(`AI model thinking budget: [${tokenBudgets.thinkingBudget}] tokens\n`);
    this.emitOutput(`Max output tokens: [${tokenBudgets.maxTokens}] tokens\n`);

    // Check for special conditions
    if (tokenBudgets.capThinkingBudget) {
      this.emitOutput(`Warning: thinking budget is larger than 32K, set to 32K.\n`);
    }

    // Check if the prompt is too large
    if (tokenBudgets.isPromptTooLarge) {
      this.emitOutput(`Error: prompt is too large to have a ${tokenBudgets.configuredThinkingBudget} thinking budget!\n`);
      this.emitOutput(`Run aborted!\n`);
      throw new Error(`Prompt is too large for ${tokenBudgets.configuredThinkingBudget} thinking budget - run aborted`);
    }
    
    // Call Claude API with streaming
    this.emitOutput(`Sending request to Claude API (streaming)...\n`);
    
    const startTime = Date.now();
    let fullResponse = "";
    let thinkingContent = "";
    
    // Create system prompt to avoid markdown
    const systemPrompt = "NO Markdown! Never respond with Markdown formatting, plain text only.";

    // Use the calculated values in the API call
    try {
      await this.GeminiAPIService.streamWithThinking(
        prompt,
        {
          model: "claude-3-7-sonnet-20250219",
          system: systemPrompt,
          max_tokens: tokenBudgets.maxTokens,
          thinking: {
            type: "enabled",
            budget_tokens: tokenBudgets.thinkingBudget
          },
          betas: ["output-128k-2025-02-19"]
        },
        // Callback for thinking content
        (thinkingDelta) => {
          thinkingContent += thinkingDelta;
        },
        // Callback for response text
        (textDelta) => {
          fullResponse += textDelta;
        }
      );
    } catch (error) {
      this.emitOutput(`\nAPI Error: ${error.message}\n`);
      throw error;
    }
    
    const elapsed = (Date.now() - startTime) / 1000;
    const minutes = Math.floor(elapsed / 60);
    const seconds = elapsed % 60;
    
    this.emitOutput(`\nCompleted in ${minutes}m ${seconds.toFixed(2)}s.\n`);
    
    // No need to remove markdown formatting - trust the API response directly
    const cleanedResponse = fullResponse;
    
    // Count words in response
    const wordCount = this.countWords(cleanedResponse);
    this.emitOutput(`Generated ${promptType} has approximately ${wordCount} words.\n`);
    
    // Count tokens in response
    const responseTokens = await this.GeminiAPIService.countTokens(cleanedResponse);
    this.emitOutput(`Response token count: ${responseTokens}\n`);
    
    // Append to ideas file
    await this.appendToIdeasFile(ideasFile, cleanedResponse, promptType);
    this.emitOutput(`Content appended to: ${ideasFile}\n`);
    
    // Save a backup copy
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').substring(0, 19);
    const backupFilename = `${promptType}_${timestamp}.txt`;
    const backupPath = path.join(saveDir, backupFilename);
    await this.writeOutputFile(cleanedResponse, saveDir, backupFilename);
    this.emitOutput(`Backup saved to: ${backupPath}\n`);
    
    // Add to the file cache
    fileCache.addFile('brainstorm', backupPath);
    
    // Save thinking content if not skipped
    if (thinkingContent) {
      const thinkingFilename = `${promptType}_thinking_${timestamp}.txt`;
      const thinkingPath = path.join(saveDir, thinkingFilename);
      
      // Stats for thinking file
      const stats = `
Details:
Max request timeout: ${this.config.request_timeout} seconds
Max AI model context window: ${this.config.context_window} tokens
AI model thinking budget: ${this.config.thinking_budget_tokens} tokens
Desired output tokens: ${this.config.desired_output_tokens} tokens

Input tokens: ${promptTokens}
Output tokens: ${responseTokens}
Elapsed time: ${minutes}m ${seconds.toFixed(2)}s
Output has ${wordCount} words
`;
      
      const thinkingContentWithPrompt = `=== PROMPT USED ===
${prompt}

=== AI'S THINKING PROCESS ===

${thinkingContent}

=== END AI'S THINKING PROCESS ===
${stats}`;
      
      await this.writeOutputFile(thinkingContentWithPrompt, saveDir, thinkingFilename);
      this.emitOutput(`AI thinking saved to: ${thinkingPath}\n`);
      
      // Add thinking file to the cache too
      fileCache.addFile('brainstorm', thinkingPath);
    }
    
    return backupPath;
  }
  
  /**
   * Append content to ideas file
   * @param {string} filepath - Path to ideas file
   * @param {string} newContent - New content to append
   * @param {string} contentType - Type of content ("Concept" or "Characters")
   * @returns {Promise<void>}
   */
  async appendToIdeasFile(filepath, newContent, contentType) {
    try {
      // Read existing content
      let existingContent = await fs.readFile(filepath, 'utf8');
      
      // Format content type with proper capitalization
      const formattedType = contentType.charAt(0).toUpperCase() + contentType.slice(1);
      
      // Get current timestamp
      const timestamp = new Date().toLocaleString();
      
      // Format new content to append
      const contentToAppend = `\n\n# ${formattedType} (Generated ${timestamp})\n\n${newContent}`;
      
      // Append to file
      await fs.writeFile(filepath, existingContent + contentToAppend);
    } catch (error) {
      this.emitOutput(`Error appending to ideas file: ${error.message}\n`);
      throw error;
    }
  }
  
  /**
   * Create concept prompt
   * @param {string} ideasContent - Content of ideas file
   * @param {Object} options - Tool options
   * @returns {string} - Concept prompt
   */
  createConceptPrompt(ideasContent, options) {
    const continueFlag = options.continue && ideasContent ? 
      "Continue and expand on the existing concept. Add new details and develop existing ideas further." : "";
    
    const titleSuggestion = options.title ? `TITLE: ${options.title}` : "";
    const genreSuggestion = options.genre ? `GENRE: ${options.genre}` : "";
    const lang = options.lang || "English";
    const worldbuildingDepth = options.worldbuilding_depth || 3;
    
    return `You are a skilled novelist and worldbuilder helping to create a detailed concept document in fluent, authentic ${lang}.
Draw upon your knowledge of worldwide literary traditions, narrative structure, and worldbuilding approaches from across cultures,
while expressing everything in natural, idiomatic ${lang}.

=== IDEAS FILE CONTENT ===
${ideasContent}
${titleSuggestion}
${genreSuggestion}
=== END IDEAS FILE CONTENT ===

${continueFlag}

Create a detailed concept document that explores and develops this writing idea. Focus on worldbuilding, setting, themes, and plot possibilities.
The depth level requested is ${worldbuildingDepth}/5, so adjust your detail accordingly.

Structure your response as a CONCEPT DOCUMENT with these clearly labeled sections:

1. HIGH CONCEPT (1-2 paragraphs summarizing the core idea)
2. WORLD/SETTING (detailed description of the world, era, technology, social structures, etc.)
3. CENTRAL CONFLICT (the main tension driving the story)
4. THEMES & MOTIFS (3-5 major themes to be explored)
5. UNIQUE ELEMENTS (what makes this concept fresh and original)
6. PLOT POSSIBILITIES (2-3 paragraphs on possible story directions)
7. TONE & ATMOSPHERE (the feeling and mood of the story)
8. WORLDBUILDING NOTES (10-15 specific details about how this world works)

IMPORTANT FORMATTING INSTRUCTIONS:
1. DO NOT use Markdown formatting (no #, ##, ###, *, **, etc.)
2. Start with "CONCEPT DOCUMENT:" at the top of your response
3. Use plain text section headers like "HIGH CONCEPT:"
4. Use plain numbered or bullet lists where appropriate
5. Keep your writing clear, concise, and creative
6. This content will be appended to an ideas file for writing development`;
  }
  
  /**
   * Create character prompt
   * @param {string} ideasContent - Content of ideas file
   * @param {Object} options - Tool options
   * @returns {string} - Character prompt
   */
  createCharacterPrompt(ideasContent, options) {
    const continueFlag = options.continue && ideasContent ? 
      "Review the existing characters in the ideas file. Build on these characters by expanding their details and deepening their characterization. If appropriate, create additional characters to reach the requested total number." : "";
    
    const titleSuggestion = options.title ? `TITLE: ${options.title}` : "";
    const genreSuggestion = options.genre ? `GENRE: ${options.genre}` : "";
    const lang = options.lang || "English";
    const numCharacters = options.num_characters || 5;
    const includeRelationships = options.character_relationships;
    
    // Determine character name handling based on arguments
    let characterNameInstructions = "";
    if (options.allow_new_characters) {
      characterNameInstructions = `
You are permitted to create new characters that fit the concept.
Create characters that align with and enhance the world, themes, and plot described in the ideas file.
Use Title Case (camel-case) for all character names.`;
    } else {
      characterNameInstructions = `
STRICT CHARACTER NAME INSTRUCTIONS:
- You MUST use ONLY the exact character names provided in: === CHARACTERS === through === END CHARACTERS === section, if provided
- DO NOT create any new character names not in: === CHARACTERS === through === END CHARACTERS ===
- DO NOT modify, expand, or add to the character names in any way (no adding first/last names, titles, etc.)
- Keep the exact capitalization/title case of each name as provided
- If a character has only a first name or nickname in the list, use ONLY that exact name
- If a character is referred to differently in different parts of the ideas file, use ONLY the specific format provided in the list

BACKGROUND CHARACTER INSTRUCTIONS:
- For incidental characters who briefly appear in scenes (cashiers, waiters, doormen, passersby, etc.), refer to them ONLY by their role or function (e.g., "the cashier," "the doorman").
- DO NOT assign names to these background characters unless they become recurring or important to the plot.
- DO NOT develop backstories for these functional characters.
- Background characters should only perform actions directly related to their function or brief interaction with named characters.
- Keep interactions with background characters brief and purposeful - they should serve the story without becoming story elements themselves.
- If a background character needs to speak, use phrases like "the clerk asked" rather than creating a name.
- Remember that background characters exist to create a realistic world but should remain in the background to keep focus on the main characters and plot.`;
    }
    
    return `You are a skilled novelist and character developer helping to create detailed character descriptions in fluent, authentic ${lang}.
Draw upon your knowledge of worldwide literary traditions, character development, and psychological complexity from across cultures,
while expressing everything in natural, idiomatic ${lang}.

=== IDEAS FILE CONTENT ===
${ideasContent}
${titleSuggestion}
${genreSuggestion}
=== END IDEAS FILE CONTENT ===

${characterNameInstructions}

${continueFlag}

Create details for ${numCharacters} characters that would fit well in this story concept.

Structure your response as a CHARACTER DOCUMENT with these elements for EACH character:

1. NAME & ROLE (full name and their function in the story)
2. PHYSICAL DESCRIPTION (key physical traits and appearance)
3. PERSONALITY (core character traits, strengths, flaws)
4. BACKGROUND (relevant history and formative experiences)
5. MOTIVATION (what drives this character)
6. ARC (how this character might change throughout the story)
7. SPECIAL SKILLS/ABILITIES (what makes them effective in this world)
${includeRelationships ? "8. RELATIONSHIPS (how they connect to other characters)" : ""}

IMPORTANT FORMATTING INSTRUCTIONS:
1. DO NOT use Markdown formatting (no #, ##, ###, *, **, etc.)
2. Number each character entry like "1. Character Name"
3. Use plain text for character details with bullet points or dashes
4. For each character attribute use a dash or bullet format like:
   - role: protagonist
   - personality: determined, resourceful
5. Separate each character with a blank line
6. Keep your writing clear, concise, and psychologically insightful
7. This content will be appended to an ideas file for writing development`;
  }

  /**
   * Count words in text
   * @param {string} text - Text to count words in
   * @returns {number} - Word count
   */
  countWords(text) {
    return text.replace(/(\r\n|\r|\n)/g, ' ').split(/\s+/).filter(word => word.length > 0).length;
  }
  
  /**
   * Ensure file path is absolute
   * @param {string} filePath - File path (may be relative or absolute)
   * @param {string} basePath - Base path to prepend for relative paths
   * @returns {string} - Absolute file path
   */
  ensureAbsolutePath(filePath, basePath) {
    if (!filePath) return filePath;
    
    // Check if the path is already absolute
    if (path.isAbsolute(filePath)) {
      return filePath;
    }
    
    // Make the path absolute by joining with the base path
    return path.join(basePath, filePath);
  }
}

module.exports = BrainstormTool;


============================================================
FILE: chapter-writer.js
SIZE: 34035 bytes
LANGUAGE: JS
============================================================

// chapter-writer.js
const BaseTool = require('./base-tool');
const path = require('path');
const fileCache = require('./file-cache');
const appState = require('./state.js');
const fs = require('fs/promises');

/**
 * ChapterWriter Tool
 * Uses the outline, chapters list, world document, and any existing manuscript to write rough draft chapters
 */
class ChapterWriter extends BaseTool {
  /**
   * Constructor
   * @param {Object} GeminiAPIService - Claude API service
   * @param {Object} config - Tool configuration
   */
  constructor(GeminiAPIService, config = {}) {
    super('chapter_writer', config);
    this.GeminiAPIService = GeminiAPIService;
    // console.log('ChapterWriter Tool initialized with config:', config);
  }
  
  /**
   * Execute the tool
   * @param {Object} options - Tool options
   * @returns {Promise<Object>} - Execution result
   */
  async execute(options) {
    console.log('Executing ChapterWriter with options:', options);
    
    // Clear the cache for this tool
    const toolName = 'chapter_writer';
    fileCache.clear(toolName);
    
    // Extract options
    const request = options.request;
    const chaptersToWrite = options.chapters_to_write;
    const manuscriptFile = options.manuscript || 'manuscript.txt';
    const outlineFile = options.outline || 'outline.txt';
    const worldFile = options.world || 'world.txt';
    const language = options.lang || 'English';
    const chapterDelay = options.chapter_delay || 15;
    const noDialogueEmphasis = options.no_dialogue_emphasis || false;
    const noAppend = options.no_append || false;
    const backup = options.backup || false;
    const showTokenStats = options.show_token_stats || false;
    
    const saveDir = options.save_dir || appState.CURRENT_PROJECT_PATH;
    const outputFiles = [];
    const summary = [];
    
    // Validate save directory
    if (!saveDir) {
      const errorMsg = 'Error: No save directory specified and no current project selected.\n' +
                      'Please select a project or specify a save directory.';
      this.emitOutput(errorMsg);
      throw new Error('No save directory available');
    }
    
    // Validate that either request or chaptersToWrite is provided
    if (!request && !chaptersToWrite) {
      const errorMsg = 'Error: You must provide either request for a single chapter or chapters_to_write for multiple chapters.\n';
      this.emitOutput(errorMsg);
      throw new Error('No chapter request provided');
    }
    
    try {
      // If chapters_to_write is provided, process multiple chapters
      if (chaptersToWrite) {
        // Read chapters list file
        this.emitOutput(`Reading chapters to write from: ${chaptersToWrite}\n`);
        const chaptersPath = this.ensureAbsolutePath(chaptersToWrite, saveDir);
        const chaptersContent = await this.readInputFile(chaptersPath);
        
        // Parse chapter list - non-empty lines
        const chapterList = chaptersContent
          .split('\n')
          .map(line => line.trim())
          .filter(line => line.length > 0);
        
        if (chapterList.length === 0) {
          this.emitOutput(`Error: Chapters file is empty: ${chaptersToWrite}\n`);
          throw new Error('Chapters file is empty');
        }
        
        this.emitOutput(`Found ${chapterList.length} chapters to process:\n`);
        chapterList.forEach((chapter, index) => {
          this.emitOutput(`  ${index + 1}. ${chapter}\n`);
        });
        
        // Process each chapter with a delay between them
        for (let i = 0; i < chapterList.length; i++) {
          const chapterRequest = chapterList[i];
          
          this.emitOutput(`\nProcessing chapter ${i + 1} of ${chapterList.length}: ${chapterRequest}\n`);
          
          const result = await this.processChapter(
            chapterRequest,
            manuscriptFile,
            outlineFile,
            worldFile,
            language,
            noDialogueEmphasis,
            noAppend,
            backup,
            showTokenStats,
            saveDir,
            i + 1,
            chapterList.length
          );
          
          if (result) {
            outputFiles.push(result.chapterFile);
            if (result.thinkingFile) {
              outputFiles.push(result.thinkingFile);
            }
            summary.push(result);
          }
          
          // If this isn't the last chapter, wait before processing the next one
          if (i < chapterList.length - 1) {
            this.emitOutput(`Waiting ${chapterDelay} seconds before next chapter...\n`);
            await new Promise(resolve => setTimeout(resolve, chapterDelay * 1000));
          }
        }
        
        // Output summary of all processed chapters
        this.emitOutput("\n" + "=".repeat(80) + "\n");
        this.emitOutput("SUMMARY OF ALL CHAPTERS PROCESSED\n");
        this.emitOutput("=".repeat(80) + "\n");
        
        let totalWords = 0;
        let totalTime = 0;
        
        for (const result of summary) {
          totalWords += result.wordCount;
          totalTime += result.elapsedTime;
          const minutes = Math.floor(result.elapsedTime / 60);
          const seconds = result.elapsedTime % 60;
          
          this.emitOutput(`Chapter ${result.chapterNum}: ${result.wordCount} words, ${minutes}m ${seconds.toFixed(1)}s, saved to: ${path.basename(result.chapterFile)}\n`);
        }
        
        // Calculate averages and totals
        const avgWords = summary.length > 0 ? totalWords / summary.length : 0;
        const totalMinutes = Math.floor(totalTime / 60);
        const totalSeconds = totalTime % 60;
        
        this.emitOutput(`\nTotal chapters: ${summary.length}\n`);
        this.emitOutput(`Total words: ${totalWords}\n`);
        this.emitOutput(`Average words per chapter: ${avgWords.toFixed(1)}\n`);
        this.emitOutput(`Total time: ${totalMinutes}m ${totalSeconds.toFixed(1)}s\n`);
        this.emitOutput("=".repeat(80) + "\n");
      } else {
        // Process a single chapter
        const result = await this.processChapter(
          request,
          manuscriptFile,
          outlineFile,
          worldFile,
          language,
          noDialogueEmphasis,
          noAppend,
          backup,
          showTokenStats,
          saveDir
        );
        
        if (result) {
          outputFiles.push(result.chapterFile);
          if (result.thinkingFile) {
            outputFiles.push(result.thinkingFile);
          }
          summary.push(result);
        }
      }
      
      // Add all files to the cache
      for (const file of outputFiles) {
        fileCache.addFile(toolName, file);
      }
      
      return {
        success: true,
        outputFiles,
        stats: {
          chapterCount: summary.length,
          totalWords: summary.reduce((sum, result) => sum + result.wordCount, 0),
          elapsedTime: summary.reduce((sum, result) => sum + result.elapsedTime, 0)
        }
      };
      
    } catch (error) {
      console.error('Error in ChapterWriter:', error);
      this.emitOutput(`\nError: ${error.message}\n`);
      throw error;
    }
  }
  
  /**
   * Process a single chapter
   * @param {string} chapterRequest - Chapter request text
   * @param {string} manuscriptFile - Path to manuscript file
   * @param {string} outlineFile - Path to outline file
   * @param {string} worldFile - Path to world file
   * @param {string} language - Language to write in
   * @param {boolean} noDialogueEmphasis - Whether to disable dialogue emphasis
   * @param {boolean} noAppend - Whether to disable auto-appending to manuscript
   * @param {boolean} backup - Whether to create a backup of manuscript
   * @param {boolean} showTokenStats - Whether to only show token stats without generation
   * @param {string} saveDir - Directory to save output files
   * @param {number} currentIdx - Current chapter index (for multiple chapters)
   * @param {number} totalChapters - Total number of chapters (for multiple chapters)
   * @returns {Promise<Object>} - Result of chapter processing
   */
  async processChapter(
    chapterRequest,
    manuscriptFile,
    outlineFile,
    worldFile,
    language,
    noDialogueEmphasis,
    noAppend,
    backup,
    showTokenStats,
    saveDir,
    currentIdx = null,
    totalChapters = null
  ) {
    try {
      // Extract chapter number and formatted chapter number
      const { chapterNum, formattedChapter } = this.extractChapterNum(chapterRequest);
      
      // Log processing info
      const currentTime = new Date().toLocaleTimeString('en-US', { 
        hour: 'numeric', 
        minute: '2-digit', 
        second: '2-digit', 
        hour12: true 
      }).toLowerCase().replace(/^0/, '');
      
      if (currentIdx !== null && totalChapters !== null) {
        this.emitOutput(`${currentTime} - Processing chapter ${currentIdx} of ${totalChapters}: Chapter ${chapterNum}\n`);
      } else {
        this.emitOutput(`${currentTime} - Processing: Chapter ${chapterNum}\n`);
      }
      
      // Read files
      // Read outline file (required)
      let outlineContent = "";
      try {
        this.emitOutput(`Reading outline file: ${outlineFile}\n`);
        outlineContent = await this.readInputFile(this.ensureAbsolutePath(outlineFile, saveDir));
      } catch (error) {
        this.emitOutput(`Error: Required outline file not found: ${outlineFile}\n`);
        this.emitOutput("The outline file is required to continue.\n");
        throw error;
      }
      
      // Read manuscript file or create it if it doesn't exist
      let novelContent = "";
      try {
        this.emitOutput(`Reading manuscript file: ${manuscriptFile}\n`);
        novelContent = await this.readInputFile(this.ensureAbsolutePath(manuscriptFile, saveDir));
      } catch (error) {
        this.emitOutput(`Error: Required manuscript file not found: ${manuscriptFile}\n`);
        this.emitOutput("Creating a new manuscript file.\n");
        
        // Create an empty manuscript file
        await fs.writeFile(this.ensureAbsolutePath(manuscriptFile, saveDir), "");
      }
      
      // Read world file (optional)
      let worldContent = "";
      try {
        this.emitOutput(`Reading world file: ${worldFile}\n`);
        worldContent = await this.readInputFile(this.ensureAbsolutePath(worldFile, saveDir));
      } catch (error) {
        this.emitOutput(`Note: World file not found: ${worldFile}\n`);
        this.emitOutput("Continuing without world information.\n");
        // Don't throw an error - continue with empty worldContent
      }
      
      // Format chapter request for consistency in prompt
      const formattedRequest = this.formatChapterRequest(chapterRequest);
      const formattedOutlineRequest = this.formatOutlineRequest(chapterRequest);
      
      // Create prompt
      const prompt = this.createChapterPrompt(
        formattedRequest,
        formattedOutlineRequest,
        outlineContent,
        worldContent,
        novelContent,
        language,
        noDialogueEmphasis
      );
      
      // Create a prompt version for logging (without full file content)
      const promptForLogging = this.createPromptForLogging(
        formattedOutlineRequest,
        language,
        noDialogueEmphasis
      );
      
      // Count tokens in prompt
      this.emitOutput(`Counting tokens in prompt...\n`);
      const promptTokens = await this.GeminiAPIService.countTokens(prompt);
      
      // Calculate available tokens after prompt
      const contextWindow = this.config.context_window || 200000;
      const desiredOutputTokens = this.config.desired_output_tokens || 12000;
      const configuredThinkingBudget = this.config.thinking_budget_tokens || 32000;
      const betasMaxTokens = this.config.betas_max_tokens || 128000;
      
      const availableTokens = contextWindow - promptTokens;
      
      // For API call, max_tokens must respect the API limit
      const maxTokens = Math.min(availableTokens, betasMaxTokens);
      
      // Thinking budget must be LESS than max_tokens to leave room for visible output
      const thinkingBudget = maxTokens - desiredOutputTokens;
      
      // Display token stats
      this.emitOutput(`\nToken stats:\n`);
      this.emitOutput(`Max AI model context window: [${contextWindow}] tokens\n`);
      this.emitOutput(`Input prompt tokens: [${promptTokens}] ...\n`);
      this.emitOutput(`                     = request + chapters.txt + manuscript.txt\n`);
      this.emitOutput(`                       + outline.txt + world.txt + prompt instructions\n`);
      this.emitOutput(`Available tokens: [${availableTokens}]  = ${contextWindow} - ${promptTokens} = context_window - prompt\n`);
      this.emitOutput(`Desired output tokens: [${desiredOutputTokens}]\n`);
      this.emitOutput(`AI model thinking budget: [${thinkingBudget}] tokens  = ${maxTokens} - ${desiredOutputTokens}\n`);
      this.emitOutput(`Max output tokens (max_tokens): [${maxTokens}] tokens  = min(${availableTokens}, ${betasMaxTokens})\n`);
      this.emitOutput(`                                = can not exceed: 'betas=["output-128k-2025-02-19"]'\n`);
      
      // Check if prompt is too large for the configured thinking budget
      if (thinkingBudget < configuredThinkingBudget) {
        this.emitOutput(`Error: prompt is too large to have a ${configuredThinkingBudget} thinking budget!\n`);
        this.emitOutput(`Run aborted!\n`);
        throw new Error(`Prompt is too large for ${configuredThinkingBudget} thinking budget - run aborted`);
      }
      
      // Show token stats only if requested
      if (showTokenStats) {
        this.emitOutput(`FYI: token stats shown without creating chapters, to aid in making adjustments.\n`);
        this.emitOutput(`\nNote: with Claude 3.7 Sonnet, 'max_tokens' is enforced as a strict limit,\n`);
        this.emitOutput(`      which includes your thinking budget when thinking is enabled.\n`);
        this.emitOutput(`      So Claude API will now return a validation error if:\n`);
        this.emitOutput(`      'prompt tokens' + 'max_tokens' exceeds the 'context window' size.\n`);
        this.emitOutput(`      Where 'prompt tokens' includes: request, chapters.txt, manuscript.txt, outline.txt, world.txt,\n`);
        this.emitOutput(`      and the prompt instructions to the AI -- see: 'Input prompt tokens:' for each run.\n`);
        return null;
      }
      
      // Call Claude API with streaming
      this.emitOutput(`Sending request to Claude API (streaming)...\n`);
      
      const startTime = Date.now();
      let fullResponse = "";
      let thinkingContent = "";
      
      // Create system prompt to avoid markdown
      const systemPrompt = "NO Markdown! Never respond with Markdown formatting, plain text only.";
      
      try {
        // Use streaming API call
        await this.GeminiAPIService.streamWithThinking(
          prompt,
          {
            model: "claude-3-7-sonnet-20250219",
            system: systemPrompt,
            max_tokens: maxTokens,
            thinking: {
              type: "enabled",
              budget_tokens: thinkingBudget
            },
            betas: ["output-128k-2025-02-19"]
          },
          // Callback for thinking content
          (thinkingDelta) => {
            thinkingContent += thinkingDelta;
          },
          // Callback for response text - simply accumulate without progress indicators
          (textDelta) => {
            fullResponse += textDelta;
          }
        );
      } catch (error) {
        this.emitOutput(`\n*** Error during generation:\n${error.message}\n`);
        throw error;
      }
      
      // Calculate elapsed time
      const elapsed = (Date.now() - startTime) / 1000;
      const minutes = Math.floor(elapsed / 60);
      const seconds = elapsed % 60;
      
      // Clean response (skipping the complex cleaning functions from Python for now)
      const cleanedResponse = fullResponse;
      
      // Create timestamp for filename
      const timestamp = new Date().toISOString().replace(/[-:.]/g, '').substring(0, 15);
      const chapterFilename = `${formattedChapter}_chapter_${timestamp}.txt`;
      const chapterPath = path.join(saveDir, chapterFilename);
      
      // Write chapter to file
      await this.writeOutputFile(cleanedResponse, saveDir, chapterFilename);
      
      // Count words in chapter
      const chapterWordCount = this.countWords(cleanedResponse);
      
      // Count tokens in chapter
      const chapterTokenCount = await this.GeminiAPIService.countTokens(cleanedResponse);
      
      // Append the new chapter to the manuscript file if not disabled
      if (!noAppend) {
        const appendSuccess = await this.appendToManuscript(
          cleanedResponse, 
          this.ensureAbsolutePath(manuscriptFile, saveDir), 
          backup
        );
        
        if (appendSuccess) {
          this.emitOutput(`Chapter ${chapterNum} appended to manuscript file: ${manuscriptFile}\n`);
        } else {
          this.emitOutput(`Warning: Failed to append chapter to manuscript file\n`);
        }
      }
      
      // Stats for thinking file
      const stats = `
Details:
Max request timeout: ${this.config.request_timeout || 300} seconds
Max retries: ${this.config.max_retries || 1}
Max AI model context window: ${contextWindow} tokens
Input prompt tokens: ${promptTokens}
AI model thinking budget: ${thinkingBudget} tokens
Max output tokens: ${maxTokens} tokens
Elapsed time: ${minutes}m ${seconds.toFixed(2)}s
Chapter ${chapterNum}: ${chapterWordCount} words
Chapter ${chapterNum} token count: ${chapterTokenCount}
`;
      
      // Save thinking content if available
      let thinkingPath = null;
      if (thinkingContent) {
        const thinkingTokenCount = await this.GeminiAPIService.countTokens(thinkingContent);
        const thinkingEfficiency = (thinkingTokenCount / thinkingBudget) * 100;
        const thinkingToOutputRatio = thinkingTokenCount / chapterTokenCount;
        
        const analytics = `
--------------------------
CHAPTER GENERATION METRICS
--------------------------
Token Counts:
- Thinking tokens used: ${thinkingTokenCount.toLocaleString()} of ${thinkingBudget.toLocaleString()} (${thinkingEfficiency.toFixed(1)}%)
- Chapter output tokens: ${chapterTokenCount.toLocaleString()}
- Thinking-to-output ratio: ${thinkingToOutputRatio.toFixed(2)}:1

Notes:
1. Token counts were calculated using full API parameters to match 
   the actual token accounting used for API billing.

2. The thinking token count represents the raw content returned 
   by the API. This gives insight into how much reasoning Claude 
   performed before producing the chapter.
   
3. A higher thinking-to-output ratio typically indicates more 
   extensive reasoning before generating content, which may 
   correlate with more complex narrative development.

4. The API does not provide details about exact internal 
   tokens or time usage, so this is just an estimate based
   on token counts alone.
`;
        
        const thinkingFilename = `${formattedChapter}_thinking_${timestamp}.txt`;
        thinkingPath = path.join(saveDir, thinkingFilename);
        
        const thinkingContent2 = `=== PROMPT USED (EXCLUDING NOVEL CONTENT) ===
${promptForLogging}

=== AI'S THINKING PROCESS ===

${thinkingContent}

=== END AI'S THINKING PROCESS ===
${stats}
${analytics}
###
`;
        
        await this.writeOutputFile(thinkingContent2, saveDir, thinkingFilename);
        this.emitOutput(`AI thinking saved to: ${thinkingPath}\n`);
      }
      
      this.emitOutput(`Completed Chapter ${chapterNum}: ${chapterWordCount} words (${minutes}m ${seconds.toFixed(2)}s) - saved to: ${path.basename(chapterPath)}\n`);
      
      // Return chapter information
      return {
        chapterNum,
        wordCount: chapterWordCount, 
        tokenCount: chapterTokenCount,
        elapsedTime: elapsed,
        chapterFile: chapterPath,
        thinkingFile: thinkingPath
      };
      
    } catch (error) {
      console.error('Error processing chapter:', error);
      this.emitOutput(`\nError processing chapter: ${error.message}\n`);
      throw error;
    }
  }
  
  /**
   * Extract chapter number from request
   * @param {string} request - Chapter request text
   * @returns {Object} - Chapter number and formatted chapter number
   */
  extractChapterNum(request) {
    // Check for the different formats
    const fullPattern = /^Chapter\s+(\d+)[:\.]?\s+(.+)$/i;
    const colonPattern = /^(\d+):\s+(.+)$/;
    const periodPattern = /^(\d+)\.\s+(.+)$/;
    
    let chapterNum;
    let fullMatch = request.match(fullPattern);
    let colonMatch = request.match(colonPattern);
    let periodMatch = request.match(periodPattern);
    
    if (fullMatch) {
      chapterNum = fullMatch[1];
    } else if (colonMatch) {
      chapterNum = colonMatch[1];
    } else if (periodMatch) {
      chapterNum = periodMatch[1];
    } else {
      this.emitOutput("\nERROR: it's best to copy your next chapter number and title from your outline, as\n");
      this.emitOutput("'--request' must be like:\n\t--request \"Chapter X: Title\"\n...or\n\t--request \"X: Title\"\n...or\n\t--request \"X. Title\"\n... where X is a number.\n");
      this.emitOutput(`But your request was: '${request}'\n\n`);
      throw new Error('Invalid chapter request format');
    }
    
    // Format the chapter number as 3-digit
    const formattedChapter = String(parseInt(chapterNum)).padStart(3, '0');
    
    return { chapterNum, formattedChapter };
  }
  
  /**
   * Format chapter request for consistency in the prompt
   * @param {string} request - Chapter request text
   * @returns {string} - Formatted chapter request
   */
  formatChapterRequest(request) {
    // Check if already in "Chapter X: Title" format
    if (/^Chapter\s+\d+/i.test(request)) {
      return request;
    }
    
    // Extract number and title
    const match = request.match(/^(\d+)[:\.]?\s+(.+)$/);
    if (match) {
      const [, num, title] = match;
      return `Chapter ${num}: ${title}`;
    }
    
    // Fallback (should never happen due to extractChapterNum validation)
    return request;
  }
  
  /**
   * Format outline request for consistency
   * @param {string} request - Chapter request text
   * @returns {string} - Formatted outline request
   */
  formatOutlineRequest(request) {
    // Check if already in "Chapter X: Title" format
    if (/^Chapter\s+\d+/i.test(request)) {
      // Convert to "Chapter X. Title" format
      return request.replace(/^(Chapter\s+\d+):\s+(.+)$/i, '$1. $2');
    }
    
    // Extract number and title
    const match = request.match(/^(\d+)[:\.]?\s+(.+)$/);
    if (match) {
      const [, num, title] = match;
      return `Chapter ${num}. ${title}`;
    }
    
    // Fallback
    return request;
  }
  
  /**
   * Create the chapter prompt
   * @param {string} formattedRequest - Formatted chapter request
   * @param {string} formattedOutlineRequest - Formatted outline request for consistency
   * @param {string} outlineContent - Content of outline file
   * @param {string} worldContent - Content of world file
   * @param {string} novelContent - Content of manuscript file
   * @param {string} language - Language to write in
   * @param {boolean} noDialogueEmphasis - Whether to disable dialogue emphasis
   * @returns {string} - Complete prompt for Claude API
   */
  createChapterPrompt(
    formattedRequest,
    formattedOutlineRequest,
    outlineContent,
    worldContent,
    novelContent,
    language,
    noDialogueEmphasis
  ) {
    // Dialogue emphasis option - included by default unless disabled
    let dialogueOption = "";
    if (!noDialogueEmphasis) {
      dialogueOption = `
- DIALOGUE EMPHASIS: Significantly increase the amount of dialogue, both external conversations between characters and internal thoughts/monologues. At least 40-50% of the content should be dialogue. Use dialogue to reveal character, advance plot, create tension, and show (rather than tell) emotional states. Ensure each character's dialogue reflects their unique personality, background, and relationship dynamics as established in the WORLD and MANUSCRIPT.
`;
    }
    
    // Character restriction is always included
    const characterRestriction = `- CHARACTER RESTRICTION: Do NOT create any new named characters. Only use characters explicitly mentioned in the WORLD, OUTLINE, or MANUSCRIPT. You may only add minimal unnamed incidental characters when absolutely necessary (e.g., a waiter, cashier, landlord) but keep these to an absolute minimum.
- WORLD FOCUS: Make extensive use of the world details provided in the WORLD section. Incorporate the settings, locations, history, culture, and atmosphere described there to create an immersive, consistent environment.
`;
    
    return `=== OUTLINE ===
${outlineContent}
=== END OUTLINE ===

=== WORLD ===
${worldContent}
=== END WORLD ===

=== EXISTING MANUSCRIPT ===
${novelContent}
=== END EXISTING MANUSCRIPT ===

You are a skilled novelist writing ${formattedRequest} in fluent, authentic ${language}. 
Draw upon your knowledge of worldwide literary traditions, narrative techniques, and creative approaches from across cultures, while expressing everything in natural, idiomatic ${language} that honors its unique linguistic character.

Consider the following in your thinking:
- IMPORTANT: always review the included WORLD, OUTLINE, and MANUSCRIPT
- Refer to the included WORLD of characters and settings provided
- Analyze how each chapter advances the overall narrative and character development
- Creating compelling opening and closing scenes
- Incorporating sensory details and vivid descriptions
- Maintaining consistent tone and style with previous chapters
- Do NOT add new characters, only used characters from: WORLD, OUTLINE, and MANUSCRIPT

IMPORTANT:
- NO Markdown formatting
- Use hyphens only for legitimate ${language} words
- Begin with: ${formattedOutlineRequest} and write in plain text only
- Write 2,000-3,000 words
- Do not repeat content from existing chapters
- Do not start working on the next chapter
- Maintain engaging narrative pacing through varied sentence structure, strategic scene transitions, and appropriate balance between action, description, and reflection
- Prioritize natural, character-revealing dialogue as the primary narrative vehicle, ensuring each conversation serves multiple purposes (character development, plot advancement, conflict building). Include distinctive speech patterns for different characters, meaningful subtext, and strategic dialogue beats, while minimizing lengthy exposition and internal reflection.
- Write all times in 12-hour numerical format with a space before lowercase am/pm (e.g., "10:30 am," "2:15 pm," "7:00 am") rather than spelling them out as words or using other formats
- Prioritize lexical diversity by considering multiple alternative word choices before finalizing each sentence. For descriptive passages especially, select precise, context-specific terminology rather than relying on common metaphorical language. When using figurative language, vary the sensory domains from which metaphors are drawn (visual, auditory, tactile, etc.). Actively monitor your own patterns of word selection across paragraphs and deliberately introduce variation.
- In your 'thinking' before writing always indicate and explain what you're using from: WORLD, OUTLINE, and MANUSCRIPT (previous chapters)${dialogueOption}${characterRestriction}
`;
  }
  
  /**
   * Create a logging version of the prompt without file contents
   * @param {string} formattedOutlineRequest - Formatted outline request
   * @param {string} language - Language to write in
   * @param {boolean} noDialogueEmphasis - Whether to disable dialogue emphasis
   * @returns {string} - Prompt for logging
   */
  createPromptForLogging(formattedOutlineRequest, language, noDialogueEmphasis) {
    // Dialogue emphasis option - included by default unless disabled
    let dialogueOption = "";
    if (!noDialogueEmphasis) {
      dialogueOption = `
- DIALOGUE EMPHASIS: Significantly increase the amount of dialogue, both external conversations between characters and internal thoughts/monologues. At least 40-50% of the content should be dialogue. Use dialogue to reveal character, advance plot, create tension, and show (rather than tell) emotional states. Ensure each character's dialogue reflects their unique personality, background, and relationship dynamics as established in the WORLD and MANUSCRIPT.
`;
    }
    
    // Character restriction is always included
    const characterRestriction = `- CHARACTER RESTRICTION: Do NOT create any new named characters. Only use characters explicitly mentioned in the WORLD, OUTLINE, or MANUSCRIPT. You may only add minimal unnamed incidental characters when absolutely necessary (e.g., a waiter, cashier, landlord) but keep these to an absolute minimum.
- WORLD FOCUS: Make extensive use of the world details provided in the WORLD section. Incorporate the settings, locations, history, culture, and atmosphere described there to create an immersive, consistent environment.
`;
    
    return `You are a skilled novelist writing ${formattedOutlineRequest} in fluent, authentic ${language}. 
Draw upon your knowledge of worldwide literary traditions, narrative techniques, and creative approaches from across cultures, while expressing everything in natural, idiomatic ${language} that honors its unique linguistic character.

Consider the following in your thinking:
- IMPORTANT: always review the included OUTLINE thoroughly 
- Refer to the included WORLD of characters and settings, if provided
- How this chapter advances the overall narrative and character development
- Creating compelling opening and closing scenes
- Incorporating sensory details and vivid descriptions
- Maintaining consistent tone and style with previous chapters

IMPORTANT:
- NO Markdown formatting
- Use hyphens only for legitimate ${language} words
- Begin with: ${formattedOutlineRequest} and write in plain text only
- Write 2,000-3,000 words
- Do not repeat content from existing chapters
- Do not start working on the next chapter
- Maintain engaging narrative pacing through varied sentence structure, strategic scene transitions, and appropriate balance between action, description, and reflection
- Prioritize natural, character-revealing dialogue as the primary narrative vehicle, ensuring each conversation serves multiple purposes (character development, plot advancement, conflict building). Include distinctive speech patterns for different characters, meaningful subtext, and strategic dialogue beats, while minimizing lengthy exposition and internal reflection.
- Write all times in 12-hour numerical format with a space before lowercase am/pm (e.g., "10:30 am," "2:15 pm," "7:00 am") rather than spelling them out as words or using other formats
- Prioritize lexical diversity by considering multiple alternative word choices before finalizing each sentence. For descriptive passages especially, select precise, context-specific terminology rather than relying on common metaphorical language. When using figurative language, vary the sensory domains from which metaphors are drawn (visual, auditory, tactile, etc.). Actively monitor your own patterns of word selection across paragraphs and deliberately introduce variation.
- In your 'thinking' before writing always indicate and explain what you're using from: WORLD, OUTLINE, and MANUSCRIPT (previous chapters)${dialogueOption}${characterRestriction}
note: The actual prompt included the outline, world, manuscript which are not logged to save space.
`;
  }
  
  /**
   * Append the new chapter to the manuscript file
   * @param {string} chapterText - Text of the new chapter
   * @param {string} manuscriptPath - Path to the manuscript file
   * @param {boolean} backup - Whether to create a backup
   * @returns {Promise<boolean>} - Whether appending was successful
   */
  async appendToManuscript(chapterText, manuscriptPath, backup) {
    try {
      // Read the existing manuscript
      let manuscriptContent = await fs.readFile(manuscriptPath, 'utf8');
      
      // Create backup if requested
      if (backup) {
        const timestamp = new Date().toISOString().replace(/[-:.]/g, '').substring(0, 15);
        const backupPath = `${manuscriptPath}_${timestamp}.bak`;
        await fs.writeFile(backupPath, manuscriptContent);
      }
      
      // Ensure manuscript ends with exactly one newline
      manuscriptContent = manuscriptContent.trim() + '\n';
      
      // Append chapter with proper formatting (two blank lines)
      const updatedContent = manuscriptContent + '\n\n' + chapterText;
      
      // Write updated content back to manuscript
      await fs.writeFile(manuscriptPath, updatedContent);
      
      return true;
    } catch (error) {
      console.error('Error appending to manuscript:', error);
      this.emitOutput(`Error appending to manuscript: ${error.message}\n`);
      return false;
    }
  }
  
  /**
   * Count words in text
   * @param {string} text - Text to count words in
   * @returns {number} - Word count
   */
  countWords(text) {
    return text.replace(/(\r\n|\r|\n)/g, ' ').split(/\s+/).filter(word => word.length > 0).length;
  }
  
  /**
   * Ensure file path is absolute
   * @param {string} filePath - File path (may be relative or absolute)
   * @param {string} basePath - Base path to prepend for relative paths
   * @returns {string} - Absolute file path
   */
  ensureAbsolutePath(filePath, basePath) {
    if (!filePath) return filePath;
    
    // Check if the path is already absolute
    if (path.isAbsolute(filePath)) {
      return filePath;
    }
    
    // Make the path absolute by joining with the base path
    return path.join(basePath, filePath);
  }
}

module.exports = ChapterWriter;


============================================================
FILE: character-analyzer.js
SIZE: 15375 bytes
LANGUAGE: JS
============================================================

// character-analyzer.js
const BaseTool = require('./base-tool');
const path = require('path');
const fileCache = require('./file-cache');
const appState = require('./state.js');
const fs = require('fs/promises');

/**
 * Character Analyzer Tool
 * Analyzes manuscript, outline, and world files to identify 
 * and compare character appearances across different story documents
 */
class CharacterAnalyzer extends BaseTool {
  /**
   * Constructor
   * @param {Object} GeminiAPIService - Claude API service
   * @param {Object} config - Tool configuration
   */
  constructor(GeminiAPIService, config = {}) {
    super('character_analyzer', config);
    this.GeminiAPIService = GeminiAPIService;
  }
  
  /**
   * Count words in text
   * @param {string} text - Text to count words in
   * @returns {number} - Word count
   */
  countWords(text) {
    return text.split(/\s+/).filter(word => word.length > 0).length;
  }
  
  /**
   * Execute the tool
   * @param {Object} options - Tool options
   * @returns {Promise<Object>} - Execution result
   */
  async execute(options) {
    console.log('Executing CharacterAnalyzer with options:', options);
    
    // Extract options
    let manuscriptFile = options.manuscript_file;
    let outlineFile = options.outline_file;
    let worldFile = options.world_file;
    const saveDir = options.save_dir || appState.CURRENT_PROJECT_PATH;
    
    if (!saveDir) {
      const errorMsg = 'Error: No save directory specified and no current project selected.\n' +
                      'Please select a project or specify a save directory.';
      this.emitOutput(errorMsg);
      throw new Error('No save directory available');
    }

    // Ensure file paths are absolute
    manuscriptFile = this.ensureAbsolutePath(manuscriptFile, saveDir);
    
    if (outlineFile) {
      outlineFile = this.ensureAbsolutePath(outlineFile, saveDir);
    }
    
    if (worldFile) {
      worldFile = this.ensureAbsolutePath(worldFile, saveDir);
    }
    
    // Log the full paths for debugging
    console.log('Using full paths:');
    console.log(`Manuscript: ${manuscriptFile}`);
    if (outlineFile) console.log(`Outline: ${outlineFile}`);
    if (worldFile) console.log(`World: ${worldFile}`);

    const outputFiles = [];
    
    try {
      // Read the input files
      this.emitOutput(`Reading files...\n`);

      // Read the manuscript file
      this.emitOutput(`Reading manuscript file: ${manuscriptFile}\n`);
      const manuscriptContent = await this.readInputFile(manuscriptFile);
      
      // Read the outline file if provided
      let outlineContent = '';
      if (outlineFile) {
        this.emitOutput(`Reading outline file: ${outlineFile}\n`);
        outlineContent = await this.readInputFile(outlineFile);
      }
      
      // Read the world file if provided
      let worldContent = '';
      if (worldFile) {
        this.emitOutput(`Reading world file: ${worldFile}\n`);
        worldContent = await this.readInputFile(worldFile);
      }
      
      // Create the prompt
      const prompt = this.createCharacterAnalysisPrompt(manuscriptContent, outlineContent, worldContent);

      // Count tokens in the prompt
      this.emitOutput(`Counting tokens in prompt...\n`);
      const promptTokens = await this.GeminiAPIService.countTokens(prompt);

      // Call the shared token budget calculator
      const tokenBudgets = this.GeminiAPIService.calculateTokenBudgets(promptTokens);

      // Handle logging based on the returned values
      this.emitOutput(`\nToken stats:\n`);
      this.emitOutput(`Max AI model context window: [${tokenBudgets.contextWindow}] tokens\n`);
      this.emitOutput(`Input prompt tokens: [${tokenBudgets.promptTokens}] sent to Claude\n`);
      this.emitOutput(`Available tokens: [${tokenBudgets.availableTokens}]  = ${tokenBudgets.contextWindow} - ${tokenBudgets.promptTokens} = context_window - prompt\n`);
      this.emitOutput(`Desired output tokens: [${tokenBudgets.desiredOutputTokens}]\n`);
      this.emitOutput(`AI model thinking budget: [${tokenBudgets.thinkingBudget}] tokens\n`);
      this.emitOutput(`Max output tokens: [${tokenBudgets.maxTokens}] tokens\n`);

      // Check for special conditions
      if (tokenBudgets.capThinkingBudget) {
        this.emitOutput(`Warning: thinking budget is larger than 32K, set to 32K.\n`);
      }

      // Check if the prompt is too large
      if (tokenBudgets.isPromptTooLarge) {
        this.emitOutput(`Error: prompt is too large to have a ${tokenBudgets.configuredThinkingBudget} thinking budget!\n`);
        this.emitOutput(`Run aborted!\n`);
        throw new Error(`Prompt is too large for ${tokenBudgets.configuredThinkingBudget} thinking budget - run aborted`);
      }
      
      // Call Claude API with streaming
      this.emitOutput(`\nSending request to Claude API . . .\n`);
      
      // Add a message about waiting
      this.emitOutput(`\n****************************************************************************\n`);
      this.emitOutput(`*  Analyzing characters in manuscript.  \n`);
      this.emitOutput(`*                                                                          \n`);
      this.emitOutput(`*  This process typically takes several minutes.                           \n`);
      this.emitOutput(`*                                                                          \n`);
      this.emitOutput(`*  It's recommended to keep this window the sole 'focus'                   \n`);
      this.emitOutput(`*  and to avoid browsing online or running other apps, as these API        \n`);
      this.emitOutput(`*  network connections are often flakey, like delicate echoes of whispers. \n`);
      this.emitOutput(`*                                                                          \n`);
      this.emitOutput(`*  So breathe, remove eye glasses, stretch, relax, and be like water 🥋 🧘🏽‍♀️\n`);
      this.emitOutput(`****************************************************************************\n\n`);
      
      const startTime = Date.now();
      let fullResponse = "";
      let thinkingContent = "";
      
      // Create system prompt to avoid markdown
      const systemPrompt = "CRITICAL INSTRUCTION: NO Markdown formatting of ANY kind. Never use headers, bullets, or any formatting symbols. Plain text only with standard punctuation.";

      // Use the calculated values in the API call
      try {
        await this.GeminiAPIService.streamWithThinkingAndMessageStart(
          prompt,
          {
            model: "claude-3-7-sonnet-20250219",
            system: systemPrompt,
            max_tokens: tokenBudgets.maxTokens,
            thinking: {
              type: "enabled",
              budget_tokens: tokenBudgets.thinkingBudget
            },
            betas: ["output-128k-2025-02-19"]
          },
          // callback for thinking content
          (thinkingDelta) => {
            thinkingContent += thinkingDelta;
          },
          // callback for response text
          (textDelta) => {
            fullResponse += textDelta;
          },
          // callback for message start with stats
          (messageStart) => {
            this.emitOutput(`${messageStart}\n`);
          },
          // callback for response headers
          (responseHeaders) => {
            this.emitOutput(`${responseHeaders}\n`);
          },
          // callback for status
          (callStatus) => {
            this.emitOutput(`${callStatus}\n`);
          },
        );
      } catch (error) {
        this.emitOutput(`\nAPI Error: ${error.message}\n`);
        throw error;
      }

      const elapsed = (Date.now() - startTime) / 1000;
      const minutes = Math.floor(elapsed / 60);
      const seconds = elapsed % 60;
      
      this.emitOutput(`\nCompleted in ${minutes}m ${seconds.toFixed(2)}s.\n`);
      
      // Count words in response
      const wordCount = this.countWords(fullResponse);
      this.emitOutput(`Report has approximately ${wordCount} words.\n`);
      
      // Count tokens in response
      const responseTokens = await this.GeminiAPIService.countTokens(fullResponse);
      this.emitOutput(`Response token count: ${responseTokens}\n`);

      // Remove any markdown formatting
      fullResponse = this.removeMarkdown(fullResponse);

      // Save the report
      const outputFile = await this.saveReport(
        fullResponse,
        thinkingContent,
        promptTokens,
        responseTokens,
        saveDir
      );
      
      // Add all output files to the result
      outputFiles.push(...outputFile);
      
      // Add files to the cache
      const toolName = 'character_analyzer';
      outputFiles.forEach(file => {
        fileCache.addFile(toolName, file);
      });
      
      // Return the result
      return {
        success: true,
        outputFiles,
        stats: {
          wordCount,
          tokenCount: responseTokens,
          elapsedTime: `${minutes}m ${seconds.toFixed(2)}s`
        }
      };
    } catch (error) {
      console.error('Error in CharacterAnalyzer:', error);
      this.emitOutput(`\nError: ${error.message}\n`);
      throw error;
    }
  }
  
  /**
   * Create character analysis prompt
   * @param {string} manuscriptContent - Manuscript content
   * @param {string} outlineContent - Outline content (optional)
   * @param {string} worldContent - World content (optional)
   * @returns {string} - Prompt for Claude API
   */
  createCharacterAnalysisPrompt(manuscriptContent, outlineContent = "", worldContent = "") {
    // Determine which files we have
    const hasOutline = Boolean(outlineContent.trim());
    const hasWorld = Boolean(worldContent.trim());
    
    // Construct file sections
    let fileSections = `=== MANUSCRIPT ===\n${manuscriptContent}\n=== END MANUSCRIPT ===\n`;
    
    if (hasOutline) {
      fileSections = `=== OUTLINE ===\n${outlineContent}\n=== END OUTLINE ===\n\n` + fileSections;
    }
    
    if (hasWorld) {
      fileSections = `=== WORLD ===\n${worldContent}\n=== END WORLD ===\n\n` + fileSections;
    }
    
    // Build instruction section
    const instructions = `IMPORTANT: NO Markdown formatting

You are an expert literary analyst specializing in character identification and analysis. Analyze the provided story files to identify all characters that appear in each file.

Your task is to create a comprehensive character analysis with these sections:

1. MASTER CHARACTER LIST:
   - Create a master list of ALL characters found across all provided files
   - For each character, specify in which file(s) they appear: manuscript, outline, and/or world
   - Include character names, aliases, titles, and roles where identifiable
   - Group related characters if appropriate (e.g., family members, teams)

2. CHARACTER PRESENCE ANALYSIS:
   - List characters that appear in the manuscript but NOT in the outline or world files
   - For each such character, provide:
     a) Brief description based on manuscript context
     b) An assessment of whether the character appears to be a deliberate addition or a potential inconsistency

3. CHARACTER CONSISTENCY ANALYSIS:
   - Identify any notable differences in how characters are portrayed across files
   - Note changes in names, titles, roles, or relationships
   - Highlight any potential continuity issues or contradictions

4. RECOMMENDATIONS:
   - Suggest which characters from the manuscript might need to be added to the outline/world files
   - Identify characters that might benefit from consolidation or clarification
   - Highlight any character-related issues that might impact story coherence

Format your analysis as a clear, organized report with sections and subsections. Use plain text formatting only (NO Markdown). Use numbered or bulleted lists where appropriate for clarity.

Be comprehensive in your character identification, capturing not just main characters but also secondary and minor characters that appear in any file.`;

    // Combine all sections
    return fileSections + "\n" + instructions;
  }
  
  /**
   * Ensure file path is absolute
   * @param {string} filePath - File path (may be relative or absolute)
   * @param {string} basePath - Base path to prepend for relative paths
   * @returns {string} - Absolute file path
   */
  ensureAbsolutePath(filePath, basePath) {
    if (!filePath) return filePath;
    
    // Check if the path is already absolute
    if (path.isAbsolute(filePath)) {
      return filePath;
    }
    
    // Make the path absolute by joining with the base path
    return path.join(basePath, filePath);
  }
  
  /**
   * Save report and thinking content to files
   * @param {string} content - Response content
   * @param {string} thinking - Thinking content
   * @param {number} promptTokens - Prompt token count
   * @param {number} responseTokens - Response token count
   * @param {string} saveDir - Directory to save to
   * @param {string} description - Optional description
   * @returns {Promise<string[]>} - Array of paths to saved files
   */
  async saveReport(content, thinking, promptTokens, responseTokens, saveDir, description) {
    try {
      const formatter = new Intl.DateTimeFormat('en-US', {
        weekday: 'long',
        month: 'long',
        day: 'numeric',
        year: 'numeric',
        hour: 'numeric',
        minute: '2-digit',
        hour12: true
      });
      const dateTimeStr = formatter.format(new Date());

      // Create timestamp for filename
      const timestamp = new Date().toISOString().replace(/[-:.]/g, '').substring(0, 15);
      
      // Create descriptive filename
      const baseFilename = `character_analysis_${timestamp}`;
      
      // Array to collect all saved file paths
      const savedFilePaths = [];
      
      // Create stats for thinking file
      const stats = `
Details:  ${dateTimeStr}
Analysis type: Character analysis
Max request timeout: ${this.config.request_timeout} seconds
Max AI model context window: ${this.config.context_window} tokens
AI model thinking budget: ${this.config.thinking_budget_tokens} tokens
Desired output tokens: ${this.config.desired_output_tokens} tokens

Input tokens: ${promptTokens}
Output tokens: ${responseTokens}
`;
      
      // Save full response
      const reportFilename = `${baseFilename}.txt`;
      const reportPath = path.join(saveDir, reportFilename);
      await this.writeOutputFile(content, saveDir, reportFilename);
      savedFilePaths.push(reportPath);
      
      // Save thinking content if available and not skipped
      if (thinking) {
        const thinkingFilename = `${baseFilename}_thinking.txt`;
        const thinkingPath = path.join(saveDir, thinkingFilename);
        const thinkingContent = `=== CHARACTER ANALYSIS ===

=== AI'S THINKING PROCESS ===

${thinking}

=== END AI'S THINKING PROCESS ===
${stats}`;
        
        await this.writeOutputFile(thinkingContent, saveDir, thinkingFilename);
        this.emitOutput(`AI thinking saved to: ${thinkingPath}\n`);
        savedFilePaths.push(thinkingPath);
      }

      this.emitOutput(`Report saved to: ${reportPath}\n`);
      return savedFilePaths;
    } catch (error) {
      console.error(`Error saving report:`, error);
      this.emitOutput(`Error saving report: ${error.message}\n`);
      throw error;
    }
  }
}

module.exports = CharacterAnalyzer;


============================================================
FILE: claude_client.js
SIZE: 16593 bytes
LANGUAGE: JS
============================================================

// claude-api/client.js
const anthropic = require('@anthropic-ai/sdk');

/**
 * Claude API Service
 * Handles interactions with the Claude AI API
 * Uses UI settings with no hardcoded values
 */
class ClaudeAPIService {

  /**
   * Constructor
   * @param {Object} config - API configuration from UI settings
   */
  constructor(config = {}) {
    // Validate required settings
    this.validateConfig(config);
    
    // Store all config values
    this.config = {
      max_retries: config.max_retries,
      request_timeout: config.request_timeout,
      context_window: config.context_window,
      thinking_budget_tokens: config.thinking_budget_tokens,
      betas_max_tokens: config.betas_max_tokens,
      desired_output_tokens: config.desired_output_tokens,
      model_name: config.model_name,
      betas: config.betas,
      max_thinking_budget: config.max_thinking_budget,
      max_tokens: config.max_tokens
    };

    const apiKey = process.env.ANTHROPIC_API_KEY;
    if (!apiKey) {
      console.error('ANTHROPIC_API_KEY environment variable not found');
      // throw new Error(
      //   "Claude API key not found. Please set the ANTHROPIC_API_KEY environment variable."
      // );
      this.apiKeyMissing = true;
      return; // don't create the client but don't crash
    }

    this.client = new anthropic.Anthropic({
      apiKey: apiKey,
      timeout: this.config.request_timeout * 1000, // convert seconds to ms
      maxRetries: this.config.max_retries,
    });
    
    console.log('Claude API Service initialized with:');
    console.log('- Context window:', this.config.context_window);
    console.log('- Model name:', this.config.model_name);
    console.log('- Beta features:', this.config.betas);
    console.log('- Max thinking budget:', this.config.max_thinking_budget);
    console.log('- Max tokens:', this.config.max_tokens);
  }
  
  /**
   * Helper method to convert betas string to array for API calls
   * @returns {string[]} Array of beta features
   */
  _getBetasArray() {
    return this.config.betas.split(',')
      .map(beta => beta.trim())
      .filter(beta => beta.length > 0);
  }

  validateConfig(config) {
    // Check if config exists at all
    if (!config || Object.keys(config).length === 0) {
      throw new Error("No Claude API configuration provided.");
    }

    // List required settings
    const requiredSettings = [
      'max_retries',
      'request_timeout',
      'context_window',
      'thinking_budget_tokens',
      'betas_max_tokens',
      'desired_output_tokens',
      'model_name',
      'betas',
      'max_thinking_budget',
      'max_tokens'
    ];
    
    // Log warnings but don't crash
    const missingSettings = requiredSettings.filter(setting => config[setting] === undefined);
    if (missingSettings.length > 0) {
      console.warn(`Warning: Some Claude API settings missing: ${missingSettings.join(', ')}`);
      console.warn("Please update API settings from the application.");
    }
  }
  
  /**
   * Count tokens in a text string
   * @param {string} text - Text to count tokens in
   * @returns {Promise<number>} - Token count
   */
  async countTokens(text) {
    try {
      const response = await this.client.beta.messages.countTokens({
        model: this.config.model_name,
        messages: [{ role: "user", content: text }],
        thinking: {
          type: "enabled",
          budget_tokens: this.config.thinking_budget_tokens
        },
        betas: this._getBetasArray()
      });
      
      return response.input_tokens;
    } catch (error) {
      console.error('Token counting error:', error);
      throw error;
    }
  }
  
  /**
   * Stream a response with thinking using callbacks
   * @param {string} prompt - Prompt to complete
   * @param {Object} options - API options (only system is allowed to be overridden)
   * @param {Function} onThinking - Callback for thinking content
   * @param {Function} onText - Callback for response text
   * @returns {Promise<void>}
   */
  async streamWithThinking(prompt, options = {}, onThinking, onText) {
    const modelOptions = {
      model: this.config.model_name,
      max_tokens: options.max_tokens,
      messages: [{ role: "user", content: prompt }],
      thinking: {
        type: "enabled",
        budget_tokens: options.thinking.budget_tokens
      },
      betas: this._getBetasArray()
    };

    // Only allow system prompt to be overridden
    if (options.system) {
      modelOptions.system = options.system;
    }
    
    try {
      const stream = await this.client.beta.messages.stream(modelOptions);
      
      for await (const event of stream) {
        if (event.type === "content_block_delta") {
          if (event.delta.type === "thinking_delta") {
            // Call thinking callback with delta
            if (onThinking && typeof onThinking === 'function') {
              onThinking(event.delta.thinking);
            }
          } else if (event.delta.type === "text_delta") {
            // Call text callback with delta
            if (onText && typeof onText === 'function') {
              onText(event.delta.text);
            }
          }
        }
      }
    } catch (error) {
      console.error('API streaming error:', error);
      throw error;
    }
  }
  
  /**
   * Stream a response with thinking and message start stats using callbacks
   * @param {string} prompt - Prompt to complete
   * @param {Object} options - API options (only system is allowed to be overridden)
   * @param {Function} onThinking - Callback for thinking content
   * @param {Function} onText - Callback for response text
   * @returns {Promise<void>}
   */
  async streamWithThinkingAndMessageStart(prompt, options = {}, onThinking, onText, onMessageStart, onResponseHeaders, onStatus) {
    const modelOptions = {
      model: this.config.model_name,
      max_tokens: options.max_tokens,
      messages: [{ role: "user", content: prompt }],
      thinking: {
        type: "enabled",
        budget_tokens: options.thinking.budget_tokens
      },
      betas: this._getBetasArray()
    };

    // Only allow system prompt to be overridden
    if (options.system) {
      modelOptions.system = options.system;
    }
    
    try {
      // const { data: response, response: rawResponse } = await client.beta.messages.create({
      //   model: 'claude-3-7-sonnet-20250219',
      //   max_tokens: 50000,  // greater than thinking.budget_tokens (32000)
      //   system: systemMessages,
      //   messages: [{ role: 'user', content: largeInput }],
      //   thinking: { type: 'enabled', budget_tokens: 32000 },
      //   betas: ['output-128k-2025-02-19']
      // }).withResponse();

      // const stream = await this.client.beta.messages.stream(modelOptions);
      const { data: stream, response: rawResponse } = await this.client.beta.messages
        .stream(modelOptions)
        .withResponse();

      // display all headers from the raw response
      onResponseHeaders(`\n=== CURRENT RATE LIMITS ===`);
      // headers is a Map-like object, get all entries
      const headerEntries = Array.from(rawResponse.headers.entries());
      for (const [name, value] of headerEntries) {
        onResponseHeaders(`${name}: ${value}`);
      }

      // event: message_start
      // data: {"type": "message_start", "message": {"id": "msg_01...", "type": "message", "role": "assistant", "content": [], "model": "claude-3-7-sonnet-20250219", "stop_reason": null, "stop_sequence": null}}
      // ⬇️
      // ⬇️
      //        ******************* = THINKING
      // event: content_block_start
      // data: {"type": "content_block_start", "index": 0, "content_block": {"type": "thinking", "thinking": ""}}
      // ⬇️
      // event: content_block_delta
      // data: {"type": "content_block_delta", "index": 0, "delta": {"type": "thinking_delta", "thinking": "Let me solve this step by step:\n\n1. First break down 27 * 453"}}
      // ⬇️
      // event: content_block_delta
      // data: {"type": "content_block_delta", "index": 0, "delta": {"type": "thinking_delta", "thinking": "\n2. 453 = 400 + 50 + 3"}}
      // ⬇️
      // event: content_block_delta
      // data: {"type": "content_block_delta", "index": 0, "delta": {"type": "thinking_delta", "thinking": "\n3. 27 * 400 = 10,800"}}
      // ⬇️
      // event: content_block_delta
      // data: {"type": "content_block_delta", "index": 0, "delta": {"type": "thinking_delta", "thinking": "\n4. 27 * 50 = 1,350"}}
      // ⬇️
      // event: content_block_delta
      // data: {"type": "content_block_delta", "index": 0, "delta": {"type": "thinking_delta", "thinking": "\n5. 27 * 3 = 81"}}
      // ⬇️
      // event: content_block_delta
      // data: {"type": "content_block_delta", "index": 0, "delta": {"type": "thinking_delta", "thinking": "\n6. 10,800 + 1,350 + 81 = 12,231"}}
      // ⬇️
      // event: content_block_delta
      // data: {"type": "content_block_delta", "index": 0, "delta": {"type": "signature_delta", "signature": "EqQBCgIYAhIM1gbcDa9GJwZA2b3hGgxBdjrkzLoky3dl1pkiMOYds..."}}
      // ⬇️
      // event: content_block_stop
      // data: {"type": "content_block_stop", "index": 0}
      // ⬇️
      // ⬇️
      //        ******************* = TEXT
      // event: content_block_start
      // data: {"type": "content_block_start", "index": 1, "content_block": {"type": "text", "text": ""}}
      // ⬇️
      // event: content_block_delta
      // data: {"type": "content_block_delta", "index": 1, "delta": {"type": "text_delta", "text": "27 * 453 = 12,231"}}
      // ⬇️
      // event: content_block_stop
      // data: {"type": "content_block_stop", "index": 1}
      // ⬇️
      // ⬇️
      // event: message_delta
      // data: {"type": "message_delta", "delta": {"stop_reason": "end_turn", "stop_sequence": null}}
      // ⬇️
      // event: message_stop
      // data: {"type": "message_stop"}

      for await (const event of stream) {
        if (event.type === "message_start") {
          onMessageStart(`\n=== MESSAGE START ===`);
          onMessageStart(`${JSON.stringify(event.message)}`);
        }

        if (event.type === "content_block_start") {
          if (event.content_block.type == "thinking") {
            if (onStatus && typeof onStatus === 'function') {
              onStatus(`\n🧍🏽stand by 🤓 thinking...\n\n`);
            }
          } else if (event.content_block.type == "text") {
            if (onStatus && typeof onStatus === 'function') {
              onStatus(`\n🗣️ now 🤖 responding...\n\n`);
            }
          }
        }

        if (event.type === "content_block_delta") {
          if (event.delta.type === "thinking_delta") {
            // call thinking callback with delta, which is the text of the thinking
            if (onThinking && typeof onThinking === 'function') {
              onThinking(event.delta.thinking);
            }
          } else if (event.delta.type === "text_delta") {
            // call text callback with delta, which is the final output text of the AI's response
            if (onText && typeof onText === 'function') {
              onText(event.delta.text);
            }
          }
        }
      }
    } catch (error) {
      console.error('API streaming error:', error);
      throw error;
    }
  }

  /**
   * Calculate token budgets and validate prompt size
   * @param {number} promptTokens - Number of tokens in the prompt
   * @returns {Object} - Calculated token budgets and limits
   */
  calculateTokenBudgets(promptTokens) {
    // Use configuration settings directly
    const contextWindow = this.config.context_window;
    const desiredOutputTokens = this.config.desired_output_tokens;
    const configuredThinkingBudget = this.config.thinking_budget_tokens;
    const betasMaxTokens = this.config.betas_max_tokens;
    const maxThinkingBudget = this.config.max_thinking_budget;
    let maxTokens = this.config.maxTokens;
    
    // Calculate available tokens after prompt
    const availableTokens = contextWindow - promptTokens;

    // For API call, max_tokens must respect the API limit
    maxTokens = Math.min(availableTokens, betasMaxTokens);
    if (maxTokens > contextWindow) {
      maxTokens = availableTokens
    }
    
    // Thinking budget must be LESS than max_tokens to leave room for visible output
    let thinkingBudget = maxTokens - desiredOutputTokens;
    
    // Cap thinking budget if it's too large - use configurable limit
    const capThinkingBudget = thinkingBudget > maxThinkingBudget;
    if (capThinkingBudget) {
      thinkingBudget = maxThinkingBudget;
    }

    // client.js: execute:
    // API Error: 400 {
    //     "type":"error",
    //     "error":{
    //       "type":"invalid_request_error",
    //       "message":"input length and `max_tokens` exceed 
    //          context limit: 107398 + 128000 > 200000, 
    //          decrease input length or `max_tokens` and try again"
    //     }}

    // ---------------------------------------------------------------
    // May 2025: Claude 3.7 Sonnet with 32K extended thinking & betas
    // _______________________________________________________________
    // OUTPUT  =  contextWindow - promptTokens     =  availableTokens
    //                                ↓ THINKING ↓
    // VISIBLE =  availableTokens  -    32000      =  maxTokens
    // ---------------------------------------------------------------
    
    // Check if prompt is too large for the configured thinking budget
    const isPromptTooLarge = thinkingBudget < configuredThinkingBudget;
    
    // Return all calculated values for use in API calls and logging
    return {
      contextWindow,
      promptTokens,
      availableTokens,
      maxTokens,
      thinkingBudget,
      desiredOutputTokens,
      betasMaxTokens,
      configuredThinkingBudget,
      capThinkingBudget,
      isPromptTooLarge
    };
  }
  
  // /**
  //  * Complete a prompt with thinking
  //  * @param {string} prompt - Prompt to complete
  //  * @param {Object} options - API options (only system is allowed to be overridden)
  //  * @returns {Promise<Object>} - Response with content and thinking
  //  */
  // async completeWithThinking(prompt, options = {}) {
  //   const modelOptions = {
  //     model: this.config.model_name,
  //     max_tokens: this.config.betas_max_tokens,
  //     messages: [{ role: "user", content: prompt }],
  //     thinking: {
  //       type: "enabled",
  //       budget_tokens: this.config.thinking_budget_tokens
  //     },
  //     betas: this._getBetasArray()
  //   };
    
  //   // Only allow system prompt to be overridden
  //   if (options.system) {
  //     modelOptions.system = options.system;
  //   }
    
  //   try {
  //     const response = await this.client.beta.messages.create(modelOptions);
      
  //     // Extract main content and thinking
  //     const content = response.content[0].text;
  //     const thinking = response.thinking || "";
      
  //     return { content, thinking };
  //   } catch (error) {
  //     console.error('API error:', error);
  //     throw error;
  //   }
  // }

  /**
   * Close the Anthropic client and clean up resources
   */
  close() {
    if (this.client) {
      console.log('Closing Anthropic client...');
      // The Anthropic SDK doesn't have an explicit close method,
      // but we can remove our reference to allow garbage collection
      this.client = null;
    }
  }

  /**
   * Recreate the client with the same settings
   * Useful when we need a fresh connection
   */
  recreate() {
    console.log('Recreating Anthropic client...');
    console.log('*** recreate: client before closing:', !!this.client);
    
    // Ensure any existing client is closed first
    this.close();
    console.log('*** recreate: client after closing:', !!this.client);
    
    // Only create a new client if the API key exists
    const apiKey = process.env.ANTHROPIC_API_KEY;
    if (!apiKey) {
      console.error('ANTHROPIC_API_KEY environment variable not found');
      this.apiKeyMissing = true;
      return;
    }

    // Create a new client with the same settings
    this.client = new anthropic.Anthropic({
      apiKey: apiKey,
      timeout: this.config.request_timeout * 1000, // convert seconds to ms
      maxRetries: this.config.max_retries,
    });
    
    console.log('*** recreate: client after recreate:', !!this.client);
    console.log('Anthropic client recreated successfully');
  }

}

module.exports = ClaudeAPIService;


============================================================
FILE: client.js
SIZE: 6929 bytes
LANGUAGE: JS
============================================================

// client.js
const { GoogleGenAI, HarmCategory, HarmBlockThreshold } = require('@google/genai');

/**
 * Gemini AI API Service
 * Handles interactions with the Google's Gemini AI API
 */
class GeminiAiAPIService {
  /**
   * Constructor
   * @param {Object} config - API configuration
   */
  constructor(config = {}) {
    // Store the configuration with defaults
    this.config = {
      model_name: 'gemini-2.5-pro-preview-05-06', 
      ...config
    };

    const apiKeyFromEnv = process.env.GEMINI_API_KEY;
    if (!apiKeyFromEnv) {
      console.error('GEMINI_API_KEY environment variable not found');
      this.apiKeyMissing = true;
      return; 
    }

    this.client = new GoogleGenAI({
      apiKey: apiKeyFromEnv,
      httpOptions: {
        timeout: 900000 // 15 mins in ms
      }
    });
  }

  /**
   * Stream a response with thinking-like functionality
   * @param {string} prompt - Prompt to complete
   * @param {Object} options - API options (currently unused but kept for interface compatibility)
   * @param {Function} onThinking - Callback for thinking content
   * @param {Function} onText - Callback for response text
   * @returns {Promise<void>}
   */
  async streamWithThinking(prompt, options = {}, onThinking, onText) {
    if (!this.client || this.apiKeyMissing) {
      throw new Error('Gemini API client not initialized - API key missing');
    }

    try {
      const thinkingPrompt = `
${prompt}

IMPORTANT INSTRUCTION: First, think through this task step by step.
Begin your internal analysis by writing "THINKING:" followed by your detailed analysis.
After you've completed your analysis, write "RESPONSE:" followed by your final answer.
The THINKING section should be comprehensive, showing all your reasoning steps.
The RESPONSE section should only contain your final answer.
`;

      // Reverted to HarmBlockThreshold.OFF as per your original code and feedback
      const safetySettings = [
        { category: HarmCategory.HARM_CATEGORY_HARASSMENT, threshold: HarmBlockThreshold.OFF },
        { category: HarmCategory.HARM_CATEGORY_HATE_SPEECH, threshold: HarmBlockThreshold.OFF },
        { category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT, threshold: HarmBlockThreshold.OFF },
        { category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT, threshold: HarmBlockThreshold.OFF }
      ];
      
      const streamGenerator = await this.client.models.generateContentStream({
        model: this.config.model_name,
        contents: [{ role: "user", parts: [{ text: thinkingPrompt }] }],
        safetySettings: safetySettings
      });

      let inThinkingMode = false;
      let inResponseMode = false;
      
      for await (const chunk of streamGenerator) {
        let currentText = chunk.candidates?.[0]?.content?.parts?.[0]?.text || '';
        if (!currentText) {
          continue;
        }

        if (inThinkingMode) {
          const responseMarkerIndex = currentText.indexOf("RESPONSE:");
          if (responseMarkerIndex !== -1) {
            const thinkingPart = currentText.substring(0, responseMarkerIndex);
            if (thinkingPart) onThinking(thinkingPart);
            
            const responsePart = currentText.substring(responseMarkerIndex + "RESPONSE:".length);
            if (responsePart) onText(responsePart);
            
            inThinkingMode = false;
            inResponseMode = true;
          } else {
            onThinking(currentText);
          }
        } else if (inResponseMode) {
          onText(currentText);
        } else { 
          const thinkingMarkerIndex = currentText.indexOf("THINKING:");
          const responseMarkerIndex = currentText.indexOf("RESPONSE:");

          if (thinkingMarkerIndex !== -1 && (responseMarkerIndex === -1 || thinkingMarkerIndex < responseMarkerIndex)) {
            const preambleText = currentText.substring(0, thinkingMarkerIndex);
            if (preambleText) onText(preambleText);
            
            let postThinkingMarkerText = currentText.substring(thinkingMarkerIndex + "THINKING:".length);
            inThinkingMode = true;
            
            const nestedResponseMarkerIndex = postThinkingMarkerText.indexOf("RESPONSE:");
            if (nestedResponseMarkerIndex !== -1) {
              const thinkingPart = postThinkingMarkerText.substring(0, nestedResponseMarkerIndex);
              if (thinkingPart) onThinking(thinkingPart);
              
              const responsePart = postThinkingMarkerText.substring(nestedResponseMarkerIndex + "RESPONSE:".length);
              if (responsePart) onText(responsePart);
              
              inThinkingMode = false;
              inResponseMode = true;
            } else {
              if (postThinkingMarkerText) onThinking(postThinkingMarkerText);
            }
          } else if (responseMarkerIndex !== -1) {
            const preambleText = currentText.substring(0, responseMarkerIndex);
            if (preambleText) onText(preambleText);
            
            const responsePart = currentText.substring(responseMarkerIndex + "RESPONSE:".length);
            if (responsePart) onText(responsePart);
            
            inResponseMode = true;
          } else {
            onText(currentText);
          }
        }
      }
    } catch (error) {
      console.error('Error in Gemini streaming with thinking:', error);
      throw error;
    }
  }

  /**
   * Count tokens in a text string
   * @param {string} text - Text to count tokens in
   * @returns {Promise<number>} - Token count
   */
  async countTokens(text) {
    if (!this.client || this.apiKeyMissing) {
      throw new Error('Gemini API client not initialized - API key missing');
    }

    try {
      const result = await this.client.models.countTokens({
        model: this.config.model_name,
        contents: [{ role: "user", parts: [{ text: text }] }] 
      });
      
      return result.totalTokens || 0;
    } catch (error) {
      console.error('Token counting error:', error);
      return Math.ceil(text.length / 4);
    }
  }

  /**
   * Calculate token budgets and validate prompt size
   * @param {number} promptTokens - Number of tokens in the prompt
   * @returns {Object} - Calculated token budgets and limits
   */
  calculateTokenBudgets(promptTokens) {
    const contextWindow = 1000000; 
    const availableTokens = contextWindow - promptTokens;
    const desiredOutputTokens = this.config.desired_output_tokens || 8192; 
    const thinkingBudget = 0; 
    
    const maxOutputTokenLimit = 8192; 
    const maxTokens = Math.min(availableTokens, maxOutputTokenLimit);
    
    return {
      contextWindow,
      promptTokens,
      availableTokens,
      maxTokens,
      thinkingBudget,
      desiredOutputTokens,
      isPromptTooLarge: promptTokens >= contextWindow 
    };
  }

  recreate() {
    // Not needed
  }

  close() {
    // Not needed
  }
}

module.exports = GeminiAPIService;

============================================================
FILE: cls_proofreader-mechanical.js
SIZE: 15509 bytes
LANGUAGE: JS
============================================================

// proofreader-mechanical.js
const BaseTool = require('./base-tool');
const path = require('path');
const fileCache = require('./file-cache');
const appState = require('./state.js');
const fs = require('fs/promises');
const textProcessor = require('./textProcessor');

/**
 * Proofreader Mechanical Tool
 * Analyzes a manuscript for spelling, grammar, typos.
 */
class ProofreaderMechanical extends BaseTool {
  /**
   * Constructor
   * @param {Object} claudeService - Claude API service
   * @param {Object} config - Tool configuration
   */
  constructor(claudeService, config = {}) {
    super('proofreader_mechanical', config);
    this.claudeService = claudeService;
  }

  /**
   * Execute the tool
   * @param {Object} options - Tool options
   * @returns {Promise<Object>} - Execution result
   */
  async execute(options) {
    console.log('Executing Proofreader Mechanical with options:', options);
    
    // Clear the cache for this tool
    const toolName = 'proofreader_mechanical';
    fileCache.clear(toolName);
    
    // Extract options
    let manuscriptFile = options.manuscript_file;
    const language = options.language || 'English';
    const saveDir = options.save_dir || appState.CURRENT_PROJECT_PATH;
    
    if (!saveDir) {
      const errorMsg = 'Error: No save directory specified and no current project selected.\n' +
                      'Please select a project or specify a save directory.';
      this.emitOutput(errorMsg);
      throw new Error('No save directory available');
    }

    // Ensure file paths are absolute
    manuscriptFile = this.ensureAbsolutePath(manuscriptFile, saveDir);

    const outputFiles = [];
    
    try {
      this.emitOutput(`Reading manuscript file: ${manuscriptFile}\n`);
      const manuscriptContent = await this.readInputFile(manuscriptFile);
      const manuscriptWordCount = this.countWords(manuscriptContent);
      const manuscriptTokens = await this.claudeService.countTokens(manuscriptContent);
      const manuscriptWithoutChapterHeaders = textProcessor.processText(manuscriptContent)
      
      // Create prompt using the template with language
      const prompt = this.createPrompt(manuscriptWithoutChapterHeaders, language);
      const promptTokens = await this.claudeService.countTokens(prompt);

      // Call the shared token budget calculator
      const tokenBudgets = this.claudeService.calculateTokenBudgets(promptTokens);

      // Handle logging based on the returned values
      this.emitOutput(`\nToken stats:\n`);
      this.emitOutput(`Manuscript is ${manuscriptWordCount} words and ${manuscriptTokens} tokens.\n`);
      this.emitOutput(`Input prompt tokens: [${tokenBudgets.promptTokens}]\n`);
      this.emitOutput(`\n`);
      this.emitOutput(`Max AI model context window: [${tokenBudgets.contextWindow}] tokens\n`);
      this.emitOutput(`Available tokens: [${tokenBudgets.availableTokens}]  = ${tokenBudgets.contextWindow} - ${tokenBudgets.promptTokens} = context_window - prompt\n`);
      this.emitOutput(`Desired output tokens: [${tokenBudgets.desiredOutputTokens}]\n`);
      this.emitOutput(`AI model thinking budget: [${tokenBudgets.thinkingBudget}] tokens\n`);
      this.emitOutput(`Max output tokens: [${tokenBudgets.maxTokens}] tokens\n`);

      // Check for special conditions
      if (tokenBudgets.capThinkingBudget) {
        this.emitOutput(`Warning: thinking budget is larger than 32K, set to 32K.\n`);
      }

      // Check if the prompt is too large
      if (tokenBudgets.isPromptTooLarge) {
        this.emitOutput(`Error: prompt is too large to have a ${tokenBudgets.configuredThinkingBudget} thinking budget!\n`);
        this.emitOutput(`Run aborted!\n`);
        throw new Error(`Prompt is too large for ${tokenBudgets.configuredThinkingBudget} thinking budget - run aborted`);
      }
      
      // Call Claude API with streaming
      this.emitOutput(`\nSending request to Claude API . . .\n`);
      
      // Add a message about waiting
      this.emitOutput(`\n****************************************************************************\n`);
      this.emitOutput(`*  Proofreading manuscript for ${language} ...\n`);
      this.emitOutput(`*  \n`);
      this.emitOutput(`*  This process typically takes several minutes.\n`);
      this.emitOutput(`*                                                                          \n`);
      this.emitOutput(`*  It's recommended to keep this window the sole 'focus'                   \n`);
      this.emitOutput(`*  and to avoid browsing online or running other apps, as these API        \n`);
      this.emitOutput(`*  network connections are often flakey, like delicate echoes of whispers. \n`);
      this.emitOutput(`*                                                                          \n`);
      this.emitOutput(`*  So breathe, remove eye glasses, stretch, relax, and be like water 🥋 🧘🏽‍♀️\n`);
      this.emitOutput(`*  \n`);
      this.emitOutput(`****************************************************************************\n\n`);
      
      const startTime = Date.now();
      let fullResponse = "";
      let thinkingContent = "";
      
      // Create system prompt - more explicit guidance
      const systemPrompt = "You are a meticulous proofreader. Be thorough and careful. DO NOT use any Markdown formatting - no headers, bullets, numbering, asterisks, hyphens, or any formatting symbols. Plain text only. You must find and report ALL errors, even small ones.";

      // Use the calculated values in the API call
      try {
        await this.claudeService.streamWithThinkingAndMessageStart(
          prompt,
          {
            model: "claude-3-7-sonnet-20250219",
            system: systemPrompt,
            max_tokens: tokenBudgets.maxTokens,
            thinking: {
              type: "enabled",
              budget_tokens: tokenBudgets.thinkingBudget
            },
            betas: ["output-128k-2025-02-19"]
          },
          // callback for thinking content
          (thinkingDelta) => {
            thinkingContent += thinkingDelta;
          },
          // callback for response text
          (textDelta) => {
            fullResponse += textDelta;
          },
          // callback for message start with stats
          (messageStart) => {
            this.emitOutput(`${messageStart}\n`);
          },
          // callback for response headers
          (responseHeaders) => {
            this.emitOutput(`${responseHeaders}\n`);
          },
          // callback for status
          (callStatus) => {
            this.emitOutput(`${callStatus}\n`);
          },
        );
      } catch (error) {
        this.emitOutput(`\nAPI Error: ${error.message}\n`);
        throw error;
      }

      const elapsed = (Date.now() - startTime) / 1000;
      const minutes = Math.floor(elapsed / 60);
      const seconds = elapsed % 60;
      
      this.emitOutput(`\nCompleted in: ⏰ ${minutes}m ${seconds.toFixed(2)}s.\n`);
      
      // Count words in response
      const wordCount = this.countWords(fullResponse);
      this.emitOutput(`Report has approximately ${wordCount} words.\n`);
      
      // Count tokens in response
      const responseTokens = await this.claudeService.countTokens(fullResponse);
      this.emitOutput(`Response token count: ${responseTokens}\n`);

      // Remove any markdown formatting
      fullResponse = this.removeMarkdown(fullResponse);

      // Save the report
      const outputFile = await this.saveReport(
        fullResponse,
        thinkingContent,
        promptTokens,
        responseTokens,
        saveDir,
        language
      );
      
      // Add the output files to the result
      outputFiles.push(...outputFile);
      
      // Add files to the cache
      outputFiles.forEach(file => {
        fileCache.addFile(toolName, file);
      });
      
      // Return the result
      return {
        success: true,
        outputFiles
      };
    } catch (error) {
      console.error('Error in Proofreader Mechanical:', error);
      this.emitOutput(`\nError: ${error.message}\n`);
      throw error;
    }
  }
  
  /**
   * Create prompt
   * @param {string} manuscriptContent - Manuscript content
   * @param {string} language - Language for proofreading (default: English)
   * @returns {string} - Prompt for Claude API
   */
//   createPrompt(manuscriptContent, language = 'English') {
//     // Prompt focused ONLY on mechanical errors, explicitly excluding consistency checks
//     const template = `You are a professional ${language} proofreader reviewing this manuscript:

// === MANUSCRIPT ===
// ${manuscriptContent}
// === END MANUSCRIPT ===

// CORE INSTRUCTION: Conduct a strictly mechanical proofreading of this manuscript. Focus EXCLUSIVELY on spelling, grammar, punctuation, and formatting errors. Do NOT check for consistency issues related to plot, characters, timeline, or story elements.

// WHAT TO CHECK (ONLY):
// - Spelling errors and typos
// - Grammar issues (subject-verb agreement, verb tense, etc.)
// - Punctuation errors (commas, periods, quotation marks, etc.)
// - Basic formatting errors (paragraph breaks, dialogue formatting)

// WHAT TO EXPLICITLY IGNORE:
// - Character name consistency across the manuscript
// - Timeline or chronology consistency
// - Setting or location consistency
// - Plot elements or story consistency
// - Repeated phrases or words across different sections
// - Any content-related issues

// APPROACH:
// Divide manuscript mentally into thirds. 
// Focus ONLY on mechanical errors. 
// Maintain consistent scrutiny throughout.

// IN A SINGLE PASS OF THE MANUSCRIPT BE LIMITED TO MECHANICAL ISSUES ONLY:
// 1. Spelling: Check for misspelled words and typos only
// 2. Grammar: Check for grammatical errors only
// 3. Punctuation: Check for punctuation errors only
// 4. Format: Check paragraph and dialogue formatting only

// ERROR REPORTING:
// For each error:
// - Number sequentially (e.g., "Spelling Error #1")
// - Show original text VERBATIM WITHOUT QUOTES
// - Specify exact mechanical error only
// - Provide correction

// EXAMPLE:
// Spelling Error #1:
// Original text: When John entered the room, he saw three seperate books on the table.
// Issue: The word "seperate" is misspelled
// Correction: When John entered the room, he saw three separate books on the table.

// CRITICAL REQUIREMENTS:
// - Flag ONLY mechanical errors (spelling, grammar, punctuation, formatting)
// - NEVER flag consistency issues across the manuscript
// - NEVER add quotation marks to original text
// - If you find no mechanical errors or very few, that's fine - do not stretch to find issues

// VERIFICATION:
// At the end, confirm you checked ONLY for mechanical errors and ignored all consistency issues as instructed.`;
//     return template;
//   }
createPrompt(manuscriptContent, language = 'English') {
  const template = `Review this manuscript for mechanical errors ONLY. Ignore all other types of issues.

=== MANUSCRIPT ===
${manuscriptContent}
=== END MANUSCRIPT ===

Focus exclusively on identifying spelling errors, grammar problems, punctuation mistakes, and basic formatting issues. Do not concern yourself with any aspects of consistency across the manuscript. This means you should not track or check character details, timeline elements, setting descriptions, or plot logic. Your task is simply to identify technical writing errors at the sentence level.

For each error you find:
1. Show the sentence containing the error verbatim WITHOUT adding quotation marks
2. Identify the specific error
3. Provide a correction

Read through the manuscript naturally without creating any tracking systems. Simply note errors as you encounter them. Give equal attention to the entire manuscript from beginning to end.

At the end, briefly confirm that you focused only on mechanical errors.`;
  return template;
}

  /**
   * Count words in text
   * @param {string} text - Text to count words in
   * @returns {number} - Word count
   */
  countWords(text) {
    return text.split(/\s+/).filter(word => word.length > 0).length;
  }
  
  /**
   * Ensure file path is absolute
   * @param {string} filePath - File path (may be relative or absolute)
   * @param {string} basePath - Base path to prepend for relative paths
   * @returns {string} - Absolute file path
   */
  ensureAbsolutePath(filePath, basePath) {
    if (!filePath) return filePath;
    
    // Check if the path is already absolute
    if (path.isAbsolute(filePath)) {
      return filePath;
    }
    
    // Make the path absolute by joining with the base path
    return path.join(basePath, filePath);
  }
  
  /**
   * Save report and thinking content to files
   * @param {string} content - Response content
   * @param {string} thinking - Thinking content
   * @param {number} promptTokens - Prompt token count
   * @param {number} responseTokens - Response token count
   * @param {string} saveDir - Directory to save to
   * @param {string} language - Language used for proofreading
   * @returns {Promise<string[]>} - Array of paths to saved files
   */
  async saveReport(
    content,
    thinking,
    promptTokens,
    responseTokens,
    saveDir,
    language = 'English'
  ) {
    try {
      const formatter = new Intl.DateTimeFormat('en-US', {
        weekday: 'long',
        month: 'long',
        day: 'numeric',
        year: 'numeric',
        hour: 'numeric',
        minute: '2-digit',
        hour12: true
      });
      const dateTimeStr = formatter.format(new Date());

      // Create timestamp for filename
      const timestamp = new Date().toISOString().replace(/[-:.]/g, '').substring(0, 15);
      
      // Create descriptive filename
      const baseFilename = `proofreader_mechanical_${language.toLowerCase()}_${timestamp}`;
      
      // Array to collect all saved file paths
      const savedFilePaths = [];
      
      // Create stats for thinking file
      const stats = `
Details:  ${dateTimeStr}
Language: ${language}
Max request timeout: ${this.config.request_timeout} seconds
Max AI model context window: ${this.config.context_window} tokens
AI model thinking budget: ${this.config.thinking_budget_tokens} tokens
Desired output tokens: ${this.config.desired_output_tokens} tokens

Input tokens: ${promptTokens}
Output tokens: ${responseTokens}
`;
      
      // Save full response
      const reportFilename = `${baseFilename}.txt`;
      const reportPath = path.join(saveDir, reportFilename);
      await this.writeOutputFile(content, saveDir, reportFilename);
      savedFilePaths.push(reportPath);
      this.emitOutput(`Report saved to: ${reportPath}\n`);

      // Save thinking content if available
      if (thinking) {
        const thinkingFilename = `${baseFilename}_thinking.txt`;
        const thinkingContent = `=== PROOFREADERMECHANICAL THINKING ===

${thinking}

=== END PROOFREADERMECHANICAL THINKING ===
${stats}`;
        
        const thinkingReportPath = path.join(saveDir, thinkingFilename);
        await this.writeOutputFile(thinkingContent, saveDir, thinkingFilename);
        savedFilePaths.push(thinkingReportPath);
        this.emitOutput(`AI thinking saved to: ${path.join(saveDir, thinkingFilename)}\n`);
      }
      
      return savedFilePaths;
    } catch (error) {
      console.error(`Error saving report:`, error);
      this.emitOutput(`Error saving report: ${error.message}\n`);
      throw error;
    }
  }
}

module.exports = ProofreaderMechanical;


============================================================
FILE: cls_tokens-words-counter.js
SIZE: 5518 bytes
LANGUAGE: JS
============================================================

// tokens-words-counter.js
const BaseTool = require('./base-tool');
const path = require('path');
const fileCache = require('./file-cache');
const appState = require('./state.js');

/**
 * FOR TESTING ONLY:
 * Creates a delay that won't completely freeze the UI
 * @param {number} seconds - Total seconds to delay
 * @param {function} progressCallback - Function to call with progress updates
 */
function gentleDelay(seconds, progressCallback) {
  return new Promise(resolve => {
    let secondsElapsed = 0;
    
    // Use setInterval for regular UI updates
    const interval = setInterval(() => {
      secondsElapsed++;
      
      if (progressCallback) {
        progressCallback(`Delay: ${secondsElapsed} seconds elapsed\n`);
      }
      
      if (secondsElapsed >= seconds) {
        clearInterval(interval);
        resolve();
      }
    }, 1000); // Update every second
  });
}

class TokensWordsCounter extends BaseTool {
  constructor(claudeService, config = {}) {
    super('tokens_words_counter', config);
    this.claudeService = claudeService;
  }
  
  /**
   * Count words in text
   * @param {string} text - Text to count words in
   * @returns {number} - Word count
   */
  countWords(text) {
    return text.split(/\s+/).filter(word => word.length > 0).length;
  }
  
  /**
   * Execute the tool
   * @param {Object} options - Tool options
   * @returns {Promise<Object>} - Execution result
   */
  async execute(options) {
    // Clear the cache for this tool
    const toolName = 'tokens_words_counter';
    fileCache.clear(toolName);
    
    // Extract options
    let inputFile = options.input_file;
    const outputFiles = [];

    // Get the project directory path
    const saveDir = options.save_dir || appState.CURRENT_PROJECT_PATH;
    if (!saveDir) {
      const errorMsg = 'Error: No save directory specified and no current project selected.\n' +
                      'Please select a project or specify a save directory.';
      this.emitOutput(errorMsg);
      throw new Error('No save directory available');
    }
  
    // Fix relative paths by resolving them against the project directory
    // Only prepend the path if inputFile doesn't already have an absolute path
    if (inputFile && !path.isAbsolute(inputFile) && !inputFile.startsWith('~/')) {
      // This makes relative paths like "manuscript.txt" resolve to the current project folder
      inputFile = path.join(saveDir, inputFile);
      this.emitOutput(`Using file: ${inputFile}\n`);
    }

    try {
      // Read the input file
      this.emitOutput(`Reading file: ${inputFile}\n`);

      const text = await this.readInputFile(inputFile);
      
      // Count words
      this.emitOutput('Counting words...\n');
      const wordCount = this.countWords(text);
      this.emitOutput(`Word count: ${wordCount}\n`);
      
      // Count tokens using Claude API
      this.emitOutput('Counting tokens using Claude API (this may take a few seconds)...\n');
      
      const promptTokens = await this.claudeService.countTokens(text);
      this.emitOutput(`Token count: ${promptTokens}\n`);
      
      // Use the shared token budgets calculator from the Claude service
      // This ensures consistent calculation across all tools
      const tokenBudgets = this.claudeService.calculateTokenBudgets(promptTokens);
      
      // Calculate words per token
      const wordsPerToken = promptTokens > 0 ? wordCount / promptTokens : 0;
      
      // Prepare report content
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      const inputBase = path.basename(inputFile);
      const inputName = path.parse(inputBase).name;
      
      const reportContent = `Token and Word Count Report
=========================

Analysis of file: ${inputFile}
Generated on: ${new Date().toLocaleString()}

Context window: ${tokenBudgets.contextWindow} tokens
Available tokens: ${tokenBudgets.availableTokens} tokens
Thinking budget: ${tokenBudgets.thinkingBudget} tokens
Desired output tokens: ${tokenBudgets.desiredOutputTokens} tokens

Note:
- This analysis shows how many tokens your text requires
- For Claude API, the token count affects both cost and context usage
- The words-to-token ratio helps estimate token usage for future texts

Word count: ${wordCount}
Token count: ${promptTokens}
Words per token ratio: ${wordsPerToken.toFixed(2)}

`;

      // Output the report to the console
      this.emitOutput('\n' + reportContent + '\n');
      
      // Save the report to a file
      const outputFileName = `count_${inputName}_${timestamp}.txt`;
      this.emitOutput(`Saving report to: ${path.join(saveDir, outputFileName)}\n`);
      
      const outputFile = await this.writeOutputFile(
        reportContent, 
        saveDir, 
        outputFileName
      );
      
      // Add to local tracking array
      outputFiles.push(outputFile);
      
      // Add to the shared file cache
      fileCache.addFile(toolName, outputFile);
      
      this.emitOutput('Analysis complete!\n');
      
      // Return the result
      return {
        success: true,
        outputFiles,
        stats: {
          wordCount,
          tokenCount: promptTokens,
          wordsPerToken: wordsPerToken.toFixed(2),
          availableTokens: tokenBudgets.availableTokens
        }
      };
    } catch (error) {
      console.error('Error in TokensWordsCounter:', error);
      this.emitOutput(`\nError: ${error.message}\n`);
      throw error;
    }
  }
}

module.exports = TokensWordsCounter;


============================================================
FILE: code-consolidator-cli.js
SIZE: 8018 bytes
LANGUAGE: JS
============================================================

#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
const inquirer = require('inquirer');
const glob = require('glob');
const chalk = require('chalk');
const cliProgress = require('cli-progress');

console.log(chalk.blue.bold('\n📦 CODE CONSOLIDATOR 📦'));
console.log(chalk.blue('Prepare your codebase for AI analysis\n'));

// Main function
async function main() {
  try {
    // Get user input through a series of questions
    const answers = await inquirer.prompt([
      {
        type: 'input',
        name: 'rootDir',
        message: 'What directory contains your codebase?',
        default: '.',
        validate: (input) => {
          return fs.existsSync(input) ? true : 'Directory does not exist!';
        }
      },
      {
        type: 'input',
        name: 'fileTypes',
        message: 'What file extensions do you want to include? (comma separated)',
        default: 'js,jsx,ts,tsx,html,css,json',
        validate: (input) => {
          return input.length > 0 ? true : 'Please specify at least one file extension';
        }
      },
      {
        type: 'input',
        name: 'excludeDirs',
        message: 'Directories to exclude? (comma separated)',
        default: 'node_modules,.git,dist,build,out',
        validate: (input) => {
          return input.length > 0 ? true : 'Please specify at least one directory to exclude';
        }
      },
      {
        type: 'input',
        name: 'excludeFiles',
        message: 'Specific files to exclude? (comma separated)',
        default: 'package-lock.json',
      },
      {
        type: 'input',
        name: 'outputFile',
        message: 'Output filename:',
        default: 'codebase_for_ai.txt'
      },
      {
        type: 'list',
        name: 'delimiter',
        message: 'Choose a file delimiter style:',
        choices: [
          { name: 'Standard (===== FILE: path =====)', value: 'standard' },
          { name: 'Markdown (## FILE: path)', value: 'markdown' },
          { name: 'Detailed (File info + Language + Size)', value: 'detailed' }
        ]
      },
      {
        type: 'confirm',
        name: 'includeTOC',
        message: 'Include a table of contents at the beginning?',
        default: true
      }
    ]);

    // Process the answers
    const fileExtensions = answers.fileTypes.split(',').map(ext => ext.trim().replace(/^\./, ''));
    const excludeDirs = answers.excludeDirs.split(',').map(dir => dir.trim());
    
    // Process excluded files
    const excludeFiles = answers.excludeFiles.split(',')
      .map(file => file.trim())
      .filter(file => file.length > 0);
    
    // Create ignore patterns for directories
    const ignorePatterns = excludeDirs.map(dir => `**/${dir}/**`);
    
    console.log(chalk.yellow('\nSearching for files...'));
    
    // Find all matching files - fix the pattern issue by using multiple glob calls
    let files = [];
    
    // Process each extension separately
    for (const ext of fileExtensions) {
      const pattern = `**/*.${ext}`;
      
      const extFiles = await new Promise((resolve, reject) => {
        glob(pattern, {
          cwd: answers.rootDir,
          ignore: ignorePatterns,
          nodir: true
        }, (err, matchedFiles) => {
          if (err) reject(err);
          else resolve(matchedFiles);
        });
      });
      
      files = [...files, ...extFiles];
    }
    
    // Remove any duplicates that might have occurred
    files = [...new Set(files)];
    
    // Filter out specific excluded files
    if (excludeFiles.length > 0) {
      const originalCount = files.length;
      
      files = files.filter(file => {
        const fileName = path.basename(file);
        return !excludeFiles.includes(fileName);
      });
      
      const excludedCount = originalCount - files.length;
      if (excludedCount > 0) {
        console.log(chalk.yellow(`Excluded ${excludedCount} specific file(s) by name.`));
      }
    }
    
    if (files.length === 0) {
      console.log(chalk.red('No matching files found!'));
      return;
    }
    
    console.log(chalk.green(`Found ${files.length} files to process.`));
    
    // Create the output file
    const outputPath = path.resolve(answers.outputFile);
    
    // Initialize progress bar
    const progressBar = new cliProgress.SingleBar({
      format: 'Processing files |' + chalk.cyan('{bar}') + '| {percentage}% | {value}/{total} files',
      barCompleteChar: '\u2588',
      barIncompleteChar: '\u2591',
    }, cliProgress.Presets.shades_classic);
    
    // Begin processing
    progressBar.start(files.length, 0);
    
    // Create a table of contents if requested
    let tableOfContents = '';
    if (answers.includeTOC) {
      tableOfContents = '# TABLE OF CONTENTS\n\n';
      files.forEach((file, index) => {
        tableOfContents += `${index + 1}. ${file}\n`;
      });
      tableOfContents += '\n\n';
    }
    
    // Write the table of contents
    fs.writeFileSync(outputPath, tableOfContents);
    
    // Process each file
    let totalBytes = 0;
    let fileStats = [];
    
    for (let i = 0; i < files.length; i++) {
      const file = files[i];
      const filePath = path.join(answers.rootDir, file);
      
      try {
        // Read the file
        const content = fs.readFileSync(filePath, 'utf8');
        const stats = fs.statSync(filePath);
        const fileSize = stats.size;
        totalBytes += fileSize;
        
        // Store stats for summary
        fileStats.push({
          path: file,
          size: fileSize,
          extension: path.extname(file).replace('.', '')
        });
        
        // Create the delimiter based on user choice
        let delimiter;
        switch (answers.delimiter) {
          case 'markdown':
            delimiter = `\n\n## FILE: ${file}\n\n`;
            break;
          case 'detailed':
            delimiter = `\n\n${'='.repeat(60)}\n`;
            delimiter += `FILE: ${file}\n`;
            delimiter += `SIZE: ${fileSize} bytes\n`;
            delimiter += `LANGUAGE: ${path.extname(file).replace('.', '').toUpperCase()}\n`;
            delimiter += `${'='.repeat(60)}\n\n`;
            break;
          default: // standard
            delimiter = `\n\n${'='.repeat(20)} FILE: ${file} ${'='.repeat(20)}\n\n`;
        }
        
        // Append to the output file
        fs.appendFileSync(outputPath, delimiter + content);
        
        // Update progress
        progressBar.update(i + 1);
      } catch (error) {
        console.error(`\nError processing ${file}: ${error.message}`);
      }
    }
    
    progressBar.stop();
    
    // Generate summary
    console.log(chalk.green(`\n✅ Successfully created ${answers.outputFile}`));
    console.log(chalk.yellow(`Total size: ${formatBytes(totalBytes)}`));
    
    // Group files by extension for summary
    const extensionStats = {};
    fileStats.forEach(file => {
      if (!extensionStats[file.extension]) {
        extensionStats[file.extension] = { count: 0, size: 0 };
      }
      extensionStats[file.extension].count++;
      extensionStats[file.extension].size += file.size;
    });
    
    console.log(chalk.yellow('\nFile Types Summary:'));
    Object.keys(extensionStats).forEach(ext => {
      const stats = extensionStats[ext];
      console.log(`  ${chalk.cyan(ext.toUpperCase())}: ${stats.count} files (${formatBytes(stats.size)})`);
    });
    
    console.log(chalk.blue(`\nYour codebase is now ready for AI analysis! 🚀`));
    
  } catch (error) {
    console.error(chalk.red(`\nAn error occurred: ${error.message}`));
  }
}

// Helper function to format bytes
function formatBytes(bytes, decimals = 2) {
  if (bytes === 0) return '0 Bytes';
  
  const k = 1024;
  const dm = decimals < 0 ? 0 : decimals;
  const sizes = ['Bytes', 'KB', 'MB', 'GB'];
  
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  
  return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
}

// Run the main function
main();


============================================================
FILE: conflict-analyzer.js
SIZE: 18533 bytes
LANGUAGE: JS
============================================================

// conflict-analyzer.js
const BaseTool = require('./base-tool');
const path = require('path');
const fileCache = require('./file-cache');
const appState = require('./state.js');
const fs = require('fs/promises');

/**
 * ConflictAnalyzer Tool
 * Analyzes manuscript for conflict patterns at different structural levels 
 * using the Claude API. Identifies conflict nature, escalation, and resolution
 * at scene, chapter, and arc levels.
 */
class ConflictAnalyzer extends BaseTool {
  /**
   * Constructor
   * @param {Object} GeminiAPIService - Claude API service
   * @param {Object} config - Tool configuration
   */
  constructor(GeminiAPIService, config = {}) {
    super('conflict_analyzer', config);
    this.GeminiAPIService = GeminiAPIService;
  }

  /**
   * Execute the tool
   * @param {Object} options - Tool options
   * @returns {Promise<Object>} - Execution result
   */
  async execute(options) {
    console.log('Executing ConflictAnalyzer with options:', options);
    
    // Extract options
    let manuscriptFile = options.manuscript_file;
    const analysisLevel = options.analysis_level;
    let outlineFile = options.outline_file;
    const conflictTypes = options.conflict_types;
    const saveDir = options.save_dir || appState.CURRENT_PROJECT_PATH;
    
    if (!saveDir) {
      const errorMsg = 'Error: No save directory specified and no current project selected.\n' +
                      'Please select a project or specify a save directory.';
      this.emitOutput(errorMsg);
      throw new Error('No save directory available');
    }

    // Ensure file paths are absolute
    manuscriptFile = this.ensureAbsolutePath(manuscriptFile, saveDir);
    
    if (outlineFile) {
      outlineFile = this.ensureAbsolutePath(outlineFile, saveDir);
    }
    
    // Log the full paths for debugging
    console.log('Using full paths:');
    console.log(`Manuscript: ${manuscriptFile}`);
    if (outlineFile) {
      console.log(`Outline: ${outlineFile}`);
    }

    const outputFiles = [];
    
    try {
      // Read the input files
      this.emitOutput(`Reading files...\n`);

      // Read the manuscript file
      this.emitOutput(`Reading manuscript file: ${manuscriptFile}\n`);
      const manuscriptContent = await this.readInputFile(manuscriptFile);
      
      // Read the outline file if provided
      let outlineContent = '';
      if (outlineFile) {
        this.emitOutput(`Reading outline file: ${outlineFile}\n`);
        outlineContent = await this.readInputFile(outlineFile);
      }
      
      // Handle "all" analysis level
      const analysisLevels = analysisLevel === "all" 
        ? ["scene", "chapter", "arc"] 
        : [analysisLevel];
      
      // Run each analysis level
      for (const level of analysisLevels) {
        this.emitOutput(`\nRunning ${level.toUpperCase()} conflict analysis...\n`);
        
        // Create the prompt for this level
        const prompt = this.createPrompt(level, outlineContent, manuscriptContent, conflictTypes);

        // Count tokens in the prompt
        this.emitOutput(`Counting tokens in prompt...\n`);
        const promptTokens = await this.GeminiAPIService.countTokens(prompt);

        // Call the shared token budget calculator
        const tokenBudgets = this.GeminiAPIService.calculateTokenBudgets(promptTokens);

        // Handle logging based on the returned values
        this.emitOutput(`\nToken stats:\n`);
        this.emitOutput(`Max AI model context window: [${tokenBudgets.contextWindow}] tokens\n`);
        this.emitOutput(`Input prompt tokens: [${tokenBudgets.promptTokens}] ...\n`);
        this.emitOutput(`                     = outline.txt + manuscript.txt\n`);
        this.emitOutput(`                       + prompt instructions\n`);
        this.emitOutput(`Available tokens: [${tokenBudgets.availableTokens}]  = ${tokenBudgets.contextWindow} - ${tokenBudgets.promptTokens} = context_window - prompt\n`);
        this.emitOutput(`Desired output tokens: [${tokenBudgets.desiredOutputTokens}]\n`);
        this.emitOutput(`AI model thinking budget: [${tokenBudgets.thinkingBudget}] tokens\n`);
        this.emitOutput(`Max output tokens: [${tokenBudgets.maxTokens}] tokens\n`);

        // Check for special conditions
        if (tokenBudgets.capThinkingBudget) {
          this.emitOutput(`Warning: thinking budget is larger than 32K, set to 32K.\n`);
        }

        // Check if the prompt is too large
        if (tokenBudgets.isPromptTooLarge) {
          this.emitOutput(`Error: prompt is too large to have a ${tokenBudgets.configuredThinkingBudget} thinking budget!\n`);
          this.emitOutput(`Run aborted!\n`);
          throw new Error(`Prompt is too large for ${tokenBudgets.configuredThinkingBudget} thinking budget - run aborted`);
        }
        
        // Call Claude API with streaming
        this.emitOutput(`Sending request to Claude API (streaming)...\n`);
        
        // Add a message about waiting
        this.emitOutput(`****************************************************************************\n`);
        this.emitOutput(`*  Analyzing ${level}-level conflicts in your manuscript...                  \n`);
        this.emitOutput(`*  This process typically takes several minutes.                           \n`);
        this.emitOutput(`*                                                                          \n`);
        this.emitOutput(`*  It's recommended to keep this window the sole 'focus'                   \n`);
        this.emitOutput(`*  and to avoid browsing online or running other apps, as these API        \n`);
        this.emitOutput(`*  network connections are often flakey, like delicate echoes of whispers. \n`);
        this.emitOutput(`*                                                                          \n`);
        this.emitOutput(`*  So breathe, remove eye glasses, stretch, relax, and be like water 🥋 🧘🏽‍♀️\n`);
        this.emitOutput(`****************************************************************************\n\n`);
        
        const startTime = Date.now();
        let fullResponse = "";
        let thinkingContent = "";
        
        // Create system prompt to avoid markdown
        const systemPrompt = "CRITICAL INSTRUCTION: NO Markdown formatting of ANY kind. Never use headers, bullets, or any formatting symbols. Plain text only with standard punctuation.";

        // Use the calculated values in the API call
        try {
          await this.GeminiAPIService.streamWithThinking(
            prompt,
            {
              system: systemPrompt,
              max_tokens: tokenBudgets.maxTokens,
              thinking: {
                type: "enabled",
                budget_tokens: tokenBudgets.thinkingBudget
              }
            },
            // Callback for thinking content
            (thinkingDelta) => {
              thinkingContent += thinkingDelta;
            },
            // Callback for response text
            (textDelta) => {
              fullResponse += textDelta;
            }
          );
        } catch (error) {
          this.emitOutput(`\nAPI Error: ${error.message}\n`);
          throw error;
        }

        const elapsed = (Date.now() - startTime) / 1000;
        const minutes = Math.floor(elapsed / 60);
        const seconds = elapsed % 60;
        
        this.emitOutput(`\nCompleted in ${minutes}m ${seconds.toFixed(2)}s.\n`);
        
        // Count words in response
        const wordCount = this.countWords(fullResponse);
        this.emitOutput(`Report has approximately ${wordCount} words.\n`);
        
        // Count tokens in response
        const responseTokens = await this.GeminiAPIService.countTokens(fullResponse);
        this.emitOutput(`Response token count: ${responseTokens}\n`);

        // Remove any markdown formatting
        fullResponse = this.removeMarkdown(fullResponse);

        // Save the report
        const outputFile = await this.saveReport(
          level,
          fullResponse,
          thinkingContent,
          promptTokens,
          responseTokens,
          saveDir
        );
        
        // Add the output files to the result
        outputFiles.push(...outputFile);
      }
      
      // Add files to the cache
      const toolName = 'conflict_analyzer';
      outputFiles.forEach(file => {
        fileCache.addFile(toolName, file);
      });
      
      // Return the result
      return {
        success: true,
        outputFiles,
        stats: {
          analysisLevels: analysisLevels
        }
      };
    } catch (error) {
      console.error('Error in ConflictAnalyzer:', error);
      this.emitOutput(`\nError: ${error.message}\n`);
      throw error;
    }
  }
  
  /**
   * Create prompt based on analysis level
   * @param {string} analysisLevel - Level of conflict analysis
   * @param {string} outlineContent - Outline content
   * @param {string} manuscriptContent - Manuscript content
   * @param {Array|string} conflictTypes - Types of conflicts to analyze
   * @returns {string} - Prompt for Claude API
   */
  createPrompt(analysisLevel, outlineContent, manuscriptContent, conflictTypes) {
    const noMarkdown = "IMPORTANT: - NO Markdown formatting";
    
    // Convert conflictTypes to comma-separated string if it's an array
    const conflictTypesList = Array.isArray(conflictTypes) ? conflictTypes.join(", ") : conflictTypes;
    
    const prompts = {
      "scene": `=== OUTLINE ===
${outlineContent}
=== END OUTLINE ===

=== MANUSCRIPT ===
${manuscriptContent}
=== END MANUSCRIPT ===

${noMarkdown}

You are an expert fiction editor specializing in conflict analysis. Analyze the manuscript to identify and evaluate conflicts at the SCENE level. Focus on these conflict types: ${conflictTypesList}.

For each scene in the manuscript:

1. CONFLICT IDENTIFICATION:
   - Identify the primary conflict driving the scene
   - Classify the conflict type (internal, interpersonal, environmental, societal, cosmic)
   - Identify any secondary or parallel conflicts

2. CONFLICT DYNAMICS:
   - Identify the specific opposing forces (character vs character, character vs self, etc.)
   - Analyze how the conflict is introduced
   - Track the escalation pattern within the scene
   - Identify the climax or turning point of the scene-level conflict
   - Analyze the resolution or non-resolution of the scene conflict

3. CONFLICT EFFECTIVENESS:
   - Evaluate how well the conflict creates tension and drives the scene
   - Identify if the conflict advances character development
   - Assess if the conflict contributes to the larger story arcs
   - Note if any scenes lack meaningful conflict

Organize your analysis by scene, using clear scene boundaries and key identifying text. For each scene, provide:
- Scene location in the manuscript (beginning and ending text)
- Main conflict identification and classification
- Analysis of conflict dynamics and progression
- Assessment of conflict effectiveness
- Specific recommendations for strengthening scene conflicts where needed

Use specific text examples from the manuscript to support your analysis.
`,

      "chapter": `=== OUTLINE ===
${outlineContent}
=== END OUTLINE ===

=== MANUSCRIPT ===
${manuscriptContent}
=== END MANUSCRIPT ===

${noMarkdown}

You are an expert fiction editor specializing in conflict analysis. Analyze the manuscript to identify and evaluate conflicts at the CHAPTER level. Focus on these conflict types: ${conflictTypesList}.

For each chapter or major section in the manuscript:

1. CONFLICT PROGRESSION:
   - Identify the primary chapter-level conflict
   - Analyze how the conflict evolves across scenes within the chapter
   - Track rising and falling tension patterns
   - Identify how the chapter-level conflict connects to the overall story arcs

2. CONFLICT STRUCTURE:
   - Analyze the chapter's conflict structure (introduction, complications, climax)
   - Identify how scene-level conflicts contribute to the chapter's main conflict
   - Note any parallel conflict threads running through the chapter
   - Evaluate the chapter's conflict resolution or cliff-hanger

3. CONFLICT EFFECTIVENESS:
   - Assess if the chapter conflict is substantial enough to sustain reader interest
   - Evaluate if the conflict pacing is effective
   - Identify if the conflict advances the overall plot and character development
   - Note if the chapter conflict integrates well with preceding and following chapters

Organize your analysis by chapter/section, providing:
- Chapter identification (heading or beginning text)
- Main conflict analysis and classification
- Conflict progression through the chapter
- Assessment of conflict structure and effectiveness
- Specific recommendations for improving chapter-level conflict where needed

Use specific text examples from the manuscript to support your analysis.
`,

      "arc": `=== OUTLINE ===
${outlineContent}
=== END OUTLINE ===

=== MANUSCRIPT ===
${manuscriptContent}
=== END MANUSCRIPT ===

${noMarkdown}

You are an expert fiction editor specializing in conflict analysis. Analyze the manuscript to identify and evaluate conflicts at the ARC level. Focus on these conflict types: ${conflictTypesList}.

Analyze the major conflict arcs that span multiple chapters or the entire manuscript:

1. CORE CONFLICT IDENTIFICATION:
   - Identify the primary conflict driving the overall narrative
   - Identify major secondary conflict arcs
   - Classify each conflict arc by type
   - Map the key characters or forces involved in each arc

2. ARC PROGRESSION:
   - For each major conflict arc, trace its development across the manuscript
   - Identify key escalation points and their manuscript locations
   - Track how the conflicts evolve, intensify, and interconnect
   - Map the climactic moments for each conflict arc
   - Analyze resolution patterns for each arc

3. CONFLICT ARCHITECTURE:
   - Analyze how the various conflict arcs interrelate
   - Identify how smaller conflicts feed into larger arcs
   - Evaluate the balance of different conflict types
   - Assess the structural integrity of the conflict arcs

4. NARRATIVE IMPACT:
   - Evaluate how effectively the conflict arcs drive the overall story
   - Assess if the conflict progression creates appropriate tension curves
   - Identify if the conflicts support the thematic elements
   - Evaluate if the resolutions are satisfying and consistent with setup

Provide a comprehensive analysis of the manuscript's conflict architecture:
- Map of major conflict arcs with their progression points
- Analysis of how conflicts interconnect and build upon each other
- Assessment of pacing and escalation effectiveness
- Specific recommendations for strengthening the conflict architecture

Use specific text examples from the manuscript to support your analysis.
`
    };
    
    return prompts[analysisLevel] || "";
  }

  /**
   * Count words in text
   * @param {string} text - Text to count words in
   * @returns {number} - Word count
   */
  countWords(text) {
    return text.split(/\s+/).filter(word => word.length > 0).length;
  }
  
  /**
   * Ensure file path is absolute
   * @param {string} filePath - File path (may be relative or absolute)
   * @param {string} basePath - Base path to prepend for relative paths
   * @returns {string} - Absolute file path
   */
  ensureAbsolutePath(filePath, basePath) {
    if (!filePath) return filePath;
    
    // Check if the path is already absolute
    if (path.isAbsolute(filePath)) {
      return filePath;
    }
    
    // Make the path absolute by joining with the base path
    return path.join(basePath, filePath);
  }
  
  /**
   * Save report and thinking content to files
   * @param {string} analysisLevel - Level of conflict analysis
   * @param {string} content - Response content
   * @param {string} thinking - Thinking content
   * @param {number} promptTokens - Prompt token count
   * @param {number} responseTokens - Response token count
   * @param {string} saveDir - Directory to save to
   * @returns {Promise<string[]>} - Array of paths to saved files
   */
  async saveReport(
    analysisLevel,
    content,
    thinking,
    promptTokens,
    responseTokens,
    saveDir
  ) {
    try {
      const formatter = new Intl.DateTimeFormat('en-US', {
        weekday: 'long',
        month: 'long',
        day: 'numeric',
        year: 'numeric',
        hour: 'numeric',
        minute: '2-digit',
        hour12: true
      });
      const dateTimeStr = formatter.format(new Date());

      // Create timestamp for filename
      const timestamp = new Date().toISOString().replace(/[-:.]/g, '').substring(0, 15);
      
      // Create descriptive filename
      const baseFilename = `conflict_analysis_${analysisLevel}_${timestamp}`;
      
      // Array to collect all saved file paths
      const savedFilePaths = [];
      
      // Create stats for thinking file
      const stats = `
Details:  ${dateTimeStr}
Analysis level: ${analysisLevel} conflict analysis
Max request timeout: ${this.config.request_timeout} seconds
Max AI model context window: ${this.config.context_window} tokens
AI model thinking budget: ${this.config.thinking_budget_tokens} tokens
Desired output tokens: ${this.config.desired_output_tokens} tokens

Input tokens: ${promptTokens}
Output tokens: ${responseTokens}
`;
      
      // Save full response
      const reportFilename = `${baseFilename}.txt`;
      const reportPath = path.join(saveDir, reportFilename);
      await this.writeOutputFile(content, saveDir, reportFilename);
      savedFilePaths.push(reportPath);
      
      // Save thinking content if available and not skipped
      if (thinking) {
        const thinkingFilename = `${baseFilename}_thinking.txt`;
        const thinkingPath = path.join(saveDir, thinkingFilename);
        const thinkingContent = `=== CONFLICT ANALYSIS LEVEL ===
${analysisLevel}

=== AI'S THINKING PROCESS ===

${thinking}

=== END AI'S THINKING PROCESS ===
${stats}`;
        
        await this.writeOutputFile(thinkingContent, saveDir, thinkingFilename);
        this.emitOutput(`AI thinking saved to: ${thinkingPath}\n`);
        savedFilePaths.push(thinkingPath);
      }

      this.emitOutput(`Report saved to: ${reportPath}\n`);
      return savedFilePaths;
    } catch (error) {
      console.error(`Error saving report:`, error);
      this.emitOutput(`Error saving report: ${error.message}\n`);
      throw error;
    }
  }
}

module.exports = ConflictAnalyzer;


============================================================
FILE: copy-editing.js
SIZE: 14811 bytes
LANGUAGE: JS
============================================================

// copy-editing.js
const BaseTool = require('./base-tool');
const path = require('path');
const fileCache = require('./file-cache');
const appState = require('./state.js');
const fs = require('fs/promises');
const textProcessor = require('./textProcessor');

/**
 * CopyEditing Tool
  * COPYEDITING: TECHNICAL CORRECTNESS
  * What actually happens:
  * - Correct grammar, syntax, and punctuation errors
  * - Ensure consistent spelling of unique names and terms
  * - Verify proper formatting of thoughts, dialogue, text messages
  * - Create and maintain a style sheet documenting decisions
  * - Fix inconsistent verb tenses or problematic tense shifts
  * - Correct misused words (affect/effect, lay/lie, etc.)
  * - Standardize formatting (em dashes, ellipses, quotation marks)
  * - Check for consistent handling of numbers (spelled out vs. numerals)
  * - Track characters' physical attributes for consistency
  * - Note timeline inconsistencies (seasons, ages, time lapses)
  * - Flag factual errors in real-world references
  * Specific examples:
  * "Character's eye color changes from blue (ch. 3) to brown (ch. 7)."
  * "Timeline error: protagonist mentions being 29, but earlier stated her 30th birthday was last month."
  * "Inconsistent spelling: 'magic-user' (hyphenated) on p.45 but 'magic user' (two words) elsewhere."
  * "Dialogue formatting inconsistent: single quotes in chapter 2, double quotes elsewhere." 
 */
class CopyEditing extends BaseTool {
  /**
   * Constructor
   * @param {Object} GeminiAPIService - Claude API service
   * @param {Object} config - Tool configuration
   */
  constructor(GeminiAPIService, config = {}) {
    super('copy_editing', config);
    this.GeminiAPIService = GeminiAPIService;
  }

  /**
   * Execute the tool
   * @param {Object} options - Tool options
   * @returns {Promise<Object>} - Execution result
   */
  async execute(options) {
    console.log('Executing CopyEditing with options:', options);
    
    // Clear the cache for this tool
    const toolName = 'copy_editing';
    fileCache.clear(toolName);
    
    // Extract options
    let manuscriptFile = options.manuscript_file;
    const language = options.language || 'English';
    const saveDir = options.save_dir || appState.CURRENT_PROJECT_PATH;
    
    if (!saveDir) {
      const errorMsg = 'Error: No save directory specified and no current project selected.\n' +
                      'Please select a project or specify a save directory.';
      this.emitOutput(errorMsg);
      throw new Error('No save directory available');
    }

    // Ensure file paths are absolute
    manuscriptFile = this.ensureAbsolutePath(manuscriptFile, saveDir);

    const outputFiles = [];
    
    try {
      // Read the input files
      this.emitOutput(`Reading manuscript file: ${manuscriptFile}\n`);
      const manuscriptContent = await this.readInputFile(manuscriptFile);
      // console.log(">>> Original manuscript lines:", manuscriptContent.split('\n').length);

      const manuscriptWithoutChapterHeaders = textProcessor.processText(manuscriptContent)
      // console.log(">>> Processed manuscript lines:", manuscriptWithoutChapterHeaders.split('\n').length);
      
      // Create prompt using the template with language substitution
      const prompt = this.createPrompt(manuscriptWithoutChapterHeaders, language);

      // Count tokens in the prompt
      this.emitOutput(`Counting tokens in prompt...\n`);
      const promptTokens = await this.GeminiAPIService.countTokens(prompt);

      // Call the shared token budget calculator
      const tokenBudgets = this.GeminiAPIService.calculateTokenBudgets(promptTokens);

      // Handle logging based on the returned values
      this.emitOutput(`\nToken stats:\n`);
      this.emitOutput(`Max AI model context window: [${tokenBudgets.contextWindow}] tokens\n`);
      this.emitOutput(`Input prompt tokens: [${tokenBudgets.promptTokens}] ...\n`);
      this.emitOutput(`Available tokens: [${tokenBudgets.availableTokens}]  = ${tokenBudgets.contextWindow} - ${tokenBudgets.promptTokens} = context_window - prompt\n`);
      this.emitOutput(`Desired output tokens: [${tokenBudgets.desiredOutputTokens}]\n`);
      this.emitOutput(`AI model thinking budget: [${tokenBudgets.thinkingBudget}] tokens\n`);
      this.emitOutput(`Max output tokens: [${tokenBudgets.maxTokens}] tokens\n`);

      // Check for special conditions
      if (tokenBudgets.capThinkingBudget) {
        this.emitOutput(`Warning: thinking budget is larger than 32K, set to 32K.\n`);
      }

      // Check if the prompt is too large
      if (tokenBudgets.isPromptTooLarge) {
        this.emitOutput(`Error: prompt is too large to have a ${tokenBudgets.configuredThinkingBudget} thinking budget!\n`);
        this.emitOutput(`Run aborted!\n`);
        throw new Error(`Prompt is too large for ${tokenBudgets.configuredThinkingBudget} thinking budget - run aborted`);
      }
      
      // Call Claude API with streaming
      this.emitOutput(`Sending request to Claude API (streaming)...\n`);
      
      // Add a message about waiting
      this.emitOutput(`****************************************************************************\n`);
      this.emitOutput(`*  Copy Editing manuscript for ${language} creative fiction...              \n`);
      this.emitOutput(`*  This process typically takes several minutes.                           \n`);
      this.emitOutput(`*                                                                          \n`);
      this.emitOutput(`*  Your creative choices and writing style will be preserved.             \n`);
      this.emitOutput(`****************************************************************************\n\n`);
      
      const startTime = Date.now();
      let fullResponse = "";
      let thinkingContent = "";
      
      // Create system prompt - more explicit guidance
      const systemPrompt = "You are a meticulous copy editor. Be thorough and careful. DO NOT use any Markdown formatting - no headers, bullets, numbering, asterisks, hyphens, or any formatting symbols. Plain text only. You must find and report ALL errors and issues, even small ones.";

      // Use the calculated values in the API call
      try {
        await this.GeminiAPIService.streamWithThinking(
          prompt,
          {
            system: systemPrompt,
            max_tokens: tokenBudgets.maxTokens,
            thinking: {
              type: "enabled",
              budget_tokens: tokenBudgets.thinkingBudget
            }
          },
          // Callback for thinking content
          (thinkingDelta) => {
            thinkingContent += thinkingDelta;
          },
          // Callback for response text
          (textDelta) => {
            fullResponse += textDelta;
          }
        );
      } catch (error) {
        this.emitOutput(`\nAPI Error: ${error.message}\n`);
        throw error;
      }

      const elapsed = (Date.now() - startTime) / 1000;
      const minutes = Math.floor(elapsed / 60);
      const seconds = elapsed % 60;
      
      this.emitOutput(`\nCompleted in ${minutes}m ${seconds.toFixed(2)}s.\n`);
      
      // Count words in response
      const wordCount = this.countWords(fullResponse);
      this.emitOutput(`Report has approximately ${wordCount} words.\n`);
      
      // Count tokens in response
      const responseTokens = await this.GeminiAPIService.countTokens(fullResponse);
      this.emitOutput(`Response token count: ${responseTokens}\n`);

      // Remove any markdown formatting
      fullResponse = this.removeMarkdown(fullResponse);

      // Save the report
      const outputFile = await this.saveReport(
        fullResponse,
        thinkingContent,
        promptTokens,
        responseTokens,
        saveDir,
        language
      );
      
      // Add the output files to the result
      outputFiles.push(...outputFile);
      
      // Add files to the cache
      outputFiles.forEach(file => {
        fileCache.addFile(toolName, file);
      });
      
      // Return the result
      return {
        success: true,
        outputFiles
      };
    } catch (error) {
      console.error('Error in CopyEditing:', error);
      this.emitOutput(`\nError: ${error.message}\n`);
      throw error;
    }
  }
  
  /**
   * Create prompt
   * @param {string} manuscriptContent - Manuscript content
   * @param {string} language - Language for copy editing (default: English)
   * @returns {string} - Prompt for Claude API
   */
  createPrompt(manuscriptContent, language = 'English') {
    // Simplified and focused prompt template
    const template = `You are acting as a professional ${language} copy editor reviewing a complete manuscript provided as plain text in its entirety, without chapter divisions, numbers, or titles. The manuscript is presented as one continuous document.

=== MANUSCRIPT ===
${manuscriptContent}
=== END MANUSCRIPT ===

First, read through the entire manuscript once to understand the overall style, voice, and content. As you read, create a comprehensive style sheet that documents:
- Spelling preferences
- Hyphenation choices
- Capitalization rules
- Character names and descriptions
- Timeline details
- Dialogue formatting conventions
- Recurring terminology and phrases
- Ensure consistent spelling of unique names and terms
- Verify proper formatting of thoughts, dialogue, text messages
- Create and maintain a style sheet documenting decisions
- Note inconsistent verb tenses or problematic tense shifts
- Note misused words (affect/effect, lay/lie, etc.)
- Standardize formatting (em dashes, ellipses, quotation marks)
- Check for consistent handling of numbers (spelled out vs. numerals)
- Track and note characters' physical attributes for consistency
- Note timeline inconsistencies (seasons, ages, time lapses)
- Flag factual errors in real-world references

Second, perform a detailed edit pass addressing:
- Grammar, punctuation, and spelling errors
- Sentence structure and flow improvements
- Word choice refinement and redundancy elimination
- Voice and tense consistency
- Paragraph transitions
- Dialogue tags and punctuation
- Scene transitions and narrative flow points

Third, compile a query list for the author regarding:
- Unclear passages needing clarification
- Potential factual errors
- VERY IMPORTANT: Plot, character, timeline, or object inconsistencies

Guidelines:
- Preserve the author's voice while noting improvements for clarity
- Note patterns of issues for author awareness

Deliverables:

For each error and/or issue found:
- Show the text verbatim without extra quotes
- Specify the error and/or issue type
- Provide a possible correction

Work methodically through the manuscript, considering each change's impact on the whole.

VERY IMPORTANT:
- Do NOT hurry to finish!
- Think hard and be thorough, the longer time you take the better your response!
- Always re-read the entire manuscript (see: === MANUSCRIPT === above) many times, which will help you to not miss any issues.
- The copy editing of an author's writing (manuscript) is very important to you, as your efforts are critical to the success and legacy of an art form that influences and outlives us all.
    `;

    return template;
  }

  /**
   * Count words in text
   * @param {string} text - Text to count words in
   * @returns {number} - Word count
   */
  countWords(text) {
    return text.split(/\s+/).filter(word => word.length > 0).length;
  }
  
  /**
   * Ensure file path is absolute
   * @param {string} filePath - File path (may be relative or absolute)
   * @param {string} basePath - Base path to prepend for relative paths
   * @returns {string} - Absolute file path
   */
  ensureAbsolutePath(filePath, basePath) {
    if (!filePath) return filePath;
    
    // Check if the path is already absolute
    if (path.isAbsolute(filePath)) {
      return filePath;
    }
    
    // Make the path absolute by joining with the base path
    return path.join(basePath, filePath);
  }
  
  /**
   * Save report and thinking content to files
   * @param {string} content - Response content
   * @param {string} thinking - Thinking content
   * @param {number} promptTokens - Prompt token count
   * @param {number} responseTokens - Response token count
   * @param {string} saveDir - Directory to save to
   * @param {string} language - Language used for copy editing
   * @returns {Promise<string[]>} - Array of paths to saved files
   */
  async saveReport(
    content,
    thinking,
    promptTokens,
    responseTokens,
    saveDir,
    language = 'English'
  ) {
    try {
      const formatter = new Intl.DateTimeFormat('en-US', {
        weekday: 'long',
        month: 'long',
        day: 'numeric',
        year: 'numeric',
        hour: 'numeric',
        minute: '2-digit',
        hour12: true
      });
      const dateTimeStr = formatter.format(new Date());

      // Create timestamp for filename
      const timestamp = new Date().toISOString().replace(/[-:.]/g, '').substring(0, 15);
      
      // Create descriptive filename
      const baseFilename = `copy_editing_${language.toLowerCase()}_${timestamp}`;
      
      // Array to collect all saved file paths
      const savedFilePaths = [];
      
      // Create stats for thinking file
      const stats = `
Details:  ${dateTimeStr}
Language: ${language}
Max request timeout: ${this.config.request_timeout} seconds
Max AI model context window: ${this.config.context_window} tokens
AI model thinking budget: ${this.config.thinking_budget_tokens} tokens
Desired output tokens: ${this.config.desired_output_tokens} tokens

Input tokens: ${promptTokens}
Output tokens: ${responseTokens}
`;
      
      // Save full response
      const reportFilename = `${baseFilename}.txt`;
      const reportPath = path.join(saveDir, reportFilename);
      await this.writeOutputFile(content, saveDir, reportFilename);
      savedFilePaths.push(reportPath);
      this.emitOutput(`Report saved to: ${reportPath}\n`);

      // Save thinking content if available
      if (thinking) {
        const thinkingFilename = `${baseFilename}_thinking.txt`;
        const thinkingContent = `=== COPYEDITING THINKING ===

${thinking}

=== END COPYEDITING THINKING ===
${stats}`;
        
        const thinkingReportPath = path.join(saveDir, thinkingFilename);
        await this.writeOutputFile(thinkingContent, saveDir, thinkingFilename);
        savedFilePaths.push(thinkingReportPath);
        this.emitOutput(`AI thinking saved to: ${path.join(saveDir, thinkingFilename)}\n`);
      }
      
      return savedFilePaths;
    } catch (error) {
      console.error(`Error saving report:`, error);
      this.emitOutput(`Error saving report: ${error.message}\n`);
      throw error;
    }
  }
}

module.exports = CopyEditing;


============================================================
FILE: crowding-leaping-evaluator.js
SIZE: 20656 bytes
LANGUAGE: JS
============================================================

// crowding-leaping-evaluator.js
const BaseTool = require('./base-tool');
const path = require('path');
const fileCache = require('./file-cache');
const appState = require('./state.js');
const fs = require('fs/promises');

/**
 * CrowdingLeapingEvaluator Tool
 * Analyzes manuscript for pacing issues based on Ursula K. Le Guin's concepts of
 * "crowding" (intense detail) and "leaping" (jumping over time or events).
 * Identifies dense paragraphs, abrupt transitions, and visualizes pacing patterns.
 */
class CrowdingLeapingEvaluator extends BaseTool {
  /**
   * Constructor
   * @param {Object} GeminiAPIService - Claude API service
   * @param {Object} config - Tool configuration
   */
  constructor(GeminiAPIService, config = {}) {
    super('crowding_leaping_evaluator', config);
    this.GeminiAPIService = GeminiAPIService;
  }

  /**
   * Execute the tool
   * @param {Object} options - Tool options
   * @returns {Promise<Object>} - Execution result
   */
  async execute(options) {
    console.log('Executing Crowding Leaping Evaluator with options:', options);
    
    // Extract options
    let manuscriptFile = options.manuscript_file;
    const analysisLevel = options.analysis_level;
    const focusAreas = options.focus_areas;
    const sensitivity = options.sensitivity;
    const includeVisualization = options.include_visualization;
    const saveDir = options.save_dir || appState.CURRENT_PROJECT_PATH;
    
    if (!saveDir) {
      const errorMsg = 'Error: No save directory specified and no current project selected.\n' +
                      'Please select a project or specify a save directory.';
      this.emitOutput(errorMsg);
      throw new Error('No save directory available');
    }

    // Ensure file paths are absolute
    manuscriptFile = this.ensureAbsolutePath(manuscriptFile, saveDir);
    
    // Log the full paths for debugging
    console.log('Using full paths:');
    console.log(`Manuscript: ${manuscriptFile}`);

    const outputFiles = [];
    
    try {
      // Read the input files
      this.emitOutput(`Reading files...\n`);

      // Read the manuscript file
      this.emitOutput(`Reading manuscript file: ${manuscriptFile}\n`);
      const manuscriptContent = await this.readInputFile(manuscriptFile);
      
      // Create the prompt
      const prompt = this.createCrowdingLeapingPrompt(
        manuscriptContent, 
        analysisLevel, 
        focusAreas, 
        sensitivity,
        includeVisualization
      );

      // Count tokens in the prompt
      this.emitOutput(`Counting tokens in prompt...\n`);
      const promptTokens = await this.GeminiAPIService.countTokens(prompt);

      // Call the shared token budget calculator
      const tokenBudgets = this.GeminiAPIService.calculateTokenBudgets(promptTokens);

      // Handle logging based on the returned values
      this.emitOutput(`\nToken stats:\n`);
      this.emitOutput(`Max AI model context window: [${tokenBudgets.contextWindow}] tokens\n`);
      this.emitOutput(`Input prompt tokens: [${tokenBudgets.promptTokens}] ...\n`);
      this.emitOutput(`                     = manuscript + prompt instructions\n`);
      this.emitOutput(`Available tokens: [${tokenBudgets.availableTokens}]  = ${tokenBudgets.contextWindow} - ${tokenBudgets.promptTokens} = context_window - prompt\n`);
      this.emitOutput(`Desired output tokens: [${tokenBudgets.desiredOutputTokens}]\n`);
      this.emitOutput(`AI model thinking budget: [${tokenBudgets.thinkingBudget}] tokens\n`);
      this.emitOutput(`Max output tokens: [${tokenBudgets.maxTokens}] tokens\n`);

      // Check for special conditions
      if (tokenBudgets.capThinkingBudget) {
        this.emitOutput(`Warning: thinking budget is larger than 32K, set to 32K.\n`);
      }

      // Check if the prompt is too large
      if (tokenBudgets.isPromptTooLarge) {
        this.emitOutput(`Error: prompt is too large to have a ${tokenBudgets.configuredThinkingBudget} thinking budget!\n`);
        this.emitOutput(`Run aborted!\n`);
        throw new Error(`Prompt is too large for ${tokenBudgets.configuredThinkingBudget} thinking budget - run aborted`);
      }
      
      // Call Claude API with streaming
      this.emitOutput(`>>> Sending request to Claude API (streaming)...\n`);

      // Add a message about waiting
      this.emitOutput(`****************************************************************************\n`);
      this.emitOutput(`*  Analyzing crowding and leaping patterns in your manuscript...            \n`);
      this.emitOutput(`*  This process typically takes several minutes.                           \n`);
      this.emitOutput(`*                                                                          \n`);
      this.emitOutput(`*  It's recommended to keep this window the sole 'focus'                   \n`);
      this.emitOutput(`*  and to avoid browsing online or running other apps, as these API        \n`);
      this.emitOutput(`*  network connections are often flakey, like delicate echoes of whispers. \n`);
      this.emitOutput(`*                                                                          \n`);
      this.emitOutput(`*  So breathe, remove eye glasses, stretch, relax, and be like water 🥋 🧘🏽‍♀️\n`);
      this.emitOutput(`****************************************************************************\n\n`);
      
      const startTime = Date.now();
      let fullResponse = "";
      let thinkingContent = "";
      
      // Create system prompt to avoid markdown
      const systemPrompt = "CRITICAL INSTRUCTION: NO Markdown formatting of ANY kind. Never use headers, bullets, or any formatting symbols. Plain text only with standard punctuation.";

      // Use the calculated values in the API call - following pattern from rhythm-analyzer.js
      try {
        await this.GeminiAPIService.streamWithThinking(
          prompt,
          {
            system: systemPrompt,
            max_tokens: tokenBudgets.maxTokens,
            thinking: {
              type: "enabled",
              budget_tokens: tokenBudgets.thinkingBudget
            }
          },
          // Callback for thinking content
          (thinkingDelta) => {
            thinkingContent += thinkingDelta;
          },
          // Callback for response text
          (textDelta) => {
            fullResponse += textDelta;
          }
        );
      } catch (error) {
        this.emitOutput(`\nAPI Error: ${error.message}\n`);
        throw error;
      }

      const elapsed = (Date.now() - startTime) / 1000;
      const minutes = Math.floor(elapsed / 60);
      const seconds = elapsed % 60;
      
      this.emitOutput(`\nCompleted in ${minutes}m ${seconds.toFixed(2)}s.\n`);
      
      // Count words in response
      const wordCount = this.countWords(fullResponse);
      this.emitOutput(`Report has approximately ${wordCount} words.\n`);
      
      // Count tokens in response
      const responseTokens = await this.GeminiAPIService.countTokens(fullResponse);
      this.emitOutput(`Response token count: ${responseTokens}\n`);

      // Remove any markdown formatting
      fullResponse = this.removeMarkdown(fullResponse);

      // Save the report
      const outputFile = await this.saveReport(
        analysisLevel,
        focusAreas,
        sensitivity,
        includeVisualization,
        fullResponse,
        thinkingContent,
        promptTokens,
        responseTokens,
        saveDir
      );
      
      // Add all output files to the result
      outputFiles.push(...outputFile);
      
      // Add files to the cache
      const toolName = 'crowding_leaping_evaluator';
      outputFiles.forEach(file => {
        fileCache.addFile(toolName, file);
      });
      
      // Return the result
      return {
        success: true,
        outputFiles,
        stats: {
          wordCount,
          tokenCount: responseTokens,
          elapsedTime: `${minutes}m ${seconds.toFixed(2)}s`,
          analysisLevel,
          focusAreas,
          sensitivity,
          includeVisualization
        }
      };
    } catch (error) {
      console.error('Error in CrowdingLeapingEvaluator:', error);
      this.emitOutput(`\nError: ${error.message}\n`);
      throw error;
    }
  }
  
  /**
   * Create crowding leaping analysis prompt
   * @param {string} manuscriptContent - Manuscript content
   * @param {string} analysisLevel - Analysis level (basic, standard, detailed)
   * @param {Array|string} focusAreas - Areas to focus on
   * @param {string} sensitivity - Sensitivity level (low, medium, high)
   * @param {boolean} includeVisualization - Whether to include visualization
   * @returns {string} - Prompt for Claude API
   */
  createCrowdingLeapingPrompt(manuscriptContent, analysisLevel = "standard", focusAreas = ["crowding", "leaping", "transitions", "pacing"], sensitivity = "medium", includeVisualization = false) {
    // Build instruction section based on analysis level
    const basicInstructions = `
1. PACING OVERVIEW:
   - Identify the overall pacing structure of the manuscript
   - Highlight patterns of crowding (dense detail) and leaping (time/event jumps)
   - Explain how these patterns affect readability and narrative flow

2. CROWDING ANALYSIS:
   - Identify paragraphs with intense detail or many events happening quickly
   - Flag sections where the narrative feels dense or overwhelming
   - Note effective use of crowding for emphasis or dramatic effect
   - Provide examples with suggestions for potential adjustment

3. LEAPING ANALYSIS:
   - Identify sections where significant time or events are skipped
   - Point out abrupt transitions that may confuse readers
   - Highlight effective uses of leaping to maintain narrative momentum
   - Suggest improvements for leaps that lack necessary context or bridges
`;

    const standardInstructions = basicInstructions + `
4. TRANSITION ANALYSIS:
   - Evaluate the effectiveness of scene and chapter transitions
   - Identify transitions that are too abrupt or too drawn out
   - Analyze how transitions contribute to or detract from pacing
   - Suggest ways to improve problematic transitions

5. BALANCE ASSESSMENT:
   - Assess the balance between crowded and leaping sections
   - Identify narrative patterns that may create reading fatigue
   - Evaluate how well the pacing serves the content and genre expectations
   - Suggest adjustments to create more effective pacing rhythms
`;

    const detailedInstructions = standardInstructions + `
6. SCENE DENSITY MAPPING:
   - Provide a structural map of the manuscript's pacing patterns
   - Analyze how scene density shifts throughout the manuscript
   - Identify potential pacing problems at the macro-structural level
   - Suggest strategic adjustments to improve overall narrative rhythm

7. WHITE SPACE ANALYSIS:
   - Examine how effectively "white space" is used between scenes and events
   - Analyze the presence and absence of reflective or transitional passages
   - Identify opportunities for adding or removing breathing room
   - Suggest techniques for modulating narrative density

8. GENRE-SPECIFIC CONSIDERATIONS:
   - Evaluate pacing against genre expectations and conventions
   - Analyze how crowding and leaping affect genre-specific elements
   - Identify pacing strategies that would enhance genre effectiveness
   - Suggest tailored approaches for improving genre alignment
`;

    // Choose the appropriate instruction level
    let instructionSet;
    if (analysisLevel === "basic") {
      instructionSet = basicInstructions;
    } else if (analysisLevel === "detailed") {
      instructionSet = detailedInstructions;
    } else {  // standard
      instructionSet = standardInstructions;
    }

    // Add visualization instructions if requested
    const visualizationInstructions = `
9. PACING VISUALIZATION:
   - Create a text-based visualization that represents the pacing patterns
   - Use symbols to indicate dense/crowded sections (e.g., "###") and leaps/transitions (e.g., "->")
   - Map the pacing flow throughout the manuscript to identify rhythm patterns
   - Include a legend explaining the visualization symbols
`;

    if (includeVisualization) {
      instructionSet += visualizationInstructions;
    }

    // Construct the focus areas emphasis
    let focusAreasText;
    if (Array.isArray(focusAreas)) {
      focusAreasText = focusAreas.join(", ");
    } else {
      // Handle the case where focusAreas might be a string
      focusAreasText = String(focusAreas);
    }

    // Adjust instructions based on sensitivity level
    const sensitivityInstructions = {
      "low": "Focus only on the most significant pacing issues that affect readability and engagement.",
      "medium": "Identify moderate to major pacing issues, balancing technical assessment with artistic considerations.",
      "high": "Perform a detailed analysis of all potential pacing patterns, noting even subtle variations in narrative density."
    };
    
    const sensitivityText = sensitivityInstructions[sensitivity] || sensitivityInstructions["medium"];

    // Construct the full prompt
    const instructions = `IMPORTANT: NO Markdown formatting

You are an expert literary editor specializing in narrative pacing and structure. Your task is to analyze the provided manuscript for crowding and leaping patterns, focusing particularly on: ${focusAreasText}.

Follow Ursula K. Le Guin's concepts from "Steering the Craft" on controlling scene density through "crowding" (adding intense detail) and "leaping" (jumping over time or events). According to Le Guin, mastering these techniques allows writers to control the reader's experience through the density and sparseness of the narrative.

Sensitivity level: ${sensitivity}. ${sensitivityText}

Pay special attention to:
1. CROWDED SECTIONS
   - Paragraphs with intense sensory detail or many quick events
   - Sections where multiple significant actions occur in rapid succession
   - Dense descriptive passages that may overwhelm the reader
   Example: "She grabbed her keys, slammed the door, ran down three flights of stairs, hailed a cab, jumped in, gave the address, texted her boss, checked her makeup, and rehearsed her presentation all before the first stoplight."

2. LEAPING SECTIONS
   - Abrupt jumps in time, location, or perspective without sufficient transition
   - Places where significant events happen "off-screen" between scenes
   - Transitions that may leave readers disoriented or confused
   Example: "John left the party early. Three years later, he returned to find everything had changed."

3. TRANSITION EFFECTIVENESS
   - How smoothly the narrative moves between scenes, settings, and time periods
   - Whether transitions provide enough context for readers to follow leaps
   - If scene changes use appropriate pacing techniques for the content
   Example (effective): "As winter gave way to spring, so too did her grief begin to thaw." 
   Example (ineffective): "They argued bitterly. The wedding was beautiful."

4. PACING PATTERNS
   - Repetitive structures that may create monotony
   - Consistent density that doesn't vary with narrative importance
   - Opportunities to use crowding and leaping more strategically
   Example (problem): Five consecutive scenes that all use the same dense detail level regardless of importance
   Suggestion: Vary detail level to emphasize key moments and quicken pace for transitions

For each pacing issue you identify, provide:
- The relevant passage with the crowding or leaping pattern
- An analysis of its effect on reader experience and narrative flow
- A suggested revision approach that maintains the author's voice and intent

Create a comprehensive pacing analysis with these sections:
${instructionSet}

Format your analysis as a clear, organized report with sections and subsections. Use plain text formatting only (NO Markdown). Use numbered or bulleted lists where appropriate for clarity.

Be specific in your examples and suggestions, showing how crowding and leaping can be adjusted without changing the author's voice or intention. Focus on practical changes that will make the writing more engaging and effective.
`;

    // Combine all sections
    return `=== MANUSCRIPT ===\n${manuscriptContent}\n=== END MANUSCRIPT ===\n\n${instructions}`;
  }

  /**
   * Count words in text
   * @param {string} text - Text to count words in
   * @returns {number} - Word count
   */
  countWords(text) {
    return text.split(/\s+/).filter(word => word.length > 0).length;
  }
  
  /**
   * Ensure file path is absolute
   * @param {string} filePath - File path (may be relative or absolute)
   * @param {string} basePath - Base path to prepend for relative paths
   * @returns {string} - Absolute file path
   */
  ensureAbsolutePath(filePath, basePath) {
    if (!filePath) return filePath;
    
    // Check if the path is already absolute
    if (path.isAbsolute(filePath)) {
      return filePath;
    }
    
    // Make the path absolute by joining with the base path
    return path.join(basePath, filePath);
  }
  
  /**
   * Save report and thinking content to files
   * @param {string} analysisLevel - Analysis level (basic, standard, detailed)
   * @param {Array|string} focusAreas - Areas analyzed
   * @param {string} sensitivity - Sensitivity level (low, medium, high)
   * @param {boolean} includeVisualization - Whether visualization was included
   * @param {string} content - Response content
   * @param {string} thinking - Thinking content
   * @param {number} promptTokens - Prompt token count
   * @param {number} responseTokens - Response token count
   * @param {string} saveDir - Directory to save to
   * @returns {Promise<string[]>} - Array of paths to saved files
   */
  async saveReport(
    analysisLevel,
    focusAreas,
    sensitivity,
    includeVisualization,
    content,
    thinking,
    promptTokens,
    responseTokens,
    saveDir
  ) {
    try {
      const formatter = new Intl.DateTimeFormat('en-US', {
        weekday: 'long',
        month: 'long',
        day: 'numeric',
        year: 'numeric',
        hour: 'numeric',
        minute: '2-digit',
        hour12: true
      });
      const dateTimeStr = formatter.format(new Date());

      // Create timestamp for filename
      const timestamp = new Date().toISOString().replace(/[-:.]/g, '').substring(0, 15);
      
      // Create descriptive filename
      const level = analysisLevel !== 'standard' ? `_${analysisLevel}` : '';
      const viz = includeVisualization ? '_with_viz' : '';
      const baseFilename = `crowding_leaping_analysis${level}${viz}_${timestamp}`;
      
      // Array to collect all saved file paths
      const savedFilePaths = [];
      
      // Format focusAreas for stats
      const focusAreasStr = Array.isArray(focusAreas) ? focusAreas.join(', ') : focusAreas;
      
      // Create stats for thinking file
      const stats = `
Details:  ${dateTimeStr}
Analysis type: Crowding and leaping pacing analysis
Analysis level: ${analysisLevel}
Focus areas: ${focusAreasStr}
Sensitivity level: ${sensitivity}
Include visualization: ${includeVisualization}
Max request timeout: ${this.config.request_timeout} seconds
Max AI model context window: ${this.config.context_window} tokens
AI model thinking budget: ${this.config.thinking_budget_tokens} tokens
Desired output tokens: ${this.config.desired_output_tokens} tokens

Input tokens: ${promptTokens}
Output tokens: ${responseTokens}
`;
      
      // Save full response
      const reportFilename = `${baseFilename}.txt`;
      const reportPath = path.join(saveDir, reportFilename);
      await this.writeOutputFile(content, saveDir, reportFilename);
      savedFilePaths.push(reportPath);
      
      // Save thinking content if available and not skipped
      if (thinking) {
        const thinkingFilename = `${baseFilename}_thinking.txt`;
        const thinkingPath = path.join(saveDir, thinkingFilename);
        const thinkingContent = `=== CROWDING AND LEAPING ANALYSIS ===

=== AI'S THINKING PROCESS ===

${thinking}

=== END AI'S THINKING PROCESS ===
${stats}`;
        
        await this.writeOutputFile(thinkingContent, saveDir, thinkingFilename);
        this.emitOutput(`AI thinking saved to: ${thinkingPath}\n`);
        savedFilePaths.push(thinkingPath);
      }

      this.emitOutput(`Report saved to: ${reportPath}\n`);
      return savedFilePaths;
    } catch (error) {
      console.error(`Error saving report:`, error);
      this.emitOutput(`Error saving report: ${error.message}\n`);
      throw error;
    }
  }
}

module.exports = CrowdingLeapingEvaluator;


============================================================
FILE: dangling-modifier-checker.js
SIZE: 19921 bytes
LANGUAGE: JS
============================================================

// dangling-modifier-checker.js
const BaseTool = require('./base-tool');
const path = require('path');
const util = require('util');
const fileCache = require('./file-cache');
const appState = require('./state.js');
const fs = require('fs/promises');

/**
 * DanglingModifierChecker Tool
 * Analyzes manuscript for dangling and misplaced modifiers using the Claude API.
 * Identifies phrases that don't logically connect to the subject they're meant to modify,
 * which can create unintended humor or confusion, following Ursula K. Le Guin's 
 * writing guidance on clarity and precision.
 */
class DanglingModifierChecker extends BaseTool {
  /**
   * Constructor
   * @param {Object} GeminiAPIService - Claude API service
   * @param {Object} config - Tool configuration
   */
  constructor(GeminiAPIService, config = {}) {
    super('dangling_modifier_checker', config);
    this.GeminiAPIService = GeminiAPIService;
    // console.log('DanglingModifierChecker initialized with config:', 
    //   util.inspect(config, { depth: 1, colors: true }));
  }
  
  /**
   * Execute the tool
   * @param {Object} options - Tool options
   * @returns {Promise<Object>} - Execution result
   */
  async execute(options) {
    console.log('Executing Dangling Modifier Checker with options:', options);
    
    // Extract options
    let manuscriptFile = options.manuscript_file;
    const analysisLevel = options.analysis_level;
    const modifierTypes = options.modifier_types;
    const sensitivity = options.sensitivity;
    const analysisDescription = options.analysis_description;
    const saveDir = options.save_dir || appState.CURRENT_PROJECT_PATH;
    
    if (!saveDir) {
      const errorMsg = 'Error: No save directory specified and no current project selected.\n' +
                      'Please select a project or specify a save directory.';
      this.emitOutput(errorMsg);
      throw new Error('No save directory available');
    }

    // Ensure file paths are absolute
    manuscriptFile = this.ensureAbsolutePath(manuscriptFile, saveDir);
    
    // Log the full paths for debugging
    console.log('Using full paths:');
    console.log(`Manuscript: ${manuscriptFile}`);

    const outputFiles = [];
    
    try {
      // Read the input files
      this.emitOutput(`Reading files...\n`);

      // Read the manuscript file
      this.emitOutput(`Reading manuscript file: ${manuscriptFile}\n`);
      const manuscriptContent = await this.readInputFile(manuscriptFile);
      
      // Create the prompt
      const prompt = this.createModifierAnalysisPrompt(manuscriptContent, analysisLevel, modifierTypes, sensitivity);

      // Count tokens in the prompt
      this.emitOutput(`Counting tokens in prompt...\n`);
      const promptTokens = await this.GeminiAPIService.countTokens(prompt);

      // Call the shared token budget calculator
      const tokenBudgets = this.GeminiAPIService.calculateTokenBudgets(promptTokens);

      // Handle logging based on the returned values
      this.emitOutput(`\nToken stats:\n`);
      this.emitOutput(`Max AI model context window: [${tokenBudgets.contextWindow}] tokens\n`);
      this.emitOutput(`Input prompt tokens: [${tokenBudgets.promptTokens}] ...\n`);
      this.emitOutput(`                     = manuscript + prompt instructions\n`);
      this.emitOutput(`Available tokens: [${tokenBudgets.availableTokens}]  = ${tokenBudgets.contextWindow} - ${tokenBudgets.promptTokens} = context_window - prompt\n`);
      this.emitOutput(`Desired output tokens: [${tokenBudgets.desiredOutputTokens}]\n`);
      this.emitOutput(`AI model thinking budget: [${tokenBudgets.thinkingBudget}] tokens\n`);
      this.emitOutput(`Max output tokens: [${tokenBudgets.maxTokens}] tokens\n`);

      // Check for special conditions
      if (tokenBudgets.capThinkingBudget) {
        this.emitOutput(`Warning: thinking budget is larger than 32K, set to 32K.\n`);
      }

      // Check if the prompt is too large
      if (tokenBudgets.isPromptTooLarge) {
        this.emitOutput(`Error: prompt is too large to have a ${tokenBudgets.configuredThinkingBudget} thinking budget!\n`);
        this.emitOutput(`Run aborted!\n`);
        throw new Error(`Prompt is too large for ${tokenBudgets.configuredThinkingBudget} thinking budget - run aborted`);
      }
      
      // Call Claude API with streaming
      this.emitOutput(`>>> Sending request to Claude API (streaming)...\n`);

      // Add a message about waiting
      this.emitOutput(`****************************************************************************\n`);
      this.emitOutput(`*  Analyzing dangling and misplaced modifiers in your manuscript...        \n`);
      this.emitOutput(`*  This process typically takes several minutes.                           \n`);
      this.emitOutput(`*                                                                          \n`);
      this.emitOutput(`*  It's recommended to keep this window the sole 'focus'                   \n`);
      this.emitOutput(`*  and to avoid browsing online or running other apps, as these API        \n`);
      this.emitOutput(`*  network connections are often flakey, like delicate echoes of whispers. \n`);
      this.emitOutput(`*                                                                          \n`);
      this.emitOutput(`*  So breathe, remove eye glasses, stretch, relax, and be like water 🥋 🧘🏽‍♀️\n`);
      this.emitOutput(`****************************************************************************\n\n`);
      
      const startTime = Date.now();
      let fullResponse = "";
      let thinkingContent = "";
      
      // Create system prompt to avoid markdown
      const systemPrompt = "CRITICAL INSTRUCTION: NO Markdown formatting of ANY kind. Never use headers, bullets, or any formatting symbols. Plain text only with standard punctuation.";

      // Use the calculated values in the API call - FIXED to match narrative-integrity.js pattern
      try {
        await this.GeminiAPIService.streamWithThinking(
          prompt,
          {
            system: systemPrompt,
            max_tokens: tokenBudgets.maxTokens,
            thinking: {
              type: "enabled",
              budget_tokens: tokenBudgets.thinkingBudget
            }
          },
          // Callback for thinking content
          (thinkingDelta) => {
            thinkingContent += thinkingDelta;
          },
          // Callback for response text
          (textDelta) => {
            fullResponse += textDelta;
          }
        );
      } catch (error) {
        this.emitOutput(`\nAPI Error: ${error.message}\n`);
        throw error;
      }

      const elapsed = (Date.now() - startTime) / 1000;
      const minutes = Math.floor(elapsed / 60);
      const seconds = elapsed % 60;
      
      this.emitOutput(`\nCompleted in ${minutes}m ${seconds.toFixed(2)}s.\n`);
      
      // Count words in response
      const wordCount = this.countWords(fullResponse);
      this.emitOutput(`Report has approximately ${wordCount} words.\n`);
      
      // Count tokens in response
      const responseTokens = await this.GeminiAPIService.countTokens(fullResponse);
      this.emitOutput(`Response token count: ${responseTokens}\n`);

      // Remove any markdown formatting
      fullResponse = this.removeMarkdown(fullResponse);

      // Save the report
      const outputFile = await this.saveReport(
        analysisLevel,
        modifierTypes,
        sensitivity,
        fullResponse,
        thinkingContent,
        promptTokens,
        responseTokens,
        saveDir,
        analysisDescription
      );
      
      // Add all output files to the result
      outputFiles.push(...outputFile);
      
      // Add files to the cache
      const toolName = 'dangling_modifier_checker';
      outputFiles.forEach(file => {
        fileCache.addFile(toolName, file);
      });
      
      // Return the result
      return {
        success: true,
        outputFiles,
        stats: {
          wordCount,
          tokenCount: responseTokens,
          elapsedTime: `${minutes}m ${seconds.toFixed(2)}s`,
          analysisLevel,
          modifierTypes,
          sensitivity
        }
      };
    } catch (error) {
      console.error('Error in DanglingModifierChecker:', error);
      this.emitOutput(`\nError: ${error.message}\n`);
      throw error;
    }
  }
  
  /**
   * Create modifier analysis prompt
   * @param {string} manuscriptContent - Manuscript content
   * @param {string} analysisLevel - Analysis level (basic, standard, detailed)
   * @param {Array|string} modifierTypes - Types of modifiers to analyze
   * @param {string} sensitivity - Sensitivity level (low, medium, high)
   * @returns {string} - Prompt for Claude API
   */
  createModifierAnalysisPrompt(manuscriptContent, analysisLevel = "standard", modifierTypes = ["dangling", "misplaced", "squinting", "limiting"], sensitivity = "medium") {
    // Build instruction section based on analysis level
    const basicInstructions = `
1. MODIFIER PROBLEM OVERVIEW:
   - Identify the most obvious dangling and misplaced modifiers in the manuscript
   - Highlight patterns of modifier usage that create confusion
   - Explain how these problems affect clarity and readability

2. DANGLING MODIFIER ANALYSIS:
   - Identify introductory phrases that don't logically connect to the subject that follows
   - Flag participial phrases (-ing, -ed) that appear to modify the wrong noun
   - Point out modifiers that create unintentional humor or confusion
   - Provide clear examples with correction suggestions

3. MISPLACED MODIFIER ANALYSIS:
   - Identify words, phrases, or clauses positioned where they modify the wrong element
   - Point out adverbs or adjectives that are placed too far from what they modify
   - Highlight restrictive modifiers (only, just, nearly, etc.) that modify the wrong element
   - Suggest proper placement for clarity
`;

    const standardInstructions = basicInstructions + `
4. SQUINTING MODIFIER ANALYSIS:
   - Identify modifiers that could logically apply to either preceding or following elements
   - Flag ambiguous adverbs that create unclear meaning
   - Examine sentences where it's unclear what a modifier is intended to modify
   - Suggest restructuring for clarity

5. COORDINATION PROBLEMS:
   - Identify faulty parallelism in lists or series that creates modifier problems
   - Point out correlative conjunctions (not only/but also, either/or) with misaligned elements
   - Analyze comparisons that create logical inconsistencies
   - Suggest restructuring to maintain logical relationships
`;

    const detailedInstructions = standardInstructions + `
6. CONTEXTUAL MODIFIER ISSUES:
   - Analyze how modifier problems affect character voice or narrative clarity
   - Identify patterns of modifier issues in different types of passages (dialogue, description, action)
   - Examine how modifier issues affect pacing or create reader confusion
   - Suggest revision strategies tailored to different passage types

7. LIMITING MODIFIER ANALYSIS:
   - Identify modifiers that create unintended restrictions or qualifications
   - Analyze how placement of limiting modifiers (only, just, even, etc.) affects meaning
   - Examine noun phrase modifiers that create ambiguity
   - Suggest precise placement to convey intended meaning

8. COMPLEX STRUCTURE ISSUES:
   - Identify problems in sentences with multiple clauses or nested modifiers
   - Analyze long sentences where modifier relationships become unclear
   - Examine complex descriptive passages for modifier clarity
   - Suggest simplification or restructuring strategies
`;

    // Choose the appropriate instruction level
    let instructionSet;
    if (analysisLevel === "basic") {
      instructionSet = basicInstructions;
    } else if (analysisLevel === "detailed") {
      instructionSet = detailedInstructions;
    } else {  // standard
      instructionSet = standardInstructions;
    }

    // Construct the modifier types emphasis
    let modifierTypesText;
    if (Array.isArray(modifierTypes)) {
      modifierTypesText = modifierTypes.join(", ");
    } else {
      // Handle the case where modifierTypes might be a string
      modifierTypesText = String(modifierTypes);
    }

    // Adjust instructions based on sensitivity level
    const sensitivityInstructions = {
      "low": "Focus only on the most obvious and confusing modifier issues that significantly impact meaning.",
      "medium": "Identify moderate to major modifier issues, balancing technical correctness with stylistic considerations.",
      "high": "Perform a detailed analysis of all potential modifier issues, noting even subtle cases of ambiguity."
    };
    
    const sensitivityText = sensitivityInstructions[sensitivity] || sensitivityInstructions["medium"];

    // Construct the full prompt
    const instructions = `IMPORTANT: NO Markdown formatting

You are an expert literary editor specializing in grammatical clarity and precision. Your task is to analyze the provided manuscript for dangling and misplaced modifiers, focusing particularly on: ${modifierTypesText}.

Follow Ursula K. Le Guin's guidance from "Steering the Craft" on the importance of clear, precise sentence construction. Dangling modifiers occur when a descriptive phrase doesn't connect logically to what it's supposed to modify, creating confusion or unintentional humor. In her words, "danglers can really wreck the scenery."

Sensitivity level: ${sensitivity}. ${sensitivityText}

Pay special attention to:
1. Introductory phrases that don't logically connect to the subject that follows
   Example: "Walking down the street, the trees were beautiful." (Who is walking?)
   Corrected: "Walking down the street, I thought the trees were beautiful."

2. Participial phrases (-ing, -ed) that appear to modify the wrong noun
   Example: "Rushing to catch the train, my coffee spilled everywhere." (The coffee wasn't rushing)
   Corrected: "Rushing to catch the train, I spilled my coffee everywhere."

3. Modifiers placed too far from what they're modifying
   Example: "She served cake to the children on paper plates." (Were the children on paper plates?)
   Corrected: "She served cake on paper plates to the children."

4. Limiting modifiers (only, just, nearly, almost) that modify the wrong element
   Example: "He only eats vegetables on Tuesdays." (Does he do nothing else with vegetables on Tuesdays?)
   Corrected: "He eats vegetables only on Tuesdays."

5. Squinting modifiers that could apply to either what comes before or after
   Example: "Drinking coffee quickly improves alertness." (Does "quickly" modify drinking or improves?)
   Corrected: "Quickly drinking coffee improves alertness." OR "Drinking coffee improves alertness quickly."

For each issue you identify, provide:
- The original sentence with the modifier problem
- An explanation of why it's problematic
- A suggested revision that maintains the author's intended meaning

Create a comprehensive modifier analysis with these sections:
${instructionSet}

Format your analysis as a clear, organized report with sections and subsections. Use plain text formatting only (NO Markdown). Use numbered or bulleted lists where appropriate for clarity.

Be specific in your examples and suggestions, showing how modifier placement can be improved without changing the author's voice or intention. Focus on practical changes that will make the writing clearer and more effective.
`;

    // Combine all sections
    return `=== MANUSCRIPT ===\n${manuscriptContent}\n=== END MANUSCRIPT ===\n\n${instructions}`;
  }

  /**
   * Count words in text
   * @param {string} text - Text to count words in
   * @returns {number} - Word count
   */
  countWords(text) {
    return text.split(/\s+/).filter(word => word.length > 0).length;
  }
  
  /**
   * Ensure file path is absolute
   * @param {string} filePath - File path (may be relative or absolute)
   * @param {string} basePath - Base path to prepend for relative paths
   * @returns {string} - Absolute file path
   */
  ensureAbsolutePath(filePath, basePath) {
    if (!filePath) return filePath;
    
    // Check if the path is already absolute
    if (path.isAbsolute(filePath)) {
      return filePath;
    }
    
    // Make the path absolute by joining with the base path
    return path.join(basePath, filePath);
  }
  
  /**
   * Save report and thinking content to files
   * @param {string} analysisLevel - Analysis level (basic, standard, detailed)
   * @param {Array|string} modifierTypes - Types of modifiers analyzed
   * @param {string} sensitivity - Sensitivity level (low, medium, high)
   * @param {string} content - Response content
   * @param {string} thinking - Thinking content
   * @param {number} promptTokens - Prompt token count
   * @param {number} responseTokens - Response token count
   * @param {string} saveDir - Directory to save to
   * @param {string} description - Optional description
   * @returns {Promise<string[]>} - Array of paths to saved files
   */
  async saveReport(
    analysisLevel,
    modifierTypes,
    sensitivity,
    content,
    thinking,
    promptTokens,
    responseTokens,
    saveDir,
    description
  ) {
    try {
      const formatter = new Intl.DateTimeFormat('en-US', {
        weekday: 'long',
        month: 'long',
        day: 'numeric',
        year: 'numeric',
        hour: 'numeric',
        minute: '2-digit',
        hour12: true
      });
      const dateTimeStr = formatter.format(new Date());

      // Create timestamp for filename
      const timestamp = new Date().toISOString().replace(/[-:.]/g, '').substring(0, 15);
      
      // Create descriptive filename
      const desc = description ? `_${description}` : '';
      const level = analysisLevel !== 'standard' ? `_${analysisLevel}` : '';
      const baseFilename = `dangling_modifier_check${desc}${level}_${timestamp}`;
      
      // Array to collect all saved file paths
      const savedFilePaths = [];
      
      // Format modifierTypes for stats
      const modifierTypesStr = Array.isArray(modifierTypes) ? modifierTypes.join(', ') : modifierTypes;
      
      // Create stats for thinking file
      const stats = `
Details:  ${dateTimeStr}
Analysis type: Dangling and misplaced modifier analysis
Analysis level: ${analysisLevel}
Modifier types: ${modifierTypesStr}
Sensitivity level: ${sensitivity}
Max request timeout: ${this.config.request_timeout} seconds
Max AI model context window: ${this.config.context_window} tokens
AI model thinking budget: ${this.config.thinking_budget_tokens} tokens
Desired output tokens: ${this.config.desired_output_tokens} tokens

Input tokens: ${promptTokens}
Output tokens: ${responseTokens}
`;
      
      // Save full response
      const reportFilename = `${baseFilename}.txt`;
      const reportPath = path.join(saveDir, reportFilename);
      await this.writeOutputFile(content, saveDir, reportFilename);
      savedFilePaths.push(reportPath);
      
      // Save thinking content if available and not skipped
      if (thinking) {
        const thinkingFilename = `${baseFilename}_thinking.txt`;
        const thinkingPath = path.join(saveDir, thinkingFilename);
        const thinkingContent = `=== DANGLING MODIFIER ANALYSIS ===

=== AI'S THINKING PROCESS ===

${thinking}

=== END AI'S THINKING PROCESS ===
${stats}`;
        
        await this.writeOutputFile(thinkingContent, saveDir, thinkingFilename);
        this.emitOutput(`AI thinking saved to: ${thinkingPath}\n`);
        savedFilePaths.push(thinkingPath);
      }

      this.emitOutput(`Report saved to: ${reportPath}\n`);
      return savedFilePaths;
    } catch (error) {
      console.error(`Error saving report:`, error);
      this.emitOutput(`Error saving report: ${error.message}\n`);
      throw error;
    }
  }
}

module.exports = DanglingModifierChecker;

============================================================
FILE: developmental-editing.js
SIZE: 16176 bytes
LANGUAGE: JS
============================================================

// developmental-editing.js
const BaseTool = require('./base-tool');
const path = require('path');
const fileCache = require('./file-cache');
const appState = require('./state.js');
const fs = require('fs/promises');
const textProcessor = require('./textProcessor');

/**
 * DevelopmentalEditing Tool
 * Analyzes a manuscript for structural foundation issues, including plot holes,
 * character arcs, pacing, narrative viewpoint, themes, worldbuilding, and more.
 */
class DevelopmentalEditing extends BaseTool {
  /**
   * Constructor
   * @param {Object} GeminiAPIService - Claude API service
   * @param {Object} config - Tool configuration
   */
  constructor(GeminiAPIService, config = {}) {
    super('developmental_editing', config);
    this.GeminiAPIService = GeminiAPIService;
  }

  /**
   * Execute the tool
   * @param {Object} options - Tool options
   * @returns {Promise<Object>} - Execution result
   */
  async execute(options) {
    console.log('Executing Developmental Editing with options:', options);
    
    // Clear the cache for this tool
    const toolName = 'developmental_editing';
    fileCache.clear(toolName);
    
    // Extract options
    let manuscriptFile = options.manuscript_file;
    const language = options.language || 'English';
    const saveDir = options.save_dir || appState.CURRENT_PROJECT_PATH;
    
    if (!saveDir) {
      const errorMsg = 'Error: No save directory specified and no current project selected.\n' +
                      'Please select a project or specify a save directory.';
      this.emitOutput(errorMsg);
      throw new Error('No save directory available');
    }

    // Ensure file paths are absolute
    manuscriptFile = this.ensureAbsolutePath(manuscriptFile, saveDir);

    const outputFiles = [];
    
    try {
      // Read the input files
      this.emitOutput(`Reading manuscript file: ${manuscriptFile}\n`);
      const manuscriptContent = await this.readInputFile(manuscriptFile);

      // Process manuscript to remove chapter headers and normalize blank lines
      const manuscriptWithoutChapterHeaders = textProcessor.processText(manuscriptContent);
      
      // Create prompt using the template with language substitution
      const prompt = this.createPrompt(manuscriptWithoutChapterHeaders, language);

      // Count tokens in the prompt
      this.emitOutput(`Counting tokens in prompt...\n`);
      const promptTokens = await this.GeminiAPIService.countTokens(prompt);

      // Call the shared token budget calculator
      const tokenBudgets = this.GeminiAPIService.calculateTokenBudgets(promptTokens);

      // Handle logging based on the returned values
      this.emitOutput(`\nToken stats:\n`);
      this.emitOutput(`Max AI model context window: [${tokenBudgets.contextWindow}] tokens\n`);
      this.emitOutput(`Input prompt tokens: [${tokenBudgets.promptTokens}] ...\n`);
      this.emitOutput(`Available tokens: [${tokenBudgets.availableTokens}]  = ${tokenBudgets.contextWindow} - ${tokenBudgets.promptTokens} = context_window - prompt\n`);
      this.emitOutput(`Desired output tokens: [${tokenBudgets.desiredOutputTokens}]\n`);
      this.emitOutput(`AI model thinking budget: [${tokenBudgets.thinkingBudget}] tokens\n`);
      this.emitOutput(`Max output tokens: [${tokenBudgets.maxTokens}] tokens\n`);

      // Check for special conditions
      if (tokenBudgets.capThinkingBudget) {
        this.emitOutput(`Warning: thinking budget is larger than 32K, set to 32K.\n`);
      }

      // Check if the prompt is too large
      if (tokenBudgets.isPromptTooLarge) {
        this.emitOutput(`Error: prompt is too large to have a ${tokenBudgets.configuredThinkingBudget} thinking budget!\n`);
        this.emitOutput(`Run aborted!\n`);
        throw new Error(`Prompt is too large for ${tokenBudgets.configuredThinkingBudget} thinking budget - run aborted`);
      }
      
      // Call Claude API with streaming
      this.emitOutput(`Sending request to Claude API (streaming)...\n`);
      
      // Add a message about waiting
      this.emitOutput(`****************************************************************************\n`);
      this.emitOutput(`*  Performing developmental editing for ${language} manuscript...           \n`);
      this.emitOutput(`*  This process typically takes several minutes.                           \n`);
      this.emitOutput(`*                                                                          \n`);
      this.emitOutput(`*  The developmental editor will analyze:                                  \n`);
      this.emitOutput(`*  - Plot structure and holes                                              \n`);
      this.emitOutput(`*  - Character arcs and development                                        \n`);
      this.emitOutput(`*  - Pacing and narrative structure                                        \n`);
      this.emitOutput(`*  - Narrative viewpoint consistency                                       \n`);
      this.emitOutput(`*  - Thematic development and resolution                                   \n`);
      this.emitOutput(`*  - Worldbuilding coherence                                               \n`);
      this.emitOutput(`*  - Emotional engagement and payoffs                                      \n`);
      this.emitOutput(`****************************************************************************\n\n`);
      
      const startTime = Date.now();
      let fullResponse = "";
      let thinkingContent = "";
      
      // Create system prompt - more explicit guidance
      const systemPrompt = "You are a professional developmental editor focused on the structural foundations of storytelling. Provide clear, specific feedback on plot structure, character development, pacing, worldbuilding, and thematic elements. DO NOT use any Markdown formatting - no headers, bullets, numbering, asterisks, hyphens, or any formatting symbols. Plain text only. Focus on substantive issues rather than line-level editing.";

      // Use the calculated values in the API call
      try {
        await this.GeminiAPIService.streamWithThinking(
          prompt,
          {
            system: systemPrompt,
            max_tokens: tokenBudgets.maxTokens,
            thinking: {
              type: "enabled",
              budget_tokens: tokenBudgets.thinkingBudget
            }
          },
          // Callback for thinking content
          (thinkingDelta) => {
            thinkingContent += thinkingDelta;
          },
          // Callback for response text
          (textDelta) => {
            fullResponse += textDelta;
          }
        );
      } catch (error) {
        this.emitOutput(`\nAPI Error: ${error.message}\n`);
        throw error;
      }

      const elapsed = (Date.now() - startTime) / 1000;
      const minutes = Math.floor(elapsed / 60);
      const seconds = elapsed % 60;
      
      this.emitOutput(`\nCompleted in ${minutes}m ${seconds.toFixed(2)}s.\n`);
      
      // Count words in response
      const wordCount = this.countWords(fullResponse);
      this.emitOutput(`Report has approximately ${wordCount} words.\n`);
      
      // Count tokens in response
      const responseTokens = await this.GeminiAPIService.countTokens(fullResponse);
      this.emitOutput(`Response token count: ${responseTokens}\n`);

      // Remove any markdown formatting
      fullResponse = this.removeMarkdown(fullResponse);

      // Save the report
      const outputFile = await this.saveReport(
        fullResponse,
        thinkingContent,
        promptTokens,
        responseTokens,
        saveDir,
        language
      );
      
      // Add the output files to the result
      outputFiles.push(...outputFile);
      
      // Add files to the cache
      outputFiles.forEach(file => {
        fileCache.addFile(toolName, file);
      });
      
      // Return the result
      return {
        success: true,
        outputFiles
      };
    } catch (error) {
      console.error('Error in DevelopmentalEditing:', error);
      this.emitOutput(`\nError: ${error.message}\n`);
      throw error;
    }
  }
  
  /**
   * Create prompt
   * @param {string} manuscriptContent - Manuscript content
   * @param {string} language - Language for developmental editing (default: English)
   * @returns {string} - Prompt for Claude API
   */
  createPrompt(manuscriptContent, language = 'English') {
    // Template for developmental editing
    const template = `You are acting as a professional ${language} developmental editor reviewing a complete manuscript. Your task is to evaluate the structural foundation of this story. The manuscript is provided as plain text in its entirety.

=== MANUSCRIPT ===
${manuscriptContent}
=== END MANUSCRIPT ===

Approach this developmental edit systematically by examining the following structural elements:

PLOT STRUCTURE
- Identify plot holes where story logic breaks down
- Evaluate the logical progression of cause and effect
- Assess if the narrative has a clear inciting incident, rising action, climax, and resolution
- Analyze whether story promises made to readers are fulfilled
- Check if key plot developments are properly foreshadowed

CHARACTER DEVELOPMENT
- Map character arcs to ensure proper growth and development
- Assess character motivations and whether actions align with established traits
- Identify inconsistencies in character behavior or backstory
- Evaluate if protagonists face meaningful obstacles that challenge their beliefs
- Check if antagonists have sufficient depth and clear motivations

PACING AND STRUCTURE
- Analyze scene-by-scene pacing, identifying areas that drag or move too quickly
- Evaluate overall rhythm
- Identify redundant scenes that don't advance plot or character development
- Assess the opening hook for effectiveness in engaging readers
- Evaluate the ending for satisfying resolution of primary conflicts

NARRATIVE CRAFT
- Evaluate narrative viewpoint consistency and effectiveness
- Assess narrative distance (close vs. distant POV) and its appropriateness
- Identify areas where showing vs. telling could be better balanced
- Check for effective use of tension, suspense, and conflict
- Evaluate dialogue effectiveness in advancing plot and revealing character

THEMATIC ELEMENTS
- Examine how themes are introduced, developed, and resolved
- Identify opportunities to strengthen thematic elements
- Assess if theme is integrated naturally or feels forced
- Evaluate symbolic elements and their consistency

WORLDBUILDING
- Assess worldbuilding elements for coherence and believability
- Check for consistent application of established rules (especially in speculative fiction)
- Identify areas where additional context would improve reader understanding
- Evaluate exposition delivery for clarity without overwhelming readers

NARRATIVE EFFICIENCY
- Identify redundant subplots or characters that can be combined
- Flag areas where tension drops or conflict becomes unclear
- Assess secondary character arcs for relevance to main story
- Evaluate if subplots complement or distract from the main plot

EMOTIONAL ENGAGEMENT
- Assess if emotional payoffs are properly set up and delivered
- Identify missed opportunities for emotional resonance
- Evaluate the emotional journey of the protagonist
- Check if reader investment is maintained throughout

For each significant issue found:
1. Identify the specific issue with reference to where it occurs
2. Explain why it's problematic for the story's structure
3. Provide specific, actionable suggestions for addressing it
4. When possible, cite examples from the manuscript to illustrate your points

Do not focus on line-level editing issues like grammar, spelling, or word choice unless they significantly impact clarity of the narrative.

Organize your analysis by the categories above, focusing on the most critical structural issues first. 
For each major issue, provide:
- A clear description of the problem
- Why it matters to the overall story
- Specific suggestions for improvement
- Reference the text verbatim as it is in the manuscript, do not add extra quotes

VERY IMPORTANT:
- Do NOT hurry to finish!
- Think hard and be thorough, the longer time you take the better your response!
- Always re-read the entire manuscript (see: === MANUSCRIPT === above) many times, which will help you to not miss any structural issues.
- Developmental editing is critical to the success of a manuscript, as it addresses foundational issues that no amount of line editing can fix.
`;

    return template;
  }

  /**
   * Count words in text
   * @param {string} text - Text to count words in
   * @returns {number} - Word count
   */
  countWords(text) {
    return text.split(/\s+/).filter(word => word.length > 0).length;
  }
  
  /**
   * Ensure file path is absolute
   * @param {string} filePath - File path (may be relative or absolute)
   * @param {string} basePath - Base path to prepend for relative paths
   * @returns {string} - Absolute file path
   */
  ensureAbsolutePath(filePath, basePath) {
    if (!filePath) return filePath;
    
    // Check if the path is already absolute
    if (path.isAbsolute(filePath)) {
      return filePath;
    }
    
    // Make the path absolute by joining with the base path
    return path.join(basePath, filePath);
  }
  
  /**
   * Save report and thinking content to files
   * @param {string} content - Response content
   * @param {string} thinking - Thinking content
   * @param {number} promptTokens - Prompt token count
   * @param {number} responseTokens - Response token count
   * @param {string} saveDir - Directory to save to
   * @param {string} language - Language used for developmental editing
   * @returns {Promise<string[]>} - Array of paths to saved files
   */
  async saveReport(
    content,
    thinking,
    promptTokens,
    responseTokens,
    saveDir,
    language = 'English'
  ) {
    try {
      const formatter = new Intl.DateTimeFormat('en-US', {
        weekday: 'long',
        month: 'long',
        day: 'numeric',
        year: 'numeric',
        hour: 'numeric',
        minute: '2-digit',
        hour12: true
      });
      const dateTimeStr = formatter.format(new Date());

      // Create timestamp for filename
      const timestamp = new Date().toISOString().replace(/[-:.]/g, '').substring(0, 15);
      
      // Create descriptive filename
      const baseFilename = `developmental_editing_${language.toLowerCase()}_${timestamp}`;
      
      // Array to collect all saved file paths
      const savedFilePaths = [];
      
      // Create stats for thinking file
      const stats = `
Details:  ${dateTimeStr}
Language: ${language}
Max request timeout: ${this.config.request_timeout} seconds
Max AI model context window: ${this.config.context_window} tokens
AI model thinking budget: ${this.config.thinking_budget_tokens} tokens
Desired output tokens: ${this.config.desired_output_tokens} tokens

Input tokens: ${promptTokens}
Output tokens: ${responseTokens}
`;
      
      // Save full response
      const reportFilename = `${baseFilename}.txt`;
      const reportPath = path.join(saveDir, reportFilename);
      await this.writeOutputFile(content, saveDir, reportFilename);
      savedFilePaths.push(reportPath);
      this.emitOutput(`Report saved to: ${reportPath}\n`);

      // Save thinking content if available
      if (thinking) {
        const thinkingFilename = `${baseFilename}_thinking.txt`;
        const thinkingContent = `=== DEVELOPMENTAL EDITING THINKING ===

${thinking}

=== END DEVELOPMENTAL EDITING THINKING ===
${stats}`;
        
        const thinkingReportPath = path.join(saveDir, thinkingFilename);
        await this.writeOutputFile(thinkingContent, saveDir, thinkingFilename);
        savedFilePaths.push(thinkingReportPath);
        this.emitOutput(`AI thinking saved to: ${path.join(saveDir, thinkingFilename)}\n`);
      }
      
      return savedFilePaths;
    } catch (error) {
      console.error(`Error saving report:`, error);
      this.emitOutput(`Error saving report: ${error.message}\n`);
      throw error;
    }
  }
}

module.exports = DevelopmentalEditing;

============================================================
FILE: docx-comments.js
SIZE: 17984 bytes
LANGUAGE: JS
============================================================

// docx-comments.js
const BaseTool = require('./base-tool');
const path = require('path');
const fs = require('fs');
const fsPromises = require('fs/promises');
const fileCache = require('./file-cache');
const appState = require('./state.js');
const mammoth = require('mammoth');
const JSZip = require('jszip');
const { DOMParser } = require('xmldom');
const xpath = require('xpath');
const os = require('os');

/**
 * DocxComments Tool
 * Extracts comments from a Word DOCX file and saves them to a text file
 */
class DocxComments extends BaseTool {
  /**
   * Constructor
   * @param {string} name - Tool name
   * @param {Object} config - Tool configuration
   */
  constructor(name, config = {}) {
    super(name, config);
  }

  /**
   * Execute the tool
   * @param {Object} options - Tool options
   * @returns {Promise<Object>} - Execution result
   */
  async execute(options) {
    console.log('Executing DocxComments with options:', options);
    
    // Extract options
    let docxFile = options.docx_file;
    const saveDir = options.save_dir || appState.CURRENT_PROJECT_PATH;
    
    if (!saveDir) {
      const errorMsg = 'Error: No save directory specified and no current project selected.\n' +
                      'Please select a project or specify a save directory.';
      this.emitOutput(errorMsg);
      throw new Error('No save directory available');
    }

    // Ensure file paths are absolute
    docxFile = this.ensureAbsolutePath(docxFile, saveDir);

    const outputFiles = [];
    
    try {
      // Read the input file
      this.emitOutput(`Reading DOCX file: ${docxFile}\n`);
      
      // Check if file exists
      if (!fs.existsSync(docxFile)) {
        throw new Error(`File not found: ${docxFile}`);
      }
      
      this.emitOutput(`Extracting comments from DOCX file...\n`);
      
      // Process the DOCX file
      const result = await this.processDocx(docxFile, saveDir);
      
      if (result.noComments) {
        this.emitOutput(`No comments found in document. Document content saved to: ${result.outputPath}\n`);
      } else {
        this.emitOutput(`Comments extracted and saved to: ${result.outputPath}\n`);
      }
      
      // Add to output files list
      outputFiles.push(result.outputPath);
      
      // Add to the file cache
      const toolName = 'docx_comments';
      fileCache.addFile(toolName, result.outputPath);
      
      // Return the result
      return {
        success: true,
        outputFiles
      };
    } catch (error) {
      console.error('Error in DocxComments:', error);
      this.emitOutput(`\nError: ${error.message}\n`);
      throw error;
    }
  }
  
  /**
   * Process a DOCX file to extract comments
   * @param {string} docxFilePath - Path to the DOCX file
   * @param {string} outputDir - Directory to save output
   * @returns {Promise<Object>} - Processing result
   */
  async processDocx(docxFilePath, outputDir) {
    let tempDir = null;
    
    try {
      // Extract comments from DOCX using multiple methods
      const extractionResult = await this.extractComments(docxFilePath);
      tempDir = extractionResult.tempDir; // Save temp directory for cleanup
      
      this.emitOutput(`Extracted ${extractionResult.comments.length} comments total\n`);
      
      if (extractionResult.comments.length === 0) {
        this.emitOutput('No comments found in the document\n');
        
        // Create minimal output with just document content
        const timestamp = new Date().toISOString().replace(/[-:.]/g, '').substring(0, 15);
        const baseFileName = path.basename(docxFilePath, '.docx');
        const outputFilename = `${baseFileName}_content_only_${timestamp}.txt`;
        const outputPath = path.join(outputDir, outputFilename);
        
        await this.writeOutputFile(
          this.cleanupText(extractionResult.documentContent || 'No document content extracted'),
          outputDir,
          outputFilename
        );
        
        // Clean up temp files
        if (tempDir) {
          await this.cleanupTempFiles(tempDir);
        }
        
        return { noComments: true, outputPath };
      }
      
      // Generate formatted output with the comments
      const result = await this.generateFormattedOutput(extractionResult, docxFilePath, outputDir);
      
      // Clean up temp files after successful processing
      if (tempDir) {
        await this.cleanupTempFiles(tempDir);
      }
      
      return result;
      
    } catch (error) {
      console.error('Error processing DOCX:', error);
      
      // Attempt to clean up temp files even if processing failed
      if (tempDir) {
        await this.cleanupTempFiles(tempDir);
      }
      
      throw error;
    }
  }
  
  /**
   * Extract comments from a DOCX file
   * @param {string} docxFilePath - Path to the DOCX file
   * @returns {Promise<Object>} - Extraction result with comments and content
   */
  async extractComments(docxFilePath) {
    this.emitOutput(`Extracting comments from: ${docxFilePath}\n`);
    
    try {
      // Create a temporary directory in the user's writing folder
      const homePath = os.homedir();
      const extractDir = path.join(homePath, 'writing', 'temp_docx_extraction');
      await fsPromises.mkdir(extractDir, { recursive: true });
      
      this.emitOutput(`Created temporary directory: ${extractDir}\n`);
      
      // First approach: Extract raw XML for detailed comment analysis
      const fileData = fs.readFileSync(docxFilePath);
      const zip = new JSZip();
      const doc = await zip.loadAsync(fileData);
      
      // Extract comments.xml for direct comment data
      const commentsXml = await this.extractFileFromZip(doc, 'word/comments.xml', extractDir);
      const documentXml = await this.extractFileFromZip(doc, 'word/document.xml', extractDir);
      
      if (!commentsXml || !documentXml) {
        this.emitOutput('Required XML files not found in DOCX. Trying alternative approach...\n');
      }
      
      // Parse comments from XML
      const commentsFromXml = commentsXml ? this.extractCommentsFromXml(commentsXml) : [];
      this.emitOutput(`Extracted ${commentsFromXml.length} comments from XML\n`);
      
      // Second approach: Use mammoth to get HTML with comments
      const result = await mammoth.convertToHtml({ path: docxFilePath });
      const html = result.value;
      
      // Save the HTML for inspection
      await fsPromises.writeFile(path.join(extractDir, 'document.html'), html);
      
      // Extract text content and comments from HTML
      const { documentContent, commentsFromHtml } = this.extractCommentsFromHtml(html);
      this.emitOutput(`Extracted ${commentsFromHtml.length} comments from HTML\n`);
      
      // Third approach: Parse document XML for comment references
      let commentRefs = {};
      if (documentXml) {
        commentRefs = this.extractCommentReferences(documentXml);
        this.emitOutput(`Found ${Object.keys(commentRefs).length} comment references in document XML\n`);
      }
      
      // Combine all comment sources, prioritizing XML comments with references
      const allComments = this.mergeCommentSources(commentsFromXml, commentsFromHtml, commentRefs);
      this.emitOutput(`Final comment count: ${allComments.length}\n`);
      
      return { 
        comments: allComments, 
        documentContent,
        tempDir: extractDir // Return the temp directory path for cleanup later
      };
    } catch (error) {
      console.error('Error extracting comments:', error);
      throw error;
    }
  }
  
  /**
   * Extract a file from ZIP archive
   * @param {Object} doc - JSZip document object
   * @param {string} fileName - File to extract
   * @param {string} extractDir - Directory to extract to
   * @returns {Promise<string|null>} - File content or null
   */
  async extractFileFromZip(doc, fileName, extractDir) {
    const file = doc.file(fileName);
    if (!file) {
      console.log(`${fileName} not found in DOCX file`);
      return null;
    }
    
    const content = await file.async('string');
    await fsPromises.writeFile(path.join(extractDir, path.basename(fileName)), content);
    return content;
  }
  
  /**
   * Extract comments from comments.xml
   * @param {string} commentsXml - XML content
   * @returns {Array} - Array of comment objects
   */
  extractCommentsFromXml(commentsXml) {
    const parser = new DOMParser();
    const commentsDoc = parser.parseFromString(commentsXml, 'text/xml');
    
    // Set up namespaces for XPath
    const select = xpath.useNamespaces({
      'w': 'http://schemas.openxmlformats.org/wordprocessingml/2006/main'
    });
    
    // Find all comment nodes
    const commentNodes = select('//w:comment', commentsDoc);
    console.log(`Found ${commentNodes.length} comment nodes in comments.xml`);
    
    const comments = [];
    
    // Extract comment information
    for (const node of commentNodes) {
      const id = node.getAttribute('w:id');
      const author = node.getAttribute('w:author') || 'Unknown';
      const date = node.getAttribute('w:date') || '';
      
      // Extract the comment text
      const textNodes = select('.//w:t', node);
      let commentText = '';
      
      for (const textNode of textNodes) {
        commentText += textNode.textContent;
      }
      
      comments.push({
        id,
        author,
        date,
        text: commentText.trim(),
        referencedText: '' // Will be filled later
      });
    }
    
    return comments;
  }
  
  /**
   * Extract comment references from document XML
   * @param {string} documentXml - Document XML content
   * @returns {Object} - Map of comment IDs to referenced text
   */
  extractCommentReferences(documentXml) {
    const parser = new DOMParser();
    const docXmlDoc = parser.parseFromString(documentXml, 'text/xml');
    
    // Set up namespaces for XPath
    const select = xpath.useNamespaces({
      'w': 'http://schemas.openxmlformats.org/wordprocessingml/2006/main'
    });
    
    const commentRefs = {};
    
    // Strategy 1: Look for commentRangeStart and commentRangeEnd pairs
    const paragraphs = select('//w:p', docXmlDoc);
    
    for (const paragraph of paragraphs) {
      // Get the text content of the paragraph
      const textContent = this.extractParagraphText(paragraph, select);
      
      // Look for comment ranges
      const commentRangeStarts = select('.//w:commentRangeStart', paragraph);
      
      for (const startNode of commentRangeStarts) {
        const commentId = startNode.getAttribute('w:id');
        
        if (commentId) {
          commentRefs[commentId] = textContent;
        }
      }
      
      // Look for simple comment references (sometimes there are no explicit ranges)
      const commentRefs2 = select('.//w:commentReference', paragraph);
      for (const refNode of commentRefs2) {
        const commentId = refNode.getAttribute('w:id');
        
        if (commentId && !commentRefs[commentId]) {
          commentRefs[commentId] = textContent;
        }
      }
    }
    
    return commentRefs;
  }
  
  /**
   * Extract text from a paragraph element
   * @param {Object} paragraph - Paragraph node
   * @param {Function} select - XPath select function
   * @returns {string} - Paragraph text
   */
  extractParagraphText(paragraph, select) {
    const textNodes = select('.//w:t', paragraph);
    let text = '';
    
    for (const node of textNodes) {
      text += node.textContent;
    }
    
    return text.trim();
  }
  
  /**
   * Extract comments from HTML content
   * @param {string} html - HTML content
   * @returns {Object} - Document content and comments
   */
  extractCommentsFromHtml(html) {
    // Extract comments using HTML comment syntax as a backup method
    const commentRegex = /<!--\s*(.*?)\s*-->/g;
    const comments = [];
    const documentContent = html.replace(commentRegex, ''); // Remove comments from content
    
    let match;
    let index = 0;
    
    while ((match = commentRegex.exec(html)) !== null) {
      const commentText = match[1].trim();
      
      // Attempt to find the nearest text by looking at the context around the comment
      const start = Math.max(0, match.index - 200); // Look 200 chars before comment
      const end = Math.min(html.length, match.index + 200); // Look 200 chars after comment
      const context = html.substring(start, end);
      
      // Remove HTML tags to get plain text
      const contextText = context.replace(/<[^>]*>/g, ' ').replace(/\s+/g, ' ').trim();
      
      comments.push({
        id: `html-${index++}`,
        author: 'Unknown',
        date: '',
        text: commentText,
        referencedText: contextText
      });
    }
    
    return { documentContent, commentsFromHtml: comments };
  }
  
  /**
   * Merge comments from different sources
   * @param {Array} commentsFromXml - Comments from XML
   * @param {Array} commentsFromHtml - Comments from HTML
   * @param {Object} commentRefs - Comment references
   * @returns {Array} - Merged comments
   */
  mergeCommentSources(commentsFromXml, commentsFromHtml, commentRefs) {
    // First, add referenced text to XML comments
    const mergedComments = commentsFromXml.map(comment => {
      if (comment.id in commentRefs) {
        return {
          ...comment,
          referencedText: commentRefs[comment.id]
        };
      }
      return comment;
    });
    
    // If we didn't get enough XML comments, supplement with HTML comments
    if (mergedComments.length === 0) {
      return commentsFromHtml;
    }
    
    return mergedComments;
  }
  
  /**
   * Clean up text by replacing special characters
   * @param {string} text - Text to clean
   * @returns {string} - Cleaned text
   */
  cleanupText(text) {
    if (!text) return '';
    
    // Replace non-breaking spaces (Unicode \u00A0 or ASCII 160) with regular spaces
    let cleaned = text.replace(/\u00A0/g, ' ');
    
    // Replace multiple spaces with a single space
    cleaned = cleaned.replace(/\s+/g, ' ');
    
    // Trim leading/trailing whitespace
    cleaned = cleaned.trim();
    
    return cleaned;
  }
  
  /**
   * Generate formatted output with comments
   * @param {Object} extractionResult - Extraction result
   * @param {string} docxFilePath - Original DOCX file path
   * @param {string} outputDir - Directory to save output
   * @returns {Promise<Object>} - Output information
   */
  async generateFormattedOutput(extractionResult, docxFilePath, outputDir) {
    this.emitOutput('Generating formatted output of comments...\n');
    
    try {
      // Prepare the comments with their text for output
      let formattedComments = '';
      
      // Output comments with their referenced text
      if (extractionResult.comments.length > 0) {
        this.emitOutput(`Formatting ${extractionResult.comments.length} comments\n`);
        
        extractionResult.comments.forEach((comment, index) => {
          if (comment.referencedText && comment.referencedText.trim()) {
            // Clean up the referenced text
            const cleanedText = this.cleanupText(comment.referencedText);
            formattedComments += `original text:\n${cleanedText}\n\n`;
          }
          
          if (comment.text && comment.text.trim()) {
            // Clean up the comment text
            const cleanedComment = this.cleanupText(comment.text);
            formattedComments += `comment:\n${cleanedComment}\n\n`;
          }
          
          formattedComments += `---\n\n`;
        });
      } else {
        formattedComments = "No comments found in the document.";
        
        // Also output the document content for reference
        formattedComments += "\n\n=== DOCUMENT CONTENT ===\n\n";
        formattedComments += this.cleanupText(extractionResult.documentContent);
      }
      
      // Create output filename with timestamp
      const timestamp = new Date().toISOString().replace(/[-:.]/g, '').substring(0, 15);
      const baseFileName = path.basename(docxFilePath, '.docx');
      const outputFilename = `${baseFileName}_comments_${timestamp}.txt`;
      
      // Write the output file
      const outputPath = await this.writeOutputFile(formattedComments, outputDir, outputFilename);
      
      this.emitOutput(`\nExtracted comments saved to: ${outputPath}\n`);
      
      return { outputPath };
      
    } catch (error) {
      console.error('Error generating formatted output:', error);
      throw error;
    }
  }
  
  /**
   * Clean up temporary files
   * @param {string} tempDir - Temporary directory path
   * @returns {Promise<void>}
   */
  async cleanupTempFiles(tempDir) {
    try {
      if (fs.existsSync(tempDir)) {
        this.emitOutput(`Cleaning up temporary directory: ${tempDir}\n`);
        
        // Read all files in the directory
        const files = await fsPromises.readdir(tempDir);
        
        // Delete each file
        for (const file of files) {
          await fsPromises.unlink(path.join(tempDir, file));
        }
        
        // Remove the directory
        await fsPromises.rmdir(tempDir);
        this.emitOutput('Temporary files cleaned up successfully\n');
      }
    } catch (error) {
      console.error('Error cleaning up temporary files:', error);
      // Continue execution even if cleanup fails
    }
  }
  
  /**
   * Ensure file path is absolute
   * @param {string} filePath - File path (may be relative or absolute)
   * @param {string} basePath - Base path to prepend for relative paths
   * @returns {string} - Absolute file path
   */
  ensureAbsolutePath(filePath, basePath) {
    if (!filePath) return filePath;
    
    // Check if the path is already absolute
    if (path.isAbsolute(filePath)) {
      return filePath;
    }
    
    // Make the path absolute by joining with the base path
    return path.join(basePath, filePath);
  }
}

module.exports = DocxComments;

============================================================
FILE: drunk-claude.js
SIZE: 10938 bytes
LANGUAGE: JS
============================================================

// drunk-claude.js
const BaseTool = require('./base-tool');
const path = require('path');
const fileCache = require('./file-cache');
const appState = require('./state.js');
const fs = require('fs/promises');

/**
 * DrunkClaude Tool
 * Reads a manuscript.txt file and gives a brutally honest critique.
 */
class DrunkClaude extends BaseTool {
  /**
   * Constructor
   * @param {Object} GeminiAPIService - Claude API service
   * @param {Object} config - Tool configuration
   */
  constructor(GeminiAPIService, config = {}) {
    super('drunk_claude', config);
    this.GeminiAPIService = GeminiAPIService;
  }

  /**
   * Execute the tool
   * @param {Object} options - Tool options
   * @returns {Promise<Object>} - Execution result
   */
  async execute(options) {
    console.log('Executing Drunk Claude with options:', options);
    
    // Extract options
    let manuscriptFile = options.manuscript_file;
    const saveDir = options.save_dir || appState.CURRENT_PROJECT_PATH;
    
    if (!saveDir) {
      const errorMsg = 'Error: No save directory specified and no current project selected.\n' +
                      'Please select a project or specify a save directory.';
      this.emitOutput(errorMsg);
      throw new Error('No save directory available');
    }

    // Ensure file paths are absolute
    manuscriptFile = this.ensureAbsolutePath(manuscriptFile, saveDir);

    const outputFiles = [];
    
    try {
      // Read the input files
      this.emitOutput(`Reading files...\n`);

      // Read the manuscript file
      this.emitOutput(`Reading manuscript file: ${manuscriptFile}\n`);
      const manuscriptContent = await this.readInputFile(manuscriptFile);
        
      const prompt = this.createPrompt(manuscriptContent);

      // Count tokens in the prompt
      this.emitOutput(`Counting tokens in prompt...\n`);
      const promptTokens = await this.GeminiAPIService.countTokens(prompt);

      // Call the shared token budget calculator
      const tokenBudgets = this.GeminiAPIService.calculateTokenBudgets(promptTokens);

      // Handle logging based on the returned values
      this.emitOutput(`\nToken stats:\n`);
      this.emitOutput(`Max AI model context window: [${tokenBudgets.contextWindow}] tokens\n`);
      this.emitOutput(`Input prompt tokens: [${tokenBudgets.promptTokens}] ...\n`);
      this.emitOutput(`                     = outline.txt + manuscript.txt\n`);
      this.emitOutput(`                       + prompt instructions\n`);
      this.emitOutput(`Available tokens: [${tokenBudgets.availableTokens}]  = ${tokenBudgets.contextWindow} - ${tokenBudgets.promptTokens} = context_window - prompt\n`);
      this.emitOutput(`Desired output tokens: [${tokenBudgets.desiredOutputTokens}]\n`);
      this.emitOutput(`AI model thinking budget: [${tokenBudgets.thinkingBudget}] tokens\n`);
      this.emitOutput(`Max output tokens: [${tokenBudgets.maxTokens}] tokens\n`);

      // Check for special conditions
      if (tokenBudgets.capThinkingBudget) {
        this.emitOutput(`Warning: thinking budget is larger than 32K, set to 32K.\n`);
      }

      // Check if the prompt is too large
      if (tokenBudgets.isPromptTooLarge) {
        this.emitOutput(`Error: prompt is too large to have a ${tokenBudgets.configuredThinkingBudget} thinking budget!\n`);
        this.emitOutput(`Run aborted!\n`);
        throw new Error(`Prompt is too large for ${tokenBudgets.configuredThinkingBudget} thinking budget - run aborted`);
      }
      
      // Call Claude API with streaming
      this.emitOutput(`Sending request to Claude API (streaming)...\n`);
      
      // Add a message about waiting
      this.emitOutput(`****************************************************************************\n`);
      this.emitOutput(`*  Drunk Claude critique your manuscript...                                \n`);
      this.emitOutput(`*  This process typically takes several minutes.                           \n`);
      this.emitOutput(`*                                                                          \n`);
      this.emitOutput(`*  It's recommended to keep this window the sole 'focus'                   \n`);
      this.emitOutput(`*  and to avoid browsing online or running other apps, as these API        \n`);
      this.emitOutput(`*  network connections are often flakey, like delicate echoes of whispers. \n`);
      this.emitOutput(`*                                                                          \n`);
      this.emitOutput(`*  So breathe, remove eye glasses, stretch, relax, and be like water 🥋 🧘🏽‍♀️\n`);
      this.emitOutput(`****************************************************************************\n\n`);
      
      const startTime = Date.now();
      let fullResponse = "";
      let thinkingContent = "";
      
      // Create system prompt to avoid markdown
      const systemPrompt = "CRITICAL INSTRUCTION: NO Markdown formatting of ANY kind. Never use headers, bullets, or any formatting symbols. Plain text only with standard punctuation.";

      // Use the calculated values in the API call
      // console.log(`prompt:\n`, prompt);
      try {
        await this.GeminiAPIService.streamWithThinking(
          prompt,
          {
            system: systemPrompt,
            max_tokens: tokenBudgets.maxTokens,
            thinking: {
              type: "enabled",
              budget_tokens: tokenBudgets.thinkingBudget
            }
          },
          // Callback for thinking content
          (thinkingDelta) => {
            thinkingContent += thinkingDelta;
          },
          // Callback for response text
          (textDelta) => {
            fullResponse += textDelta;
          }
        );
      } catch (error) {
        this.emitOutput(`\nAPI Error: ${error.message}\n`);
        throw error;
      }

      const elapsed = (Date.now() - startTime) / 1000;
      const minutes = Math.floor(elapsed / 60);
      const seconds = elapsed % 60;
      
      this.emitOutput(`\nCompleted in ${minutes}m ${seconds.toFixed(2)}s.\n`);
      
      // Count words in response
      const wordCount = this.countWords(fullResponse);
      this.emitOutput(`Report has approximately ${wordCount} words.\n`);
      
      // Count tokens in response
      const responseTokens = await this.GeminiAPIService.countTokens(fullResponse);
      this.emitOutput(`Response token count: ${responseTokens}\n`);

      // Remove any markdown formatting
      fullResponse = this.removeMarkdown(fullResponse);

      // Save the report
      const outputFile = await this.saveReport(
        fullResponse,
        thinkingContent,
        promptTokens,
        responseTokens,
        saveDir
      );
      
      // Add the output files to the result
      outputFiles.push(...outputFile);
      
      // Add files to the cache
      const toolName = 'drunk_claude';
      outputFiles.forEach(file => {
        fileCache.addFile(toolName, file);
      });
      
      // Return the result
      return {
        success: true,
        outputFiles
      };
    } catch (error) {
      console.error('Error in DrunkClaude:', error);
      this.emitOutput(`\nError: ${error.message}\n`);
      throw error;
    }
  }
  
  /**
   * Create prompt
   * @param {string} manuscriptContent - Manuscript content
   * @returns {string} - Prompt for Claude API
   */
  createPrompt(manuscriptContent) {
    const noMarkdown = "IMPORTANT: - NO Markdown formatting";
    
    // Return just the text content, not a structured object
    return `=== MANUSCRIPT ===
${manuscriptContent}
=== END MANUSCRIPT ===

${noMarkdown}

Let's pretend you are a very drunk Claude at a local author/writer's pub, and 
you're working on your second bottle of really good wine. 
So you are very loose and very honest, more so than usual.

As a retired college professor of fiction writing you always were 
brutally honest about student manuscripts and book critiques.
Lay it on me, us writer's can handle it.

Use specific text examples from the manuscript to support your critique.`;
  }

  /**
   * Count words in text
   * @param {string} text - Text to count words in
   * @returns {number} - Word count
   */
  countWords(text) {
    return text.split(/\s+/).filter(word => word.length > 0).length;
  }
  
  /**
   * Ensure file path is absolute
   * @param {string} filePath - File path (may be relative or absolute)
   * @param {string} basePath - Base path to prepend for relative paths
   * @returns {string} - Absolute file path
   */
  ensureAbsolutePath(filePath, basePath) {
    if (!filePath) return filePath;
    
    // Check if the path is already absolute
    if (path.isAbsolute(filePath)) {
      return filePath;
    }
    
    // Make the path absolute by joining with the base path
    return path.join(basePath, filePath);
  }
  
  /**
   * Save report and thinking content to files
   * @param {string} content - Response content
   * @param {string} thinking - Thinking content
   * @param {number} promptTokens - Prompt token count
   * @param {number} responseTokens - Response token count
   * @param {string} saveDir - Directory to save to
   * @returns {Promise<string[]>} - Array of paths to saved files
   */
  async saveReport(
    content,
    thinking,
    promptTokens,
    responseTokens,
    saveDir
  ) {
    try {
      const formatter = new Intl.DateTimeFormat('en-US', {
        weekday: 'long',
        month: 'long',
        day: 'numeric',
        year: 'numeric',
        hour: 'numeric',
        minute: '2-digit',
        hour12: true
      });
      const dateTimeStr = formatter.format(new Date());

      // Create timestamp for filename
      const timestamp = new Date().toISOString().replace(/[-:.]/g, '').substring(0, 15);
      
      // Create descriptive filename
      const baseFilename = `drunk_claude_critique_${timestamp}`;
      
      // Array to collect all saved file paths
      const savedFilePaths = [];
      
      // Create stats for thinking file
      const stats = `
Details:  ${dateTimeStr}
Max request timeout: ${this.config.request_timeout} seconds
Max AI model context window: ${this.config.context_window} tokens
AI model thinking budget: ${this.config.thinking_budget_tokens} tokens
Desired output tokens: ${this.config.desired_output_tokens} tokens

Input tokens: ${promptTokens}
Output tokens: ${responseTokens}
`;
      
      // Save full response
      const reportFilename = `${baseFilename}.txt`;
      const reportPath = path.join(saveDir, reportFilename);
      await this.writeOutputFile(content, saveDir, reportFilename);
      savedFilePaths.push(reportPath);
      this.emitOutput(`Report saved to: ${reportPath}\n`);
      return savedFilePaths;
    } catch (error) {
      console.error(`Error saving report:`, error);
      this.emitOutput(`Error saving report: ${error.message}\n`);
      throw error;
    }
  }
}

module.exports = DrunkClaude;


============================================================
FILE: editor-dialog.js
SIZE: 5778 bytes
LANGUAGE: JS
============================================================

// DOM Elements
const editor = document.getElementById('editor');
const positionDisplay = document.getElementById('position');
const statsDisplay = document.getElementById('statistics');
const currentFileDisplay = document.getElementById('currentFile');
const saveAsButton = document.getElementById('btnSaveAs');
const fontSizeSelect = document.getElementById('fontSize');
const wordWrapSelect = document.getElementById('wordWrap');
const closeBtn = document.getElementById('close-btn');
const body = document.body;

// Track the current file
let currentFilePath = null;
let documentChanged = false;

// Initialize editor
function initEditor() {
  // Set up tab key behavior
  editor.addEventListener('keydown', function(e) {
    if (e.key === 'Tab') {
      e.preventDefault();
      
      // Insert a tab at cursor position
      const start = this.selectionStart;
      const end = this.selectionEnd;
      
      this.value = this.value.substring(0, start) + 
                    "  " + 
                    this.value.substring(end);
      
      // Put cursor after the inserted tab
      this.selectionStart = this.selectionEnd = start + 2;
      
      documentChanged = true;
    }
  });
  
  // Update the cursor position and stats display
  editor.addEventListener('keyup', updatePositionAndStats);
  editor.addEventListener('click', updatePositionAndStats);
  editor.addEventListener('input', () => {
    documentChanged = true;
    updatePositionAndStats();
  });
  
  // Initial update
  updatePositionAndStats();
  
  // Set up event listeners for UI controls
  setupEventListeners();
}

// Update the position and statistics displays
function updatePositionAndStats() {
  const text = editor.value;
  
  // Get cursor position
  const cursorPos = editor.selectionStart;
  
  // Calculate line and column
  const lines = text.substr(0, cursorPos).split('\n');
  const lineNumber = lines.length;
  const columnNumber = lines[lines.length - 1].length + 1;
  
  // Update displays with formatted numbers
  positionDisplay.textContent = `Line: ${lineNumber}, Column: ${columnNumber}`;
  statsDisplay.textContent = `Words: ${countWords(text).toLocaleString()} & Characters: ${text.length.toLocaleString()}`;
}

// Count words in text
function countWords(text) {
  return text.trim().split(/\s+/).filter(Boolean).length;
}

// Set up event listeners
function setupEventListeners() {
  // Close button handler
  closeBtn.addEventListener('click', closeDialog);
  
  // Save As button handler
  saveAsButton.addEventListener('click', saveFileAs);
  
  // Font size changes
  fontSizeSelect.addEventListener('change', function() {
    editor.style.fontSize = `${this.value}px`;
  });
  
  // Word wrap toggle
  wordWrapSelect.addEventListener('change', function() {
    const isWrapped = this.value === 'on';
    editor.style.whiteSpace = isWrapped ? 'pre-wrap' : 'pre';
  });
  
  // IPC events from main process
  if (window.electronAPI) {
    window.electronAPI.onFileOpened && window.electronAPI.onFileOpened(handleFileOpened);
  }
}

// Close the dialog
function closeDialog() {
  // Check for unsaved changes
  if (documentChanged) {
    if (!confirm('You have unsaved changes. Close anyway?')) {
      return; // User canceled, so don't close
    }
  }
  
  // Close the dialog
  if (window.electronAPI && window.electronAPI.closeEditorDialog) {
    window.electronAPI.closeEditorDialog();
  }
}

// Save As functionality
async function saveFileAs() {
  const content = editor.value;
  
  if (window.electronAPI && window.electronAPI.saveFile) {
    const result = await window.electronAPI.saveFile({
      filePath: currentFilePath,
      content,
      saveAs: true
    });
    
    if (result && result.success) {
      currentFilePath = result.filePath;
      currentFileDisplay.textContent = currentFilePath;
      documentChanged = false;
      // Show saved notification briefly
      showNotification('File saved successfully');
    }
  }
}

// Show a brief notification
function showNotification(message, duration = 2000) {
  // Create notification element if it doesn't exist
  let notification = document.getElementById('notification');
  
  if (!notification) {
    notification = document.createElement('div');
    notification.id = 'notification';
    notification.style.position = 'fixed';
    notification.style.bottom = '20px';
    notification.style.right = '20px';
    notification.style.padding = '10px 20px';
    notification.style.backgroundColor = '#4a89dc';
    notification.style.color = 'white';
    notification.style.borderRadius = '4px';
    notification.style.opacity = '0';
    notification.style.transition = 'opacity 0.3s';
    notification.style.zIndex = '1000';
    
    document.body.appendChild(notification);
  }
  
  // Set message and show
  notification.textContent = message;
  notification.style.opacity = '1';
  
  // Hide after duration
  setTimeout(() => {
    notification.style.opacity = '0';
  }, duration);
}

// Handle opened file data from main process
function handleFileOpened(data) {
  if (data && data.filePath && data.content !== undefined) {
    currentFilePath = data.filePath;
    editor.value = data.content;
    currentFileDisplay.textContent = currentFilePath;
    documentChanged = false;
    updatePositionAndStats();
  }
}

// Initialize the editor when the document is ready
document.addEventListener('DOMContentLoaded', initEditor);

// Apply theme if sent from main process
if (window.electronAPI && window.electronAPI.onSetTheme) {
  window.electronAPI.onSetTheme(theme => {
    if (theme === 'light') {
      body.classList.remove('dark-mode');
      body.classList.add('light-mode');
    } else {
      body.classList.remove('light-mode');
      body.classList.add('dark-mode');
    }
  });
}

============================================================
FILE: editor-main.js
SIZE: 6061 bytes
LANGUAGE: JS
============================================================

const { app, BrowserWindow, dialog, ipcMain, Menu, screen } = require('electron');
const path = require('path');
const fs = require('fs');
const os = require('os');

// Define the restricted directory
const WRITING_DIR = path.join(os.homedir(), 'writing');

// Ensure the writing directory exists
if (!fs.existsSync(WRITING_DIR)) {
  fs.mkdirSync(WRITING_DIR, { recursive: true });
}

let mainWindow;

function createWindow() {
  // Get the primary display's work area dimensions
  const primaryDisplay = screen.getPrimaryDisplay();
  const { width, height } = primaryDisplay.workAreaSize;
  console.log('*** Screen dimensions:', screen.getPrimaryDisplay().workAreaSize);  

  // Use 90% of the available width and height
  const windowWidth = Math.floor(width * 0.95);
  const windowHeight = Math.floor(height * 0.95);

  mainWindow = new BrowserWindow({
    width: windowWidth,
    height: windowHeight,
    webPreferences: {
      contextIsolation: true,
      nodeIntegration: false,
      preload: path.join(__dirname, 'editor-preload.js')
    },
    title: 'Writer\'s Toolkit - Editor',
    backgroundColor: '#121212', // Dark background for better appearance during load
    autoHideMenuBar: true // Hide the menu bar but keep shortcuts accessible
  });

  // Explicitly hide the menu bar
  mainWindow.setMenuBarVisibility(false);
  
  // Set null menu to completely remove it
  Menu.setApplicationMenu(null);

  // Center the window
  mainWindow.center();

  mainWindow.loadFile(path.join(__dirname, 'renderer', 'editor', 'index.html'));
  
  // Handle window closed
  mainWindow.on('closed', () => {
    mainWindow = null;
  });
}

// File opening function
async function openFile() {
  if (!mainWindow) return;

  const { canceled, filePaths } = await dialog.showOpenDialog(mainWindow, {
    title: 'Open File',
    defaultPath: WRITING_DIR,
    filters: [
      { name: 'Text Files', extensions: ['txt'] },
      { name: 'All Files', extensions: ['*'] }
    ],
    properties: ['openFile']
  });

  if (canceled || filePaths.length === 0) return;

  const filePath = filePaths[0];
  
  // Verify file is within the allowed directory
  if (!filePath.startsWith(WRITING_DIR)) {
    dialog.showErrorBox(
      'Access Denied',
      `Files can only be opened from the ${WRITING_DIR} directory.`
    );
    return;
  }

  try {
    const content = fs.readFileSync(filePath, 'utf8');
    mainWindow.webContents.send('file-opened', { filePath, content });
  } catch (error) {
    dialog.showErrorBox('Error', `Failed to open file: ${error.message}`);
  }
}

// File saving function
async function saveFile(event, { filePath, content, saveAs = false }) {
  let finalPath = filePath;

  // If no path or saveAs is true, show save dialog
  if (!finalPath || saveAs) {
    const { canceled, filePath: newPath } = await dialog.showSaveDialog(mainWindow, {
      title: 'Save File',
      defaultPath: WRITING_DIR,
      filters: [
        { name: 'Text Files', extensions: ['txt'] },
        { name: 'All Files', extensions: ['*'] }
      ]
    });

    if (canceled || !newPath) return { success: false };
    finalPath = newPath;
  }

  // Verify file is within the allowed directory
  if (!finalPath.startsWith(WRITING_DIR)) {
    dialog.showErrorBox(
      'Access Denied',
      `Files can only be saved to the ${WRITING_DIR} directory.`
    );
    return { success: false };
  }

  try {
    fs.writeFileSync(finalPath, content, 'utf8');
    return { success: true, filePath: finalPath };
  } catch (error) {
    dialog.showErrorBox('Error', `Failed to save file: ${error.message}`);
    return { success: false };
  }
}

// Handle IPC events
function setupIPC() {
  ipcMain.handle('save-file', saveFile);
  
  ipcMain.handle('open-file-dialog', async () => {
    return await openFile();
  });

  // Fix for the Quit button - make sure it's properly registered
  ipcMain.on('app-quit', () => {
    console.log('Quit requested from renderer process');
    app.quit();
  });
}

// App lifecycle events
app.whenReady().then(() => {
  createWindow();
  setupIPC();
  
  // Log all command line arguments for debugging
  console.log('Command line arguments:', process.argv);
  
  // Improved file argument detection for .txt files only
  let fileArg = null;
  for (const arg of process.argv) {
    // Clean up the argument to handle potential quotes or spaces
    const cleanArg = arg.replace(/^["']|["']$/g, '');
    
    console.log('Checking argument:', cleanArg);
    
    // Check if it's a .txt file that exists
    if (cleanArg.endsWith('.txt') && fs.existsSync(cleanArg)) {
      fileArg = cleanArg;
      console.log('Found valid .txt file:', fileArg);
      break;
    }
  }
  
  if (fileArg) {
    const filePath = path.resolve(fileArg);
    console.log('Resolved file path:', filePath);
    
    // Only open if in allowed directory
    if (filePath.startsWith(WRITING_DIR)) {
      try {
        console.log('Reading file contents from:', filePath);
        const content = fs.readFileSync(filePath, 'utf8');
        
        // Wait for window to be ready
        if (mainWindow.webContents.isLoading()) {
          console.log('Window still loading, waiting to send file content...');
          mainWindow.webContents.once('did-finish-load', () => {
            console.log('Window loaded, sending file content now');
            mainWindow.webContents.send('file-opened', { filePath, content });
          });
        } else {
          console.log('Window ready, sending file content immediately');
          mainWindow.webContents.send('file-opened', { filePath, content });
        }
      } catch (error) {
        console.error('Error reading file:', error);
      }
    } else {
      console.warn('File is outside the allowed directory:', filePath);
    }
  } else {
    console.log('No valid .txt file argument found');
  }
  
  app.on('activate', function () {
    if (BrowserWindow.getAllWindows().length === 0) createWindow();
  });
});

app.on('window-all-closed', function () {
  if (process.platform !== 'darwin') app.quit();
});

============================================================
FILE: editor-preload.js
SIZE: 1246 bytes
LANGUAGE: JS
============================================================

const { contextBridge, ipcRenderer } = require('electron');

// Check for standalone mode using the environment variable
const isStandaloneMode = process.env.EDITOR_STANDALONE_MODE === 'true';
console.log(`Editor running in ${isStandaloneMode ? 'STANDALONE' : 'INTEGRATED'} mode`);

// Expose protected methods that allow the renderer process to use
// the ipcRenderer without exposing the entire object
contextBridge.exposeInMainWorld(
  'api', {
    // Quit application
    quitApp: () => ipcRenderer.send('app-quit'),
    
    // Force quit (stronger method)
    forceQuit: () => ipcRenderer.send('force-quit'),
    
    // Mode indicator for the renderer
    isStandaloneMode: isStandaloneMode,
    
    // File operations
    saveFile: (data) => ipcRenderer.invoke('save-file', data),
    openFileDialog: () => ipcRenderer.invoke('open-file-dialog'),
    
    // Event listeners
    onFileNew: (callback) => ipcRenderer.on('file-new', () => callback()),
    onFileSaveRequest: (callback) => ipcRenderer.on('file-save-request', () => callback()),
    onFileSaveAsRequest: (callback) => ipcRenderer.on('file-save-as-request', () => callback()),
    onFileOpened: (callback) => ipcRenderer.on('file-opened', (_, data) => callback(data))
  }
);


============================================================
FILE: epub-converter.js
SIZE: 8869 bytes
LANGUAGE: JS
============================================================

// epub-converter.js
const BaseTool = require('./base-tool');
const path = require('path');
const fs = require('fs');
const fsPromises = require('fs/promises');
const fileCache = require('./file-cache');
const appState = require('./state.js');
const JSZip = require('jszip');
const { DOMParser } = require('xmldom');
const xpath = require('xpath');

/**
 * EpubConverter Tool
 * Converts EPUB files to plain text
 */
class EpubConverter extends BaseTool {
  /**
   * Constructor
   * @param {string} name - Tool name
   * @param {Object} config - Tool configuration
   */
  constructor(name, config = {}) {
    super(name, config);
  }

  /**
   * Execute the tool
   * @param {Object} options - Tool options
   * @returns {Promise<Object>} - Execution result
   */
  async execute(options) {
    console.log('Executing EPUB Converter with options:', options);
    
    // Extract options
    let epubFile = options.epub_file;
    const saveDir = appState.CURRENT_PROJECT_PATH;
    
    if (!saveDir) {
      const errorMsg = 'Error: No project selected. Please select a project first.';
      this.emitOutput(errorMsg);
      throw new Error('No project selected');
    }

    // Ensure file paths are absolute
    epubFile = this.ensureAbsolutePath(epubFile, saveDir);

    const outputFiles = [];
    
    try {
      // Read the input file
      this.emitOutput(`Reading EPUB file: ${epubFile}\n`);
      
      // Check if file exists
      if (!fs.existsSync(epubFile)) {
        throw new Error(`File not found: ${epubFile}`);
      }
      
      this.emitOutput(`Converting EPUB to text...\n`);
      
      // Read EPUB file as buffer
      const fileData = await fsPromises.readFile(epubFile);
      
      // Process the EPUB file
      const result = await this.processEpub(fileData);
      
      if (result.chapters.length === 0) {
        this.emitOutput(`No chapters found in EPUB file\n`);
      } else {
        this.emitOutput(`Extracted ${result.chapters.length} chapters\n`);
      }
      
      // Generate text content
      let allText = '';
      result.chapters.forEach((ch) => {
        if (ch.title) {
          allText += ch.title + '\n\n';
        }
        allText += ch.textBlocks.join('\n\n') + '\n\n';
      });
      
      // Create output filename with timestamp
      const timestamp = new Date().toISOString().replace(/[-:.]/g, '').substring(0, 15);
      const baseFileName = path.basename(epubFile, '.epub');
      const outputFilename = `${baseFileName}_${timestamp}.txt`;
      
      // Write the output file
      const outputPath = await this.writeOutputFile(allText, saveDir, outputFilename);
      
      this.emitOutput(`\nConverted EPUB saved to: ${outputPath}\n`);
      outputFiles.push(outputPath);
      
      // Add to the file cache
      const toolName = 'epub_converter';
      fileCache.addFile(toolName, outputPath);
      
      // Return the result
      return {
        success: true,
        outputFiles,
        stats: {
          chapterCount: result.chapters.length,
          wordCount: this.countWords(allText)
        }
      };
    } catch (error) {
      console.error('Error in EPUB Converter:', error);
      this.emitOutput(`\nError: ${error.message}\n`);
      throw error;
    }
  }
  
  /**
   * Process an EPUB file
   * @param {Buffer} fileData - EPUB file data
   * @returns {Promise<Object>} - Processing result
   */
  async processEpub(fileData) {
    try {
      const zip = await JSZip.loadAsync(fileData);
      
      // 1. locate the OPF file via META-INF/container.xml
      const containerFile = zip.file("META-INF/container.xml");
      if (!containerFile) throw new Error("META-INF/container.xml not found.");
      
      const containerXml = await containerFile.async("text");
      const containerDoc = new DOMParser().parseFromString(containerXml, "application/xml");
      
      // Set up namespaces for XPath if needed
      const select = xpath.useNamespaces({
        'ns': 'urn:oasis:names:tc:opendocument:xmlns:container',
        'opf': 'http://www.idpf.org/2007/opf'
      });
      
      const rootfileElement = containerDoc.getElementsByTagName("rootfile")[0];
      if (!rootfileElement) throw new Error("OPF file reference not found.");
      
      const opfPath = rootfileElement.getAttribute("full-path");
      if (!opfPath) throw new Error("OPF file path is missing.");
      
      // Get the base path (e.g. if opfPath is "OEBPS/content.opf", base = "OEBPS/")
      const basePath = opfPath.includes("/") ? opfPath.substring(0, opfPath.lastIndexOf("/") + 1) : "";

      // 2. read the OPF file
      const opfFile = zip.file(opfPath);
      if (!opfFile) throw new Error("OPF file not found: " + opfPath);
      
      const opfXml = await opfFile.async("text");
      const opfDoc = new DOMParser().parseFromString(opfXml, "application/xml");

      // 3. build a manifest (id → href)
      const manifest = {};
      const items = opfDoc.getElementsByTagName("item");
      for (let i = 0; i < items.length; i++) {
        const item = items[i];
        const id = item.getAttribute("id");
        const href = item.getAttribute("href");
        if (id && href) {
          manifest[id] = href;
        }
      }

      // 4. get the spine (reading order)
      const spineItems = [];
      const itemrefs = opfDoc.getElementsByTagName("itemref");
      for (let i = 0; i < itemrefs.length; i++) {
        const itemref = itemrefs[i];
        const idref = itemref.getAttribute("idref");
        if (idref && manifest[idref]) {
          spineItems.push(manifest[idref]);
        }
      }

      // 5. process each chapter file from the spine
      const chapters = [];
      
      // Define a list of unwanted titles
      const unwantedTitles = ["TITLE PAGE", "COPYRIGHT"];

      for (const itemHref of spineItems) {
        const chapterPath = basePath + itemHref;
        const chapterFile = zip.file(chapterPath);
        
        if (!chapterFile) {
          this.emitOutput(`Chapter file not found: ${chapterPath}\n`);
          continue;
        }
        
        const chapterContent = await chapterFile.async("text");
        
        // Parse the chapter content into a DOM
        const doc = new DOMParser().parseFromString(chapterContent, "text/html");
        
        // Extract and store the title from the first <h1>
        let title = "";
        const h1Elements = doc.getElementsByTagName("h1");
        if (h1Elements.length > 0) {
          title = h1Elements[0].textContent.trim();
          
          // Filter out unwanted titles
          if (unwantedTitles.includes(title.toUpperCase())) {
            this.emitOutput(`Skipping non-chapter content: ${title}\n`);
            continue;
          }
        }
        
        // Extract the body text
        let bodyText = "";
        const bodyElements = doc.getElementsByTagName("body");
        if (bodyElements.length > 0) {
          bodyText = bodyElements[0].textContent.trim();
        }
        
        // Split into paragraphs
        const textBlocks = bodyText.split(/\n\s*\n/).filter(block => block.trim() !== "");
        
        // Special handling for CONTENTS page
        if (title.toUpperCase() === "CONTENTS") {
          for (let i = 0; i < textBlocks.length; i++) {
            // If a line is non-empty and does not start with whitespace, add an indent
            if (textBlocks[i].trim() && !/^\s/.test(textBlocks[i])) {
              textBlocks[i] = "        " + textBlocks[i];
            }
          }
        }
        
        // If no title and content is too short, skip this chapter
        if (!title && textBlocks.join("").length < 100) {
          this.emitOutput(`Skipping empty or minimal chapter\n`);
          continue;
        }
        
        chapters.push({
          title: title,
          textBlocks: textBlocks
        });
      }

      return {
        chapters: chapters,
        success: true
      };
    } catch (error) {
      console.error('Error processing EPUB:', error);
      throw error;
    }
  }

  /**
   * Count words in text
   * @param {string} text - Text to count words in
   * @returns {number} - Word count
   */
  countWords(text) {
    return text.split(/\s+/).filter(word => word.length > 0).length;
  }
  
  /**
   * Ensure file path is absolute
   * @param {string} filePath - File path (may be relative or absolute)
   * @param {string} basePath - Base path to prepend for relative paths
   * @returns {string} - Absolute file path
   */
  ensureAbsolutePath(filePath, basePath) {
    if (!filePath) return filePath;
    
    // Check if the path is already absolute
    if (path.isAbsolute(filePath)) {
      return filePath;
    }
    
    // Make the path absolute by joining with the base path
    return path.join(basePath, filePath);
  }
}

module.exports = EpubConverter;

============================================================
FILE: file-cache.js
SIZE: 1794 bytes
LANGUAGE: JS
============================================================

// cache/file-cache.js
/**
 * Simple file cache for tracking output files created by tools
 * This is a singleton that can be imported by both tools and the main app
 */

// Simple in-memory cache object
const fileCache = {
  // Store the most recent files for each tool
  _latestFiles: new Map(),
  
  /**
   * Clear the cache for a specific tool
   * @param {string} toolName - Tool name/ID
   */
  clear(toolName) {
    this._latestFiles.set(toolName, []);
    console.log(`Cache cleared for tool: ${toolName}`);
  },
  
  /**
   * Add a file to the cache for a specific tool
   * @param {string} toolName - Tool name/ID
   * @param {string} filePath - Path to the created file
   */
  addFile(toolName, filePath) {
    // Initialize if needed
    if (!this._latestFiles.has(toolName)) {
      this._latestFiles.set(toolName, []);
    }
    
    // Add the file
    this._latestFiles.get(toolName).push(filePath);
    console.log(`Added file to cache for ${toolName}: ${filePath}`);
  },
  
  /**
   * Get the most recent files for a specific tool
   * @param {string} toolName - Tool name/ID
   * @returns {Array} - Array of file objects with path and name properties
   */
  getFiles(toolName) {
    const files = this._latestFiles.get(toolName) || [];
    
    // Map full paths to objects with path and filename for UI display
    return files.map(filePath => {
      const path = require('path');
      return {
        path: filePath,
        name: path.basename(filePath)
      };
    });
  },
  
  /**
   * Get all tool names that have files in the cache
   * @returns {string[]} - Array of tool names
   */
  getToolsWithFiles() {
    return Array.from(this._latestFiles.keys()).filter(
      tool => this._latestFiles.get(tool).length > 0
    );
  }
};

module.exports = fileCache;

============================================================
FILE: file-utils.js
SIZE: 782 bytes
LANGUAGE: JS
============================================================

const fs = require('fs/promises');
const path = require('path');

async function readFile(filePath, encoding = 'utf-8') {
  try {
    const content = await fs.readFile(filePath, encoding);
    if (!content.trim()) {
      throw new Error(`File is empty: ${filePath}`);
    }
    return content;
  } catch (error) {
    if (error.code === 'ENOENT') {
      throw new Error(`File not found: ${filePath}`);
    }
    throw error;
  }
}

async function writeFile(filePath, content, encoding = 'utf-8') {
  try {
    // Ensure directory exists
    await fs.mkdir(path.dirname(filePath), { recursive: true });
    await fs.writeFile(filePath, content, encoding);
    return path.resolve(filePath);
  } catch (error) {
    throw error;
  }
}

module.exports = {
  readFile,
  writeFile
};


============================================================
FILE: foreshadowing-tracker.js
SIZE: 20670 bytes
LANGUAGE: JS
============================================================

// foreshadowing-tracker.js
const BaseTool = require('./base-tool');
const path = require('path');
const fileCache = require('./file-cache');
const appState = require('./state.js');
const fs = require('fs/promises');

/**
 * ForeshadowingTracker Tool
 * Analyzes manuscript for foreshadowing elements, planted clues, and their payoffs using the Claude API.
 * Tracks setup and resolution of story elements, ensuring narrative promises are fulfilled.
 */
class ForeshadowingTracker extends BaseTool {
  /**
   * Constructor
   * @param {Object} GeminiAPIService - Claude API service
   * @param {Object} config - Tool configuration
   */
  constructor(GeminiAPIService, config = {}) {
    super('foreshadowing_tracker', config);
    this.GeminiAPIService = GeminiAPIService;
  }

  /**
   * Execute the tool
   * @param {Object} options - Tool options
   * @returns {Promise<Object>} - Execution result
   */
  async execute(options) {
    console.log('Executing Foreshadowing Tracker with options:', options);
    
    // Extract options
    let manuscriptFile = options.manuscript_file;
    let outlineFile = options.outline_file;
    const foreshadowingType = options.foreshadowing_type;
    const chronological = options.chronological;
    const saveDir = options.save_dir || appState.CURRENT_PROJECT_PATH;
    
    if (!saveDir) {
      const errorMsg = 'Error: No save directory specified and no current project selected.\n' +
                      'Please select a project or specify a save directory.';
      this.emitOutput(errorMsg);
      throw new Error('No save directory available');
    }

    // Ensure file paths are absolute
    manuscriptFile = this.ensureAbsolutePath(manuscriptFile, saveDir);
    if (outlineFile) {
      outlineFile = this.ensureAbsolutePath(outlineFile, saveDir);
    }
    
    // Log the full paths for debugging
    console.log('Using full paths:');
    console.log(`Manuscript: ${manuscriptFile}`);
    if (outlineFile) {
      console.log(`Outline: ${outlineFile}`);
    }

    const outputFiles = [];
    
    try {
      // Read the input files
      this.emitOutput(`Reading files...\n`);

      // Read the manuscript file
      this.emitOutput(`Reading manuscript file: ${manuscriptFile}\n`);
      const manuscriptContent = await this.readInputFile(manuscriptFile);
      
      // Read the outline file if provided
      let outlineContent = '';
      if (outlineFile) {
        this.emitOutput(`Reading outline file: ${outlineFile}\n`);
        outlineContent = await this.readInputFile(outlineFile);
      }
      
      // If foreshadowingType is 'all', run all types
      if (foreshadowingType === 'all') {
        const types = ['explicit', 'implicit', 'chekhov'];
        for (const type of types) {
          const result = await this.runAnalysis(
            type,
            outlineContent,
            manuscriptContent,
            chronological,
            saveDir
          );
          outputFiles.push(...result.outputFiles);
        }
      } else {
        // Run a single analysis type
        const result = await this.runAnalysis(
          foreshadowingType,
          outlineContent,
          manuscriptContent,
          chronological,
          saveDir
        );
        outputFiles.push(...result.outputFiles);
      }
      
      // Add files to the cache
      const toolName = 'foreshadowing_tracker';
      outputFiles.forEach(file => {
        fileCache.addFile(toolName, file);
      });
      
      // Return the result
      return {
        success: true,
        outputFiles
      };
    } catch (error) {
      console.error('Error in ForeshadowingTracker:', error);
      this.emitOutput(`\nError: ${error.message}\n`);
      throw error;
    }
  }

  /**
   * Run a single foreshadowing analysis
   * @param {string} foreshadowingType - Type of foreshadowing to analyze
   * @param {string} outlineContent - Outline content
   * @param {string} manuscriptContent - Manuscript content
   * @param {boolean} chronological - Whether to organize chronologically
   * @param {string} saveDir - Directory to save to
   * @returns {Promise<Object>} - Analysis result
   */
  async runAnalysis(
    foreshadowingType,
    outlineContent,
    manuscriptContent,
    chronological,
    saveDir
  ) {
    this.emitOutput(`\n=== Running ${foreshadowingType.toUpperCase()} Foreshadowing Analysis ===\n`);
    
    // Create the prompt
    const prompt = this.createForeshadowingPrompt(
      foreshadowingType,
      outlineContent,
      manuscriptContent,
      chronological
    );

    // Count tokens in the prompt
    this.emitOutput(`Counting tokens in prompt...\n`);
    const promptTokens = await this.GeminiAPIService.countTokens(prompt);

    // Call the shared token budget calculator
    const tokenBudgets = this.GeminiAPIService.calculateTokenBudgets(promptTokens);

    // Handle logging based on the returned values
    this.emitOutput(`\nToken stats:\n`);
    this.emitOutput(`Max AI model context window: [${tokenBudgets.contextWindow}] tokens\n`);
    this.emitOutput(`Input prompt tokens: [${tokenBudgets.promptTokens}] ...\n`);
    this.emitOutput(`                     = outline + manuscript + prompt instructions\n`);
    this.emitOutput(`Available tokens: [${tokenBudgets.availableTokens}]  = ${tokenBudgets.contextWindow} - ${tokenBudgets.promptTokens} = context_window - prompt\n`);
    this.emitOutput(`Desired output tokens: [${tokenBudgets.desiredOutputTokens}]\n`);
    this.emitOutput(`AI model thinking budget: [${tokenBudgets.thinkingBudget}] tokens\n`);
    this.emitOutput(`Max output tokens: [${tokenBudgets.maxTokens}] tokens\n`);

    // Check for special conditions
    if (tokenBudgets.capThinkingBudget) {
      this.emitOutput(`Warning: thinking budget is larger than 32K, set to 32K.\n`);
    }

    // Check if the prompt is too large
    if (tokenBudgets.isPromptTooLarge) {
      this.emitOutput(`Error: prompt is too large to have a ${tokenBudgets.configuredThinkingBudget} thinking budget!\n`);
      this.emitOutput(`Run aborted!\n`);
      throw new Error(`Prompt is too large for ${tokenBudgets.configuredThinkingBudget} thinking budget - run aborted`);
    }
    
    // Call Claude API with streaming
    this.emitOutput(`>>> Sending request to Claude API (streaming)...\n`);

    // Add a message about waiting
    this.emitOutput(`****************************************************************************\n`);
    this.emitOutput(`*  Analyzing foreshadowing elements in your manuscript...                  \n`);
    this.emitOutput(`*  This process typically takes several minutes.                           \n`);
    this.emitOutput(`*                                                                          \n`);
    this.emitOutput(`*  It's recommended to keep this window the sole 'focus'                   \n`);
    this.emitOutput(`*  and to avoid browsing online or running other apps, as these API        \n`);
    this.emitOutput(`*  network connections are often flakey, like delicate echoes of whispers. \n`);
    this.emitOutput(`*                                                                          \n`);
    this.emitOutput(`*  So breathe, remove eye glasses, stretch, relax, and be like water 🥋 🧘🏽‍♀️\n`);
    this.emitOutput(`****************************************************************************\n\n`);
    
    const startTime = Date.now();
    let fullResponse = "";
    let thinkingContent = "";
    
    // Create system prompt to avoid markdown
    const systemPrompt = "CRITICAL INSTRUCTION: NO Markdown formatting of ANY kind. Never use headers, bullets, or any formatting symbols. Plain text only with standard punctuation.";

    // Use the calculated values in the API call
    try {
      await this.GeminiAPIService.streamWithThinking(
        prompt,
        {
          system: systemPrompt,
          max_tokens: tokenBudgets.maxTokens,
          thinking: {
            type: "enabled",
            budget_tokens: tokenBudgets.thinkingBudget
          }
        },
        // Callback for thinking content
        (thinkingDelta) => {
          thinkingContent += thinkingDelta;
        },
        // Callback for response text
        (textDelta) => {
          fullResponse += textDelta;
        }
      );
    } catch (error) {
      this.emitOutput(`\nAPI Error: ${error.message}\n`);
      throw error;
    }

    const elapsed = (Date.now() - startTime) / 1000;
    const minutes = Math.floor(elapsed / 60);
    const seconds = elapsed % 60;
    
    this.emitOutput(`\nCompleted in ${minutes}m ${seconds.toFixed(2)}s.\n`);
    
    // Count words in response
    const wordCount = this.countWords(fullResponse);
    this.emitOutput(`Report has approximately ${wordCount} words.\n`);
    
    // Count tokens in response
    const responseTokens = await this.GeminiAPIService.countTokens(fullResponse);
    this.emitOutput(`Response token count: ${responseTokens}\n`);

    // Remove any markdown formatting
    fullResponse = this.removeMarkdown(fullResponse);

    // Save the report
    const outputFile = await this.saveReport(
      foreshadowingType,
      fullResponse,
      thinkingContent,
      promptTokens,
      responseTokens,
      saveDir,
      chronological
    );
    
    return {
      success: true,
      outputFiles: outputFile,
      stats: {
        wordCount,
        tokenCount: responseTokens,
        elapsedTime: `${minutes}m ${seconds.toFixed(2)}s`,
        foreshadowingType,
        chronological
      }
    };
  }

  /**
   * Create foreshadowing analysis prompt
   * @param {string} foreshadowingType - Type of foreshadowing to analyze
   * @param {string} outlineContent - Outline content
   * @param {string} manuscriptContent - Manuscript content
   * @param {boolean} chronological - Whether to organize chronologically
   * @returns {string} - Prompt for Claude API
   */
  createForeshadowingPrompt(foreshadowingType, outlineContent, manuscriptContent, chronological = false) {
    const noMarkdown = "IMPORTANT: - NO Markdown formatting";
      
    const orgInstruction = chronological 
      ? "Organize your analysis chronologically, following the manuscript's progression."
      : "Organize your analysis by foreshadowing type, grouping similar elements together.";
    
    const prompts = {
      "explicit": `=== OUTLINE ===
${outlineContent}
=== END OUTLINE ===

=== MANUSCRIPT ===
${manuscriptContent}
=== END MANUSCRIPT ===

${noMarkdown}

You are an expert fiction editor specializing in narrative structure and foreshadowing. Analyze the manuscript to identify EXPLICIT foreshadowing elements - direct hints, statements, or events that point to future developments.

Focus on identifying:

1. DIRECT FORESHADOWING:
   - Clear statements or hints that explicitly point to future events
   - Prophecies, predictions, or warnings made by characters
   - Narrative statements that directly hint at what's to come
   - Character statements that foreshadow future developments

2. SETUP AND PAYOFF TRACKING:
   - For each foreshadowing element, locate where it is set up (the hint/clue)
   - Identify where/if each setup is paid off later in the manuscript
   - Note any explicit foreshadowing that remains unresolved
   - Analyze the effectiveness of the setup-payoff connections

3. TIMING AND DISTANCE ASSESSMENT:
   - Evaluate the distance between setup and payoff (immediate, mid-range, long-range)
   - Assess if the timing between setup and payoff is appropriate
   - Note if foreshadowed events occur too quickly or are delayed too long

4. NARRATIVE IMPACT:
   - Analyze how the foreshadowing enhances tension and anticipation
   - Assess if the foreshadowing is too obvious or too subtle
   - Evaluate if the payoff satisfies the expectations created by the setup

${orgInstruction}

For each foreshadowing element, provide:
- The exact text and location where the foreshadowing occurs
- The exact text and location where the payoff occurs (if present)
- An assessment of the effectiveness of the setup-payoff connection
- Recommendations for improvement where relevant

For unresolved foreshadowing, note:
- The setup that lacks a payoff
- Where a payoff could naturally occur
- Specific suggestions for resolving the planted clue

Use the extensive thinking space to thoroughly catalog and cross-reference all foreshadowing elements before finalizing your analysis.`,

      "implicit": `=== OUTLINE ===
${outlineContent}
=== END OUTLINE ===

=== MANUSCRIPT ===
${manuscriptContent}
=== END MANUSCRIPT ===

${noMarkdown}

You are an expert fiction editor specializing in narrative structure and foreshadowing. Analyze the manuscript to identify IMPLICIT foreshadowing elements - subtle clues, symbolic imagery, and thematic elements that hint at future developments.

Focus on identifying:

1. SYMBOLIC FORESHADOWING:
   - Recurring symbols, motifs, or imagery that hint at future events
   - Visual descriptions that subtly indicate coming developments
   - Metaphors or similes that suggest future outcomes
   - Environmental details (weather, setting) that subtly presage events

2. DIALOGUE FORESHADOWING:
   - Casual remarks by characters that gain significance later
   - Seemingly unimportant information revealed in dialogue
   - Character observations that subtly hint at future revelations
   - Patterns in dialogue that create expectations

3. BACKGROUND DETAILS:
   - Seemingly minor world-building elements that become important
   - Casual mentions of places, objects, or people that later become significant
   - Incidental actions or habits that foreshadow character choices

4. PATTERN RECOGNITION:
   - Track recurring themes or ideas that create expectations
   - Identify narrative patterns that implicitly suggest outcomes
   - Note subtle character behaviors that foreshadow major decisions

${orgInstruction}

For each implicit foreshadowing element, provide:
- The exact text and location where the subtle clue appears
- The exact text and location of the corresponding payoff (if present)
- An analysis of how the subtle connection works (or doesn't)
- Recommendations for strengthening subtle connections where relevant

For potential missed opportunities, identify:
- Events that would benefit from earlier foreshadowing
- Suggestions for subtle clues that could be planted earlier
- Ways to enhance thematic coherence through implicit connections

Use the extensive thinking space to thoroughly catalog and cross-reference all implicit elements before finalizing your analysis.`,

      "chekhov": `=== OUTLINE ===
${outlineContent}
=== END OUTLINE ===

=== MANUSCRIPT ===
${manuscriptContent}
=== END MANUSCRIPT ===

${noMarkdown}

You are an expert fiction editor specializing in narrative structure and "Chekhov's Gun" analysis - the principle that significant elements introduced in a story must be used in a meaningful way. Analyze the manuscript to identify introduced elements that create expectations for later use.

Focus on identifying:

1. INTRODUCED BUT UNUSED ELEMENTS:
   - Significant objects that are prominently described but not used
   - Special abilities, skills, or knowledge mentioned but never employed
   - Locations described in detail but not utilized in the plot
   - Character traits or backgrounds emphasized but not made relevant

2. PROPERLY UTILIZED ELEMENTS:
   - Significant objects, places, or abilities that are introduced and later used
   - The setup of these elements and their subsequent payoff
   - How effectively the payoff fulfills the expectation created by the setup

3. SETUP-PAYOFF EVALUATION:
   - Whether the payoff is proportional to the emphasis placed on the setup
   - If the payoff occurs at an appropriate time after the setup
   - Whether the use of the element is satisfying given how it was introduced

4. NARRATIVE PROMISE ASSESSMENT:
   - Identify what narrative promises are made to readers through introduced elements
   - Evaluate whether these promises are fulfilled
   - Assess the impact of unfulfilled narrative promises on reader satisfaction

${orgInstruction}

For each Chekhov's Gun element, provide:
- The exact text and location where the element is introduced
- The exact text and location where the element is used (if it is)
- An assessment of the effectiveness of the setup-payoff
- Specific recommendations for elements that need resolution

For unfired Chekhov's Guns, suggest:
- How the introduced element could be meaningfully incorporated
- Where in the narrative the payoff could naturally occur
- How to revise the introduction if the element won't be used

Use the extensive thinking space to thoroughly catalog all introduced significant elements and their resolution status before finalizing your analysis.`
    };
    
    return prompts[foreshadowingType] || "";
  }

  /**
   * Save report and thinking content to files
   * @param {string} foreshadowingType - Type of foreshadowing analyzed
   * @param {string} content - Response content
   * @param {string} thinking - Thinking content
   * @param {number} promptTokens - Prompt token count
   * @param {number} responseTokens - Response token count
   * @param {string} saveDir - Directory to save to
   * @param {boolean} chronological - Whether organized chronologically
   * @returns {Promise<string[]>} - Array of paths to saved files
   */
  async saveReport(
    foreshadowingType,
    content,
    thinking,
    promptTokens,
    responseTokens,
    saveDir,
    chronological
  ) {
    try {
      const formatter = new Intl.DateTimeFormat('en-US', {
        weekday: 'long',
        month: 'long',
        day: 'numeric',
        year: 'numeric',
        hour: 'numeric',
        minute: '2-digit',
        hour12: true
      });
      const dateTimeStr = formatter.format(new Date());

      // Create timestamp for filename
      const timestamp = new Date().toISOString().replace(/[-:.]/g, '').substring(0, 15);
      
      // Create descriptive filename
      const baseFilename = `foreshadowing_analysis_${foreshadowingType}_${timestamp}`;
      
      // Array to collect all saved file paths
      const savedFilePaths = [];
      
      // Create stats for thinking file
      const stats = `
Details:  ${dateTimeStr}
Analysis type: Foreshadowing ${foreshadowingType} analysis
Organization: ${chronological ? 'Chronological' : 'By foreshadowing type'}
Max request timeout: ${this.config.request_timeout} seconds
Max AI model context window: ${this.config.context_window} tokens
AI model thinking budget: ${this.config.thinking_budget_tokens} tokens
Desired output tokens: ${this.config.desired_output_tokens} tokens

Input tokens: ${promptTokens}
Output tokens: ${responseTokens}
`;
      
      // Save full response
      const reportFilename = `${baseFilename}.txt`;
      const reportPath = path.join(saveDir, reportFilename);
      await this.writeOutputFile(content, saveDir, reportFilename);
      savedFilePaths.push(reportPath);
      
      // Save thinking content if available and not skipped
      if (thinking) {
        const thinkingFilename = `${baseFilename}_thinking.txt`;
        const thinkingPath = path.join(saveDir, thinkingFilename);
        const thinkingContent = `=== FORESHADOWING ANALYSIS TYPE ===
${foreshadowingType}

=== AI'S THINKING PROCESS ===

${thinking}

=== END AI'S THINKING PROCESS ===
${stats}`;
        
        await this.writeOutputFile(thinkingContent, saveDir, thinkingFilename);
        this.emitOutput(`AI thinking saved to: ${thinkingPath}\n`);
        savedFilePaths.push(thinkingPath);
      }

      this.emitOutput(`Report saved to: ${reportPath}\n`);
      return savedFilePaths;
    } catch (error) {
      console.error(`Error saving report:`, error);
      this.emitOutput(`Error saving report: ${error.message}\n`);
      throw error;
    }
  }

  /**
   * Count words in text
   * @param {string} text - Text to count words in
   * @returns {number} - Word count
   */
  countWords(text) {
    return text.split(/\s+/).filter(word => word.length > 0).length;
  }

  /**
   * Ensure file path is absolute
   * @param {string} filePath - File path (may be relative or absolute)
   * @param {string} basePath - Base path to prepend for relative paths
   * @returns {string} - Absolute file path
   */
  ensureAbsolutePath(filePath, basePath) {
    if (!filePath) return filePath;
    
    // Check if the path is already absolute
    if (path.isAbsolute(filePath)) {
      return filePath;
    }
    
    // Make the path absolute by joining with the base path
    return path.join(basePath, filePath);
  }
}

module.exports = ForeshadowingTracker;


============================================================
FILE: forge.config.js
SIZE: 1486 bytes
LANGUAGE: JS
============================================================

const { FusesPlugin } = require('@electron-forge/plugin-fuses');
const { FuseV1Options, FuseVersion } = require('@electron/fuses');

module.exports = {
  packagerConfig: {
    asar: false,
    name: 'WritersToolkit',
    executableName: 'writers-toolkit',
    icon: './resources/icon',
    osxSign: false, // Explicitly disable signing
    osxNotarize: false, // Explicitly disable notarization
  },
  rebuildConfig: {},
  makers: [
    {
      name: '@electron-forge/maker-zip',
      platforms: ['darwin', 'win32'],
    },
    {
      name: '@electron-forge/maker-dmg',
      icon: './resources/WritersToolkit.icns',
      background: './resources/dmg-background.png',
      platforms: ['darwin'],
    },
    {
      name: '@electron-forge/maker-squirrel',
      config: {
        name: 'WritersToolkit',
        authors: 'Chris Smith',
        description: "A toolkit for writers with AI assistance and a text editor",
        setupIcon: './resources/icons/win/icon.ico',
        // Add these properties for proper Start menu integration
        shortcutName: "Writer's Toolkit",
        // Optional but recommended product name for Start menu folder
        productName: "Writer's Toolkit",
        // Create Start menu shortcut
        loadingGif: undefined,
        // Add registry keys for better Windows integration
        noMsi: false,
        // Tell Squirrel to create a desktop shortcut
        createDesktopShortcut: true
      },
      platforms: ['win32'],
    }
  ]
};


============================================================
FILE: gemini-file-manager.js
SIZE: 7327 bytes
LANGUAGE: JS
============================================================

const { GoogleGenAI } = require('@google/genai');
const readline = require('readline');

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});

// Helper function to ask a question and return a promise
function askQuestion(query) {
  return new Promise(resolve => rl.question(query, resolve));
}

// Global AI client
let ai;

async function initializeClient() {
  const apiKeyFromEnv = process.env.GEMINI_API_KEY;
  if (!apiKeyFromEnv) {
    console.error("ERROR: GEMINI_API_KEY environment variable is not set.");
    process.exit(1);
  }
  ai = new GoogleGenAI({ apiKey: apiKeyFromEnv });
  console.log("Gemini AI Client Initialized.");
}

async function listFiles() {
  if (!ai || !ai.files || typeof ai.files.list !== 'function') {
    console.error("ERROR: AI client or ai.files.list is not available.");
    return []; // Return empty array on error
  }
  console.log("\n--- Listing all project files ---");
  try {
    const listParams = {}; // Default parameters
    const listResponsePager = await ai.files.list(listParams);

    const files = [];
    let filesFound = false;
    for await (const file of listResponsePager) {
      filesFound = true;
      console.log(`  - Name (ID): ${file.name}`);
      console.log(`    Display Name: ${file.displayName || 'N/A'}`);
      console.log(`    URI: ${file.uri}`);
      console.log(`    Size: ${file.sizeBytes || 'N/A'} bytes`);
      console.log(`    MIME Type: ${file.mimeType}`);
      console.log(`    State: ${file.state || 'N/A'}`); // Added state if available
      console.log(`    Create Time: ${file.createTime ? new Date(file.createTime).toLocaleString() : 'N/A'}`);
      console.log(`    Update Time: ${file.updateTime ? new Date(file.updateTime).toLocaleString() : 'N/A'}`);
      console.log(`    Expiration Time: ${file.expirationTime ? new Date(file.expirationTime).toLocaleString() : 'N/A'}`);
      console.log(`    SHA256 Hash: ${file.sha256Hash || 'N/A'}`);
      console.log(`    ------------------------------------`);
      files.push(file); // Store for potential use by other functions
    }
    if (!filesFound) {
      console.log("  No files found for this project.");
    }
    return files;
  } catch (listError) {
    console.error(`ERROR: Failed to list project files.`);
    console.error("File listing error details:", listError.message);
    if (listError.stack) console.error("Listing Stack:", listError.stack);
    return []; // Return empty array on error
  } finally {
    console.log(`--- End of File Listing ---`);
  }
}

async function deleteSpecificFile() {
  if (!ai || !ai.files || typeof ai.files.delete !== 'function') {
    console.error("ERROR: AI client or ai.files.delete is not available.");
    return;
  }
  console.log("\n--- Delete a Specific File ---");
  const currentFiles = await listFiles();
  if (currentFiles.length === 0) {
    console.log("No files available to delete.");
    return;
  }

  const fileNameToDelete = await askQuestion("Enter the full 'Name (ID)' of the file to delete (e.g., files/xxxxxxx): ");
  if (!fileNameToDelete || !fileNameToDelete.startsWith('files/')) {
    console.log("Invalid file name format. Must start with 'files/'. Aborting deletion.");
    return;
  }

  // Verify the file exists in the list
  const fileExists = currentFiles.some(f => f.name === fileNameToDelete);
  if (!fileExists) {
      console.log(`File with ID '${fileNameToDelete}' not found in the current list. Please check the ID and try again.`);
      return;
  }

  const confirmation = await askQuestion(`Are you sure you want to delete the file '${fileNameToDelete}'? This cannot be undone. (yes/no): `);
  if (confirmation.toLowerCase() !== 'yes') {
    console.log("Deletion aborted by user.");
    return;
  }

  try {
    const deleteParams = { name: fileNameToDelete };
    console.log("Calling ai.files.delete() with params:", JSON.stringify(deleteParams));
    await ai.files.delete(deleteParams);
    console.log(`File ${fileNameToDelete} deleted successfully.`);
  } catch (deleteError) {
    console.error(`ERROR: Failed to delete file '${fileNameToDelete}'.`);
    console.error("File deletion error details:", deleteError.message);
    if (deleteError.stack) console.error("Deletion Stack:", deleteError.stack);
  }
  console.log(`--- End of Specific File Deletion Attempt ---`);
}

async function deleteAllFiles() {
  if (!ai || !ai.files || typeof ai.files.delete !== 'function' || typeof ai.files.list !== 'function') {
    console.error("ERROR: AI client or ai.files.delete/list is not available.");
    return;
  }
  console.log("\n--- Delete ALL Project Files ---");
  console.warn("WARNING: This action will attempt to delete ALL files associated with your project key.");

  const filesToList = await listFiles(); // List them first
  if (filesToList.length === 0) {
    console.log("No files found to delete.");
    return;
  }

  const count = filesToList.length;
  const confirmPrompt = `You are about to delete ALL ${count} file(s) listed above. This action CANNOT BE UNDONE.
Type 'YES I AM ABSOLUTELY SURE' to confirm: `;
  const confirmation = await askQuestion(confirmPrompt);

  if (confirmation !== 'YES I AM ABSOLUTELY SURE') {
    console.log("Deletion of all files aborted by user.");
    return;
  }

  console.log(`Proceeding with deletion of ${count} file(s)...`);
  let successCount = 0;
  let errorCount = 0;

  for (const file of filesToList) {
    try {
      const deleteParams = { name: file.name };
      // console.log(`Attempting to delete ${file.name}...`); // Can be verbose
      await ai.files.delete(deleteParams);
      console.log(`  Successfully deleted ${file.name}`);
      successCount++;
    } catch (deleteError) {
      console.error(`  ERROR: Failed to delete file '${file.name}'.`);
      console.error("  File deletion error details:", deleteError.message);
      errorCount++;
    }
  }
  console.log("\n--- Summary of Delete All Files ---");
  console.log(`Successfully deleted: ${successCount} file(s)`);
  console.log(`Failed to delete: ${errorCount} file(s)`);
  console.log(`--- End of Delete All Files Operation ---`);
}


async function showMenu() {
  console.log("\nGemini File Manager Menu:");
  console.log("1. List all files");
  console.log("2. Delete a specific file");
  console.log("3. Delete ALL project files (USE WITH EXTREME CAUTION!)");
  console.log("4. Exit");

  const choice = await askQuestion("Enter your choice (1-4): ");
  return choice;
}

async function runFileManager() {
  await initializeClient();

  let running = true;
  while (running) {
    const choice = await showMenu();
    switch (choice) {
      case '1':
        await listFiles();
        break;
      case '2':
        await deleteSpecificFile();
        break;
      case '3':
        await deleteAllFiles();
        break;
      case '4':
        running = false;
        break;
      default:
        console.log("Invalid choice. Please enter a number between 1 and 4.");
    }
  }
  console.log("Exiting Gemini File Manager.");
  rl.close();
}

runFileManager().catch(err => {
  console.error("\n--- A FATAL UNHANDLED ERROR OCCURRED IN FILE MANAGER ---");
  console.error("Error message:", err.message);
  if (err.stack) console.error("Stack trace:", err.stack);
  rl.close();
  process.exit(1);
});


============================================================
FILE: gemini25.js
SIZE: 894 bytes
LANGUAGE: JS
============================================================

// To run this code you need to install the following dependencies:
// npm install @google/genai mime
// npm install -D @types/node

// import {
//   GoogleGenAI,
// } from '@google/genai';
const { GoogleGenAI } = require('@google/genai');

async function main() {
  const ai = new GoogleGenAI({
    apiKey: process.env.GEMINI_API_KEY,
  });
  const config = {
    responseMimeType: 'text/plain',
  };
  const model = 'gemini-2.5-pro-exp-03-25';
  // const model = 'gemini-2.5-pro-preview-05-06';
  const contents = [
    {
      role: 'user',
      parts: [
        {
          text: `list planets ... respond without using Markdown`,
        },
      ],
    },
  ];

  const response = await ai.models.generateContentStream({
    model,
    config,
    contents,
  });
  let output = "";
  for await (const chunk of response) {
    output += chunk.text;
  }
  console.log(output);
}

main();


============================================================
FILE: hattie_gemini25.js
SIZE: 10735 bytes
LANGUAGE: JS
============================================================

const { GoogleGenAI, HarmCategory, HarmBlockThreshold } = require('@google/genai');
const fs = require('fs'); // Node.js File System module

async function main() {
  const apiKeyFromEnv = process.env.GEMINI_API_KEY;
  if (!apiKeyFromEnv) {
    console.error("ERROR: GEMINI_API_KEY environment variable is not set.");
    process.exit(1);
  }

  // 1. Initialize the GoogleGenAI client (Log removed)
  const ai = new GoogleGenAI({ apiKey: apiKeyFromEnv });

  const manuscriptFilePath = 'manuscript.txt';
  let manuscriptContent = '';

  // 2. Read the manuscript file content
  try {
    if (!fs.existsSync(manuscriptFilePath)) {
      console.error(`ERROR: Manuscript file not found at: ${manuscriptFilePath}`);
      process.exit(1);
    }
    manuscriptContent = fs.readFileSync(manuscriptFilePath, 'utf8');
    console.log(`Successfully read content from ${manuscriptFilePath} (Size: ${Buffer.byteLength(manuscriptContent, 'utf8')} bytes).`);
  } catch (fileReadError) {
    console.error(`ERROR: Failed to read file '${manuscriptFilePath}'.`);
    console.error("File read error details:", fileReadError.message);
    process.exit(1);
  }

  // 3. Define the model name
  const modelName = 'gemini-2.5-pro-preview-05-06';

  // 4. Define generation configuration
  const generationConfiguration = {
    responseMimeType: 'text/plain',
  };

  // 5. Prepare the content parts for the prompt
  const contentsForRequest = [
    {
      role: 'user',
      parts: [
        { text: manuscriptContent }, // Manuscript content is the first part
        { // Instructions are the second part
          text: `\n\n---\nINSTRUCTIONS:\nYour responses must be in PLAIN TEXT ONLY.
ABSOLUTELY DO NOT use any Markdown formatting (such as **, *, #, lists with -, etc.) in any part of your response.

You will proofread the creative fiction manuscript provided above the '--- INSTRUCTIONS:' line.
Focus ONLY on grammar, spelling, and punctuation issues.

DO NOT include any introductory or concluding remarks (e.g., "Okay, here's a proofread...", "Overall, the manuscript is...").
DO NOT repeat any parts of the manuscript that are correct or do not have issues.
Your response should ONLY consist of the identified issues, formatted as follows for EACH issue found:

Original: [The complete original sentence from the manuscript with the error, exactly as it appears, with no extra quotation marks added by you around the sentence itself.]
Issue(s): [A brief description of the specific grammar, spelling, or punctuation problem(s) in that sentence.]
Correction: [The complete corrected sentence.]

After each "Correction:", add two newlines before presenting the "Original:" of the next identified issue.

For example, if the manuscript contained these lines:
Its a lovely day. The dog runned fast. See the cat.

Your response should be formatted exactly like this:

Original: Its a lovely day.
Issue(s): Spelling - "Its" should be "It's" (contraction of "it is" or "it has").
Correction: It's a lovely day.


Original: The dog runned fast.
Issue(s): Grammar - Incorrect past tense of "run".
Correction: The dog ran fast.

Now, please provide the proofread for the manuscript above using this exact format.
`,
        },
      ],
    }
  ];

  // Log only the instructions part of the prompt being sent
  const instructionsTextForLogging = contentsForRequest[0].parts[1].text;
  console.log(`\n--- Sending Prompt to Model (${modelName}) ---`);
  console.log(`Instructions Sent to Model:\n${instructionsTextForLogging}`);
  // console.log(`(Full prompt includes the manuscript content beforehand)`); // Optional clarification
  console.log(`--- End of Instructions Sent ---`);


  try {
    if (!(ai.models && typeof ai.models.generateContentStream === 'function')) {
      console.error("CRITICAL ERROR: 'ai.models.generateContentStream' is NOT a function.");
      process.exit(1);
    }

    // --- LIVE TIMER START ---
    const apiCallStartTime = new Date();
    console.log(`\nAPI Call Start Time: ${apiCallStartTime.toLocaleTimeString()}\n`);
    // Initial timer display - \r is carriage return to overwrite the line
    process.stdout.write("elapsed: 0m 0s");

    let timerInterval;
    const updateTimer = () => {
      const now = new Date();
      const elapsedMs = now.getTime() - apiCallStartTime.getTime();
      const totalSeconds = Math.floor(elapsedMs / 1000);
      const minutes = Math.floor(totalSeconds / 60);
      const seconds = totalSeconds % 60;
      // Move cursor to beginning of line, clear line, then write new time
      process.stdout.cursorTo(0); // Go to beginning of the line
      process.stdout.clearLine(0); // Clear the current line
      process.stdout.write(`elapsed: ${minutes}m ${seconds}s`);
    };
    timerInterval = setInterval(updateTimer, 1000); // Update every second
    // --- END LIVE TIMER START ---

    let lastUsageMetadata = null;

    const responseStream = await ai.models.generateContentStream({
      model: modelName,
      contents: contentsForRequest,
      generationConfig: generationConfiguration,
      safetySettings: [
        { category: HarmCategory.HARM_CATEGORY_HARASSMENT, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE },
        { category: HarmCategory.HARM_CATEGORY_HATE_SPEECH, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE },
        { category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE },
        { category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE },
      ],
    });

    clearInterval(timerInterval); // Stop the timer updating
    // MODIFICATION: Do NOT clear the timer line. Add a newline so subsequent logs appear below.
    process.stdout.write('\n'); // Ensure next log is on a new line below the frozen timer.

    const callEndTime = new Date();
    console.log(`\nAPI Call End Time (stream initiated): ${callEndTime.toLocaleTimeString()}\n`);
    const durationMs = callEndTime.getTime() - apiCallStartTime.getTime();
    const durationSeconds = durationMs / 1000;
    const displayTotalSeconds = Math.floor(durationSeconds); // Get whole seconds
    const displayMinutes = Math.floor(displayTotalSeconds / 60);
    const displayRemainingSeconds = displayTotalSeconds % 60;
    console.log(`Time to initiate stream: ${displayMinutes}m ${displayRemainingSeconds}s`);

    console.log("\nCall to ai.models.generateContentStream has returned, processing stream...");

    console.log("\n--- Gemini Response Stream ---");
    let output = "";
    let chunkCount = 0;
    const streamProcessingStartTime = new Date();

    for await (const chunk of responseStream) {
      chunkCount++;
      if (chunk.usageMetadata) {
        lastUsageMetadata = chunk.usageMetadata;
      }
      if (chunk && chunk.candidates && chunk.candidates.length > 0 &&
          chunk.candidates[0].content && chunk.candidates[0].content.parts &&
          chunk.candidates[0].content.parts.length > 0 &&
          typeof chunk.candidates[0].content.parts[0].text === 'string') {
        const textContent = chunk.candidates[0].content.parts[0].text;
        output += textContent;
        process.stdout.write(textContent);
      } else if (chunk && chunk.error) {
        console.error(`\nERROR in stream chunk ${chunkCount}:`, JSON.stringify(chunk.error));
        break;
      } else {
        console.warn(`\nSkipping unrecognized or non-text chunk structure in stream (chunk ${chunkCount}):`, JSON.stringify(chunk));
      }
    }
    process.stdout.write('\n');

    if (lastUsageMetadata) {
      console.log(`\n--- Usage Statistics (from last relevant chunk) ---`);
      console.log(`Prompt Token Count: ${lastUsageMetadata.promptTokenCount}`);
      // The 'candidatesTokenCount' in the streaming response usually accumulates
      // and the one in the *last* chunk with usageMetadata represents the total for candidates.
      console.log(`Candidates Token Count: ${lastUsageMetadata.candidatesTokenCount}`);
      console.log(`Total Token Count: ${lastUsageMetadata.totalTokenCount}`);

      // Optional: Check for other specific fields you might have seen
      if (lastUsageMetadata.promptTokensDetails) {
        // console.log(`Prompt Tokens Details:`, JSON.stringify(lastUsageMetadata.promptTokensDetails, null, 2));
      }
      if (lastUsageMetadata.thoughtsTokenCount !== undefined) {
        console.log(`Thoughts Token Count: ${lastUsageMetadata.thoughtsTokenCount}`);
      }
      // For full inspection:
      // console.log("Full Final Usage Metadata:", JSON.stringify(lastUsageMetadata, null, 2));
      console.log(`--- End Usage Statistics ---`);
    } else {
      console.log("\nNo usage metadata was found in the response stream.");
    }

    const streamProcessingEndTime = new Date();
    const streamDurationMs = streamProcessingEndTime.getTime() - streamProcessingStartTime.getTime();
    const streamDurationSeconds = streamDurationMs / 1000;

    if (chunkCount === 0) {
        console.log("WARNING: Stream completed with 0 chunks containing parsable text.");
    }
    console.log(`--- End of Stream (processed ${chunkCount} chunks in ${streamDurationSeconds.toFixed(2)} seconds) ---`);

    const totalEndTime = new Date();
    const totalDurationMs = totalEndTime.getTime() - apiCallStartTime.getTime();
    const totalDurationSeconds = totalDurationMs / 1000;
    // console.log(`\nTotal operation time (API call + stream processing): ${totalDurationSeconds.toFixed(2)} seconds.`);
    const wholeSeconds = Math.floor(totalDurationSeconds);
    console.log(`\nTotal operation time (API call + stream processing): ${Math.floor(wholeSeconds / 60)}m ${wholeSeconds % 60}s.`);

  } catch (error) {
    // --- Ensure timer is cleared on error too ---
    if (timerInterval) {
        clearInterval(timerInterval);
        // MODIFICATION: Do NOT clear the timer line if error occurs after it started. Add a newline.
        process.stdout.write('\n');
    }
    // ---
    console.error("\nERROR during 'ai.models.generateContentStream' call or stream processing:");
    console.error("Error message:", error.message);
    if (error.stack) console.error("Stack:", error.stack);
    if (error.cause) console.error("Cause:", error.cause);
    if (error.response) {
        console.error("API Response (if available from error object):", JSON.stringify(error.response, null, 2));
    }
    process.exit(1);
  }
}

main().catch(error => {
  console.error("\n--- A FATAL UNHANDLED ERROR OCCURRED IN main() ---");
  console.error("Error message:", error.message);
  if (error.stack) console.error("Stack trace:", error.stack);
  if (error.cause) console.error("Cause:", error.cause);
  process.exit(1);
});


============================================================
FILE: kdp-publishing-prep.js
SIZE: 16318 bytes
LANGUAGE: JS
============================================================

// kdp-publishing-prep.js
const BaseTool = require('./base-tool');
const path = require('path');
const fs = require('fs/promises');
const fileCache = require('./file-cache');
const appState = require('./state.js');

/**
 * KDP Publishing Prep Tool
 * Analyzes a manuscript and generates KDP publishing elements
 * including title suggestions, descriptions, categories, keywords, and more
 */
class KdpPublishingPrep extends BaseTool {
  /**
   * Constructor
   * @param {Object} GeminiAPIService - Claude API service
   * @param {Object} config - Tool configuration
   */
  constructor(GeminiAPIService, config = {}) {
    super('kdp_publishing_prep', config);
    this.GeminiAPIService = GeminiAPIService;
  }
  
  /**
   * Execute the tool
   * @param {Object} options - Tool options
   * @returns {Promise<Object>} - Execution result
   */
  async execute(options) {
    console.log('Executing KdpPublishingPrep with options:', options);
    
    // Extract options
    let manuscriptFile = options.manuscript_file;
    const bookType = options.book_type;
    const titleIdeas = options.title_ideas;
    const existingTitle = options.existing_title;
    const targetAudience = options.target_audience;
    const includeHtml = options.include_html;

    let saveDir = options.save_dir || appState.CURRENT_PROJECT_PATH;
    
    // Check if we have a valid save directory
    if (!saveDir) {
      const errorMsg = 'Error: No save directory specified and no current project selected.\n' +
                      'Please select a project or specify a save directory.';
      this.emitOutput(errorMsg);
      throw new Error('No save directory available');
    }

    // Ensure file paths are absolute by prepending the project path if needed
    manuscriptFile = this.ensureAbsolutePath(manuscriptFile, saveDir);
    
    // Log the full paths for debugging
    console.log('Using full paths:');
    console.log(`Manuscript: ${manuscriptFile}`);
    console.log(`Save directory: ${saveDir}`);

    const outputFiles = [];
    
    try {
      // Read the manuscript file
      this.emitOutput(`Reading manuscript file: ${manuscriptFile}\n`);
      const manuscriptContent = await this.readInputFile(manuscriptFile);
      
      // Get word count for progress reporting
      const wordCount = this.countWords(manuscriptContent);
      this.emitOutput(`Manuscript loaded. Word count: ${wordCount.toLocaleString()}\n`);
      
      // Prepare for analysis
      this.emitOutput(`Analyzing manuscript content for KDP publishing elements...\n`);
      
      // Prepare text sample for analysis (for large manuscripts)
      const textSample = this.prepareTextSample(manuscriptContent);
      
      // Start generating KDP elements
      this.emitOutput(`Generating KDP publishing elements with AI analysis...\n`);
      
      // Create appropriate prompt based on book type
      const prompt = this.createKDPPrompt(textSample, bookType, titleIdeas, existingTitle, targetAudience);
      
      // Count tokens in the prompt
      this.emitOutput(`Counting tokens in prompt...\n`);
      const promptTokens = await this.GeminiAPIService.countTokens(prompt);

      // Calculate token budgets
      const tokenBudgets = this.GeminiAPIService.calculateTokenBudgets(promptTokens);

      // Log token information
      this.emitOutput(`\nToken stats:\n`);
      this.emitOutput(`Max AI model context window: [${tokenBudgets.contextWindow}] tokens\n`);
      this.emitOutput(`Input prompt tokens: [${tokenBudgets.promptTokens}]\n`);
      this.emitOutput(`Available tokens: [${tokenBudgets.availableTokens}]\n`);
      this.emitOutput(`Desired output tokens: [${tokenBudgets.desiredOutputTokens}]\n`);
      this.emitOutput(`AI model thinking budget: [${tokenBudgets.thinkingBudget}] tokens\n`);
      this.emitOutput(`Max output tokens: [${tokenBudgets.maxTokens}] tokens\n`);

      // Check if the prompt is too large
      if (tokenBudgets.isPromptTooLarge) {
        this.emitOutput(`Error: prompt is too large to have a ${tokenBudgets.configuredThinkingBudget} thinking budget!\n`);
        this.emitOutput(`Run aborted!\n`);
        throw new Error(`Prompt is too large for ${tokenBudgets.configuredThinkingBudget} thinking budget - run aborted`);
      }
      
      // Call Claude API with streaming
      this.emitOutput(`Sending request to Claude API (streaming)...\n`);
      
      const startTime = Date.now();
      let fullResponse = "";
      let thinkingContent = "";
        
      // Create system prompt to avoid markdown
      // const systemPrompt = "CRITICAL INSTRUCTION: NO Markdown formatting of ANY kind. Never use headers, bullets, or any formatting symbols. Plain text only with standard punctuation.";
      
      // Use the calculated values in the API call
      try {
        await this.GeminiAPIService.streamWithThinking(
          prompt,
          {
            max_tokens: tokenBudgets.maxTokens,
            thinking: {
              type: "enabled",
              budget_tokens: tokenBudgets.thinkingBudget
            }
          },
          // Callback for thinking content
          (thinkingDelta) => {
            thinkingContent += thinkingDelta;
          },
          // Callback for response text
          (textDelta) => {
            fullResponse += textDelta;
          }
        );
      } catch (error) {
        this.emitOutput(`\nAPI Error: ${error.message}\n`);
        throw error;
      }

      // Remove any markdown formatting
      // cls: also removes HTML so skip this:
      // fullResponse = this.removeMarkdown(fullResponse);

      const elapsed = (Date.now() - startTime) / 1000;
      const minutes = Math.floor(elapsed / 60);
      const seconds = elapsed % 60;
      
      this.emitOutput(`\nCompleted in ${minutes}m ${seconds.toFixed(2)}s.\n`);
      
      // Count words in response
      const responseWordCount = this.countWords(fullResponse);
      this.emitOutput(`Analysis contains approximately ${responseWordCount} words.\n`);
      
      // Create timestamp for filename
      const timestamp = new Date().toISOString().replace(/[-:.]/g, '').substring(0, 15);
      
      // Create base filename
      const baseFilename = `kdp_publishing_prep_${timestamp}`;
      
      // Save the KDP elements to file
      const mainOutputPath = path.join(saveDir, `${baseFilename}.txt`);
      await this.writeOutputFile(fullResponse, saveDir, `${baseFilename}.txt`);
      outputFiles.push(mainOutputPath);
      
      // Save the thinking content if available
      if (thinkingContent) {
        const thinkingPath = path.join(saveDir, `${baseFilename}_thinking.txt`);
        await this.writeOutputFile(thinkingContent, saveDir, `${baseFilename}_thinking.txt`);
        outputFiles.push(thinkingPath);
      }
      
      // If HTML formatting was requested, extract and save the HTML description
      if (includeHtml) {
        try {
          const htmlDescription = this.extractHTMLDescription(fullResponse);
          if (htmlDescription) {
            const htmlPath = path.join(saveDir, `${baseFilename}_description_html.txt`);
            await this.writeOutputFile(htmlDescription, saveDir, `${baseFilename}_description_html.txt`);
            outputFiles.push(htmlPath);
          }
        } catch (error) {
          this.emitOutput(`Warning: Could not extract HTML description. ${error.message}\n`);
        }
      }
      
      this.emitOutput(`\nKDP publishing elements saved to: ${mainOutputPath}\n`);
      this.emitOutput(`\n✅ KDP Publishing Prep complete!\n`);
      
      // Return success
      return {
        success: true,
        outputFiles,
        stats: {
          wordCount,
          responseWordCount,
          promptTokens,
          responseTokens: await this.GeminiAPIService.countTokens(fullResponse)
        }
      };
      
    } catch (error) {
      console.error('Error in KdpPublishingPrep:', error);
      this.emitOutput(`\nError: ${error.message}\n`);
      throw error;
    }
  }
  
  /**
   * Create prompt for KDP elements generation
   * @param {string} textSample - Manuscript sample text
   * @param {string} bookType - Fiction or non-fiction
   * @param {string} titleIdeas - Optional title ideas from the author
   * @param {string} existingTitle - Optional existing title
   * @param {string} targetAudience - Optional target audience info
   * @returns {string} - Prompt for Claude API
   */
  createKDPPrompt(textSample, bookType, titleIdeas, existingTitle, targetAudience) {
    const titleContext = existingTitle 
      ? `The author has an existing title in mind: "${existingTitle}". Evaluate if this title works well or suggest alternatives.`
      : titleIdeas 
        ? `The author has shared these title ideas or concepts: "${titleIdeas}". Incorporate these if they work well.`
        : "Generate fresh title ideas based on the manuscript content.";
        
    const audienceContext = targetAudience
      ? `The author has identified their target audience as: "${targetAudience}". Keep this in mind when making suggestions.`
      : "";
      
    return `You are a professional publishing consultant helping an author prepare their manuscript for Kindle Direct Publishing (KDP). 

The author has provided their manuscript text and needs your expertise to generate the essential elements for their KDP submission page. Amazon has specific requirements and limitations for each element.

Here's what the author needs:

1. TITLE AND SUBTITLE SUGGESTIONS
   - Provide 3-5 strong title options that reflect the manuscript's content
   - For each title, suggest an optional subtitle if appropriate
   - Maximum combined length: 200 characters
   - Titles should be marketable but authentic to the content
   - ${titleContext}

2. BOOK DESCRIPTION
   - Create a compelling book description (~400-600 words)
   - Character limit: 4,000 characters including spaces
   - This will appear on the Amazon product page
   - Engage readers while accurately representing the content
   - Maintain appropriate tone and style for the genre
   - Do NOT include:
     * Reviews, quotes, or testimonials
     * Requests for customer reviews
     * Advertisements or promotional material
     * Time-sensitive information
     * Availability or pricing information
     * Links to other websites
     * Spoilers
   
3. DESCRIPTION WITH HTML FORMATTING
   - Provide the same description formatted with simple HTML tags
   - Use only these supported tags: <br>, <p></p>, <b></b>, <em></em>, <i></i>, <u></u>, <h4></h4>, <h5></h5>, <h6></h6>, <ol>, <ul>, <li>
   - Character count includes HTML tags (still 4,000 character limit)

4. CATEGORY RECOMMENDATIONS
   - Recommend 3 specific Amazon browse categories for discoverability
   - Include both primary and secondary category paths
   - Follow Amazon's category structure (Fiction/Genre/Subgenre or Nonfiction/Topic/Subtopic)
   - Explain why these categories fit the work

5. KEYWORD SUGGESTIONS
   - Suggest 7 keywords/phrases (50 character limit each)
   - Focus on search terms potential readers might use
   - Optimize for Amazon's search algorithm
   - Avoid:
     * Other authors' names
     * Books by other authors
     * Sales rank terms (e.g., "bestselling")
     * Promotional terms (e.g., "free")
     * Unrelated content

6. CONCISE SYNOPSIS
   - Create a brief overview (150-200 words)
   - Capture the essence without spoilers
   - For fiction: main character, conflict, stakes, setting, tone
   - For non-fiction: core thesis, approach, perspective, value to readers

7. ELEVATOR PITCH
   - Ultra-short compelling hook (1-2 sentences)
   - Captures the book's essence/selling points

8. READING AGE RECOMMENDATION
   - Suggest appropriate age range for readers
   - For children's books: 0-2, 3-5, 6-8, 9-12
   - For YA: 13-17
   - For adult books: appropriate range based on content
   - Consider themes, language, and content maturity

9. GENERAL PUBLISHING RECOMMENDATIONS
   - Specific advice for maximizing this book's success on KDP
   - KDP Select enrollment recommendation (yes/no and why)
   - Any other relevant KDP strategy suggestions

${audienceContext}

Analyze the following manuscript and provide all requested elements in a clearly organized format. For a ${bookType} book:

=== MANUSCRIPT ===
${textSample}
=== END MANUSCRIPT ===`;
  }

  /**
   * Prepare a representative sample of the manuscript for analysis
   * @param {string} fullText - Complete manuscript text
   * @returns {string} - Sample text for analysis
   */
  prepareTextSample(fullText) {
    // Split text into paragraphs
    const paragraphs = fullText.split(/\n\s*\n/).filter(p => p.trim().length > 0);
    
    // If text is short enough, use it all
    if (fullText.length < 60000) {
      return fullText;
    }
    
    // Otherwise, create a strategic sample:
    // 1. First 20 paragraphs (beginning)
    // 2. Middle 10 paragraphs (middle of story)
    // 3. Last 20 paragraphs (ending)
    // 4. Additional samples from quarter and three-quarter points
    
    const beginning = paragraphs.slice(0, 20).join('\n\n');
    
    const quarterIndex = Math.floor(paragraphs.length * 0.25);
    const quarterSample = paragraphs.slice(quarterIndex, quarterIndex + 5).join('\n\n');
    
    const middleIndex = Math.floor(paragraphs.length / 2);
    const middle = paragraphs.slice(middleIndex - 5, middleIndex + 5).join('\n\n');
    
    const threeQuarterIndex = Math.floor(paragraphs.length * 0.75);
    const threeQuarterSample = paragraphs.slice(threeQuarterIndex, threeQuarterIndex + 5).join('\n\n');
    
    const ending = paragraphs.slice(-20).join('\n\n');
    
    return `BEGINNING:\n${beginning}\n\nQUARTER POINT:\n${quarterSample}\n\nMIDDLE SECTION:\n${middle}\n\nTHREE-QUARTER POINT:\n${threeQuarterSample}\n\nENDING:\n${ending}`;
  }
  
  /**
   * Extract HTML formatted description from response
   * @param {string} response - Full response from Claude
   * @returns {string} - HTML formatted description
   */
  extractHTMLDescription(response) {
    const regex = /DESCRIPTION WITH HTML FORMATTING:?\s*\n*([\s\S]*?)(?=\n\s*\d+\.|$)/i;
    const match = response.match(regex);
    
    if (match && match[1]) {
      return match[1].trim();
    }
    
    return null;
  }
  
  /**
   * Read an input file
   * @param {string} filePath - Path to the file
   * @returns {Promise<string>} - File content
   */
  async readInputFile(filePath) {
    try {
      return await fs.readFile(filePath, 'utf8');
    } catch (error) {
      console.error(`Error reading file ${filePath}:`, error);
      this.emitOutput(`Error reading file: ${error.message}\n`);
      throw new Error(`Could not read file ${path.basename(filePath)}: ${error.message}`);
    }
  }
  
  /**
   * Write content to an output file
   * @param {string} content - Content to write
   * @param {string} saveDir - Directory to save to
   * @param {string} filename - Name of the file
   * @returns {Promise<void>}
   */
  async writeOutputFile(content, saveDir, filename) {
    try {
      const filePath = path.join(saveDir, filename);
      await fs.writeFile(filePath, content, 'utf8');
      
      // Add to file cache
      fileCache.addFile({
        path: filePath,
        toolId: this.id,
        type: 'text'
      });
      
      return filePath;
    } catch (error) {
      console.error(`Error writing file ${filename}:`, error);
      this.emitOutput(`Error writing file: ${error.message}\n`);
      throw error;
    }
  }
  
  /**
   * Ensure file path is absolute
   * @param {string} filePath - File path (may be relative or absolute)
   * @param {string} basePath - Base path to prepend for relative paths
   * @returns {string} - Absolute file path
   */
  ensureAbsolutePath(filePath, basePath) {
    if (!filePath) return filePath;
    
    // Check if the path is already absolute
    if (path.isAbsolute(filePath)) {
      return filePath;
    }
    
    // Make the path absolute by joining with the base path
    return path.join(basePath, filePath);
  }
  
  /**
   * Count words in text
   * @param {string} text - Text to count words in
   * @returns {number} - Word count
   */
  countWords(text) {
    return text.split(/\s+/).filter(word => word.length > 0).length;
  }
}

module.exports = KdpPublishingPrep;


============================================================
FILE: line-editing.js
SIZE: 22342 bytes
LANGUAGE: JS
============================================================

// line-editing.js
const BaseTool = require('./base-tool');
const path = require('path');
const fileCache = require('./file-cache');
const appState = require('./state.js');
const fs = require('fs/promises');

/**
 * LineEditing Tool
 * Performs detailed line editing analysis on a specific chapter of a fiction manuscript.
 */
class LineEditing extends BaseTool {
  /**
   * Constructor
   * @param {Object} GeminiAPIService - Claude API service
   * @param {Object} config - Tool configuration
   */
  constructor(GeminiAPIService, config = {}) {
    super('line_editing', config);
    this.GeminiAPIService = GeminiAPIService;
  }

  /**
   * Execute the tool
   * @param {Object} options - Tool options
   * @returns {Promise<Object>} - Execution result
   */
  async execute(options) {
    console.log('Executing Line Editing with options:', options);
    
    // Extract options
    let manuscriptFile = options.manuscript_file;
    const chapterNumber = options.chapter_number;
    const saveDir = options.save_dir || appState.CURRENT_PROJECT_PATH;
    
    if (!saveDir) {
      const errorMsg = 'Error: No save directory specified and no current project selected.\n' +
                      'Please select a project or specify a save directory.';
      this.emitOutput(errorMsg);
      throw new Error('No save directory available');
    }

    // Ensure file paths are absolute
    manuscriptFile = this.ensureAbsolutePath(manuscriptFile, saveDir);

    const outputFiles = [];
    
    try {
      // Read the input files
      this.emitOutput(`Reading files...\n`);

      // Read the manuscript file
      this.emitOutput(`Reading manuscript file: ${manuscriptFile}\n`);
      const manuscriptContent = await this.readInputFile(manuscriptFile);
        
      const prompt = this.createPrompt(manuscriptContent, chapterNumber);

      // Count tokens in the prompt
      this.emitOutput(`Counting tokens in prompt...\n`);
      const promptTokens = await this.GeminiAPIService.countTokens(prompt);

      // Call the shared token budget calculator
      const tokenBudgets = this.GeminiAPIService.calculateTokenBudgets(promptTokens);

      // Handle logging based on the returned values
      this.emitOutput(`\nToken stats:\n`);
      this.emitOutput(`Max AI model context window: [${tokenBudgets.contextWindow}] tokens\n`);
      this.emitOutput(`Input prompt tokens: [${tokenBudgets.promptTokens}] ...\n`);
      this.emitOutput(`Available tokens: [${tokenBudgets.availableTokens}]  = ${tokenBudgets.contextWindow} - ${tokenBudgets.promptTokens} = context_window - prompt\n`);
      this.emitOutput(`Desired output tokens: [${tokenBudgets.desiredOutputTokens}]\n`);
      this.emitOutput(`AI model thinking budget: [${tokenBudgets.thinkingBudget}] tokens\n`);
      this.emitOutput(`Max output tokens: [${tokenBudgets.maxTokens}] tokens\n`);

      // Check for special conditions
      if (tokenBudgets.capThinkingBudget) {
        this.emitOutput(`Warning: thinking budget is larger than 32K, set to 32K.\n`);
      }

      // Check if the prompt is too large
      if (tokenBudgets.isPromptTooLarge) {
        this.emitOutput(`Error: prompt is too large to have a ${tokenBudgets.configuredThinkingBudget} thinking budget!\n`);
        this.emitOutput(`Run aborted!\n`);
        throw new Error(`Prompt is too large for ${tokenBudgets.configuredThinkingBudget} thinking budget - run aborted`);
      }
      
      // Call Claude API with streaming
      this.emitOutput(`Sending request to Claude API (streaming)...\n`);
      
      // Add a message about waiting
      this.emitOutput(`****************************************************************************\n`);
      this.emitOutput(`*  Line Editing Chapter ${chapterNumber} in progress...                    \n`);
      this.emitOutput(`*  This process typically takes several minutes.                           \n`);
      this.emitOutput(`*                                                                          \n`);
      this.emitOutput(`*  It's recommended to keep this window the sole 'focus'                   \n`);
      this.emitOutput(`*  and to avoid browsing online or running other apps, as these API        \n`);
      this.emitOutput(`*  network connections can be fragile.                                     \n`);
      this.emitOutput(`*                                                                          \n`);
      this.emitOutput(`*  Please wait while Claude analyzes the chapter...                        \n`);
      this.emitOutput(`****************************************************************************\n\n`);
      
      const startTime = Date.now();
      let fullResponse = "";
      let thinkingContent = "";
      
      // Create system prompt to avoid markdown
      const systemPrompt = "CRITICAL INSTRUCTION: NO Markdown formatting of ANY kind. Never use headers, bullets, or any formatting symbols. Plain text only with standard punctuation.";

      // Use the calculated values in the API call
      // console.log(`prompt:\n`, prompt);
      try {
        await this.GeminiAPIService.streamWithThinking(
          prompt,
          {
            system: systemPrompt,
            max_tokens: tokenBudgets.maxTokens,
            thinking: {
              type: "enabled",
              budget_tokens: tokenBudgets.thinkingBudget
            }
          },
          // Callback for thinking content
          (thinkingDelta) => {
            thinkingContent += thinkingDelta;
          },
          // Callback for response text
          (textDelta) => {
            fullResponse += textDelta;
          }
        );
      } catch (error) {
        this.emitOutput(`\nAPI Error: ${error.message}\n`);
        throw error;
      }

      const elapsed = (Date.now() - startTime) / 1000;
      const minutes = Math.floor(elapsed / 60);
      const seconds = elapsed % 60;
      
      this.emitOutput(`\nCompleted in ${minutes}m ${seconds.toFixed(2)}s.\n`);
      
      // Count words in response
      const wordCount = this.countWords(fullResponse);
      this.emitOutput(`Line editing analysis has approximately ${wordCount} words.\n`);
      
      // Count tokens in response
      const responseTokens = await this.GeminiAPIService.countTokens(fullResponse);
      this.emitOutput(`Response token count: ${responseTokens}\n`);

      // Remove any markdown formatting
      fullResponse = this.removeMarkdown(fullResponse);

      // Save the report
      const outputFile = await this.saveReport(
        fullResponse,
        thinkingContent,
        promptTokens,
        responseTokens,
        saveDir,
        chapterNumber
      );
      
      // Add the output files to the result
      outputFiles.push(...outputFile);
      
      // Add files to the cache
      const toolName = 'line_editing';
      outputFiles.forEach(file => {
        fileCache.addFile(toolName, file);
      });
      
      // Return the result
      return {
        success: true,
        outputFiles
      };
    } catch (error) {
      console.error('Error in LineEditing:', error);
      this.emitOutput(`\nError: ${error.message}\n`);
      throw error;
    }
  }
  
  /**
   * Create prompt
   * @param {string} manuscriptContent - Manuscript content
   * @param {string} chapterNumber - Chapter number to analyze
   * @returns {string} - Prompt for Claude API
   */
  //   createPrompt(manuscriptContent, chapterNumber) {
  //     const prompt = `You are an expert line editor specializing in creative fiction. Your task is to provide detailed line editing feedback on the fiction manuscript text provided, focusing specifically on the chapter referenced.

  // I'm providing:
  // 1. A complete fiction manuscript
  // 2. A chapter reference: ${chapterNumber}

  // IMPORTANT: Provide your entire response in plain text only. NO Markdown formatting of ANY kind. Do not use #, *, _, or any other Markdown symbols. Use only standard text formatting with clear section breaks using plain text characters like equals signs and dashes.

  // First, you will need to extract the specified chapter from the manuscript. Look for the chapter heading that matches the reference (accounting for different formatting like "Chapter ${chapterNumber}", "${chapterNumber}.", "CHAPTER ${this.numberToWord(chapterNumber).toUpperCase()}", etc.). Extract all text from this chapter heading until the next chapter heading or the end of the manuscript.

  // Once you've identified the chapter text, proceed with your line editing analysis.

  // Begin your response with the exact chapter heading/title as it appears in the manuscript. This should be prominently displayed at the top of your analysis.

  // For each sentence in the extracted chapter, you will:
  // 1. Quote the original sentence exactly as written
  // 2. List ALL line editing issues in that sentence, with no artificial limit - be thorough and identify every issue you detect
  // 3. Provide one sample rewrite that addresses all identified issues
  // 4. DO NOT add any quotation marks that aren't already in the original text

  // Your fiction-focused analysis should address:
  // - Character voice consistency and authenticity
  // - Dialogue that sounds natural and distinctive
  // - Balance of showing vs. telling
  // - Sensory details and vivid imagery
  // - Emotional resonance and impact
  // - Sentence rhythm and flow for dramatic effect
  // - Word choice and precision for fiction
  // - Eliminating weak modifiers, clichés, and redundancies
  // - Strengthening verbs and removing unnecessary adverbs
  // - Point of view consistency
  // - Improving clarity without sacrificing style
  // - Enhancing pacing appropriate to scene intensity

  // At the end of each paragraph, add:
  // 1. A comprehensive paragraph-level analysis that addresses:
  //    - Scene-building effectiveness
  //    - Emotional arc within the paragraph
  //    - Character development revealed
  //    - Balance of action, dialogue, and description
  //    - Overall flow and coherence
  //    - Appropriate length for story pacing
  //    - Any recurring issues across multiple sentences

  // Format your feedback like this (using ONLY plain text, NO Markdown):

  // ====================
  // [EXACT CHAPTER HEADING/TITLE AS IT APPEARS IN THE MANUSCRIPT]
  // ====================

  // ORIGINAL: [exact original sentence]
  // ISSUES:
  // - [Issue 1]
  // - [Issue 2]
  // - [Continue listing ALL issues you identify]
  // SUGGESTED REWRITE: [your revised version]

  // [After the last sentence in a paragraph]
  // PARAGRAPH ANALYSIS: [Your detailed insights about paragraph-level issues]

  // Remember:
  // 1. Preserve the author's unique fictional voice and style
  // 2. Focus on enhancing the emotional and sensory impact
  // 3. Maintain character consistency in dialogue and actions
  // 4. Aim for prose that serves the story and engages readers
  // 5. Be precise but supportive in your critique
  // 6. Offer concrete improvements rather than just identifying problems
  // 7. Be as thorough as possible - don't limit your analysis due to space concerns
  // 8. Use plain text ONLY - avoid any special formatting characters

  // Your final output should be a comprehensive line edit of the extracted chapter that helps the author elevate their fiction without changing their distinct voice or storytelling approach, formatted in clean, easy-to-edit plain text.

  // === MANUSCRIPT ===
  // ${manuscriptContent}
  // === END MANUSCRIPT ===`;

  //     return prompt;
  //   }

  createPrompt(manuscriptContent, chapterNumber) {
    const prompt = `You are an expert line editor specializing in creative fiction. Your task is to provide detailed line editing feedback on the fiction manuscript text provided, focusing specifically on the chapter referenced.
Your goal is to enhance the clarity, flow, conciseness, word choice, sentence structure, and overall impact of the provided text at the sentence and paragraph level, while preserving the author's unique voice and style.

I'm providing:
1. A complete fiction manuscript
2. A chapter reference: ${chapterNumber}

IMPORTANT: Provide your entire response in plain text only. NO Markdown formatting of ANY kind. Do not use #, *, _, or any other Markdown symbols. Use only standard text formatting with clear section breaks using plain text characters like equals signs and dashes.

TASK: Perform a detailed line edit on the following manuscript, focusing specifically on the chapter referenced: ${chapterNumber}.
Focus ONLY on line-level improvements. 
Do NOT address plot, character arcs, or overall structure (developmental edits). 
Do NOT perform simple proofreading (catching only typos/grammar errors), although you should mention obvious errors you encounter.

CRITICAL PRELIMINARY ANALYSIS (REQUIRED):
Before suggesting any edits, thoroughly read the entire manuscript to establish:

1. Genre Context: Identify the genre and its conventions. Different genres permit different approaches to pacing, description, dialogue, and technical elements.

2. Writer's Style: Note distinctive patterns in:
   - Sentence structure (short and punchy vs. flowing and complex)
   - Word choice (formal vs. colloquial, sparse vs. rich)
   - Use of literary devices (metaphors, alliteration, repetition)
   - Handling of transitions between ideas

3. Writer's Voice: Recognize the unique personality coming through in:
   - Narrative tone (serious, humorous, ironic, etc.)
   - Level of authorial presence/distance
   - Distinctive phrases or cadences
   - Character voice differentiation in dialogue
   - How emotions and thoughts are conveyed

4. Structural Rhythm/Whitespace: Observe patterns in:
   - Balance between dialogue and description
   - Paragraph length variation
   - Scene vs. summary
   - Use of white space to create pacing effects

VERY IMPORTANT: 
Do not suggest changes to every sentence. 
Many apparent "deviations" from standard writing conventions are 
deliberate stylistic choices that contribute to the author's unique voice. 
efore suggesting any edit, ask yourself: 
"Is this truly improving the writing, or am I simply enforcing a convention that may not apply to this author's style or genre?"

FOCUS AREAS FOR LINE EDITING (apply selectively, respecting the author's established style):

1. Clarity & Precision:
   - Are there genuinely ambiguous sentences or phrases?
   - Can any sentences be made clearer or more direct without sacrificing the author's voice?
   - Are there vague words that could be replaced with stronger, more specific ones?

2. Conciseness:
   - Identify and remove redundant words, phrases, or sentences.
   - Tighten wordy constructions that don't serve a stylistic purpose.
   - Eliminate unnecessary filler words that don't contribute to rhythm or voice.

3. Flow & Rhythm:
   - Check sentence structure variation. Are there too many sentences of the same length or structure?
   - Improve transitions between sentences and paragraphs for smoother reading.
   - Does the text have a good rhythm, or does it feel choppy or monotonous in ways that don't serve the content?

4. Word Choice (Diction):
   - Are there clichés or overused phrases that could be refreshed?
   - Is the vocabulary appropriate for the genre, tone, and characters/narrator?
   - Are there stronger verbs or more evocative adjectives that could be used?
   - Ensure consistent tone and voice that matches the author's established style.

5. Sentence Structure (Syntax):
   - Correct genuinely awkward phrasing or confusing sentence structures.
   - Check for misplaced modifiers or parallelism issues that impede understanding.
   - Ensure subject-verb agreement and correct pronoun usage.

6. Show, Don't Tell:
   - Identify instances of "telling" that could be replaced with "showing" through action, dialogue, sensory details, or internal thought. (Apply lightly at the line-edit stage)

7. Consistency:
   - Check for consistent terminology, character voice (within dialogue), and narrative perspective.

INSTRUCTIONS FOR OUTPUT FORMAT:

Present your line edits in the following consistent format for each paragraph or section where changes are suggested. 
PAY CAREFUL ATTENTION TO THE NEWLINES AFTER EACH LABEL:

ORIGINAL TEXT: [put a newline here]
[Copy the exact original text verbatim on a new line after this label]

ISSUES IDENTIFIED: [put a newline here]
- [Issue 1]: [Brief explanation]
- [Issue 2]: [Brief explanation]
(Only list genuine issues that need addressing)

SUGGESTED CHANGES: [put a newline here]
[Present the revised text with changes clearly marked on a new line after this label]

EXPLANATION: [put a newline here]
[Brief explanation on a new line after this label, explaining why these changes improve the text while respecting the author's voice]


FORMATTING EXAMPLE:

ORIGINAL TEXT: 
She ran quickly to the store, her feet pounding against the sidewalk as she hurried with great speed toward her destination.

ISSUES IDENTIFIED:
- Redundancy: "ran quickly" and "hurried with great speed" express the same idea twice
- Wordiness: The sentence could be more concise while maintaining the sense of urgency

SUGGESTED CHANGES:
She ran to the store, her feet pounding against the sidewalk as she hurried toward her destination.

EXPLANATION: 
This edit removes redundant phrasing while preserving the urgency and physical description in the original sentence.


For passages that need no editing, simply state: "This passage effectively achieves its purpose while maintaining the author's voice. No edits suggested."

Maintain the author's original voice and intent. Do not rewrite extensively. Focus on quality over quantity of edits - prioritize changes that will have meaningful impact.
After all, the author can re-run this prompt after applying changes to the manuscript.    

=== MANUSCRIPT ===
${manuscriptContent}
=== END MANUSCRIPT ===

DENSITY OF EDITING: Please provide moderate line editing, focusing on the most impactful changes rather than attempting to "fix" every possible issue.

Thank you for your thoughtful and respectful approach to line editing.`;

    return prompt;
  }


  /**
   * Convert a number to its word representation (for chapter numbers)
   * @param {number|string} num - The number to convert
   * @returns {string} - Word representation
   */
  numberToWord(num) {
    // Convert string to number if necessary
    num = parseInt(num, 10);
    
    const words = [
      'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine',
      'ten', 'eleven', 'twelve', 'thirteen', 'fourteen', 'fifteen', 'sixteen', 'seventeen', 'eighteen', 'nineteen',
      'twenty'
    ];
    
    // Handle simple cases
    if (num <= 20) return words[num];
    
    // For simplicity, just return the number as string for larger numbers
    // A more comprehensive implementation would handle all numbers
    return num.toString();
  }

  /**
   * Count words in text
   * @param {string} text - Text to count words in
   * @returns {number} - Word count
   */
  countWords(text) {
    return text.split(/\s+/).filter(word => word.length > 0).length;
  }
  
  /**
   * Ensure file path is absolute
   * @param {string} filePath - File path (may be relative or absolute)
   * @param {string} basePath - Base path to prepend for relative paths
   * @returns {string} - Absolute file path
   */
  ensureAbsolutePath(filePath, basePath) {
    if (!filePath) return filePath;
    
    // Check if the path is already absolute
    if (path.isAbsolute(filePath)) {
      return filePath;
    }
    
    // Make the path absolute by joining with the base path
    return path.join(basePath, filePath);
  }
  
  /**
   * Save report and thinking content to files
   * @param {string} content - Response content
   * @param {string} thinking - Thinking content
   * @param {number} promptTokens - Prompt token count
   * @param {number} responseTokens - Response token count
   * @param {string} saveDir - Directory to save to
   * @param {string} chapterNumber - Chapter number that was analyzed
   * @returns {Promise<string[]>} - Array of paths to saved files
   */
  async saveReport(
    content,
    thinking,
    promptTokens,
    responseTokens,
    saveDir,
    chapterNumber
  ) {
    try {
      const formatter = new Intl.DateTimeFormat('en-US', {
        weekday: 'long',
        month: 'long',
        day: 'numeric',
        year: 'numeric',
        hour: 'numeric',
        minute: '2-digit',
        hour12: true
      });
      const dateTimeStr = formatter.format(new Date());

      // Create timestamp for filename
      const timestamp = new Date().toISOString().replace(/[-:.]/g, '').substring(0, 15);
      
      // Create descriptive filename
      const baseFilename = `line_editing_chapter_${chapterNumber}_${timestamp}`;
      
      // Array to collect all saved file paths
      const savedFilePaths = [];
      
      // Create stats for thinking file
      const stats = `
Details:  ${dateTimeStr}
Max request timeout: ${this.config.request_timeout} seconds
Max AI model context window: ${this.config.context_window} tokens
AI model thinking budget: ${this.config.thinking_budget_tokens} tokens
Desired output tokens: ${this.config.desired_output_tokens} tokens

Input tokens: ${promptTokens}
Output tokens: ${responseTokens}
`;
      
      // Save full response
      const reportFilename = `${baseFilename}.txt`;
      const reportPath = path.join(saveDir, reportFilename);
      await this.writeOutputFile(content, saveDir, reportFilename);
      savedFilePaths.push(reportPath);
      this.emitOutput(`Line editing analysis saved to: ${reportPath}\n`);
      
      // Save thinking content to a separate file
      const thinkingFilename = `${baseFilename}_thinking.txt`;
      const thinkingPath = path.join(saveDir, thinkingFilename);
      await this.writeOutputFile(thinking + "\n\n" + stats, saveDir, thinkingFilename);
      savedFilePaths.push(thinkingPath);
      this.emitOutput(`AI thinking process saved to: ${thinkingPath}\n`);
      
      return savedFilePaths;
    } catch (error) {
      console.error(`Error saving report:`, error);
      this.emitOutput(`Error saving report: ${error.message}\n`);
      throw error;
    }
  }
}

module.exports = LineEditing;

============================================================
FILE: main.js
SIZE: 46336 bytes
LANGUAGE: JS
============================================================

// main.js - Writer's Toolkit main process
const { app, BrowserWindow, Menu, ipcMain, dialog, screen } = require('electron');

// Handle Squirrel events
if (require('electron-squirrel-startup')) app.quit();

const path = require('path');
const fs = require('fs');
const os = require('os');

require('dotenv').config({ path: require('os').homedir() + '/.env' });

const { v4: uuidv4 } = require('uuid');
const appState = require('./state.js');
const toolSystem = require('./tool-system');
const fileCache = require('./file-cache');

let editorDialogWindow = null;

// Determine if we're running in packaged mode
const isPackaged = app.isPackaged || !process.defaultApp;

// Configure paths for packaged application
if (isPackaged) {
  console.log('Running in packaged mode');
  
  // Get the Resources path where our app is located
  const resourcesPath = path.join(app.getAppPath(), '..');
  console.log(`Resources path: ${resourcesPath}`);
  
  // Ensure the current working directory is correct
  try {
    // Set working directory to the app's root
    process.chdir(app.getAppPath());
    console.log(`Set working directory to: ${process.cwd()}`);
  } catch (error) {
    console.error('Failed to set working directory:', error);
  }
  
  // Explicitly expose the location of tools to global scope
  global.TOOLS_DIR = app.getAppPath();
  console.log(`Set global TOOLS_DIR to: ${global.TOOLS_DIR}`);
} else {
  console.log('Running in development mode');
  global.TOOLS_DIR = path.join(__dirname);
  console.log(`Set global TOOLS_DIR to: ${global.TOOLS_DIR}`);
}

// Only one whenReady that does everything in proper sequence
app.whenReady().then(() => {
  // 1. Set App User Model ID first
  app.setAppUserModelId("com.slipthetrap.writerstoolkit");
  
  // 2. Register DevTools shortcut
  const { globalShortcut } = require('electron');
  globalShortcut.register('CommandOrControl+Shift+I', () => {
    const focusedWindow = BrowserWindow.getFocusedWindow();
    if (focusedWindow) {
      focusedWindow.webContents.openDevTools();
    }
  });
  
  // 3. Initialize the app (replaces your existing main() function)
  initializeApp();
});

async function initializeApp() {
  try {
    // Initialize AppState before using it
    await appState.initialize();

    // Set up IPC handlers first
    setupIPCHandlers();

    // Initialize tool system with COMPLETE AI API settings
    try {
      // Get complete settings
      const completeSettings = getCompleteClaudeSettings();
      
      // Log the complete settings
      console.log('Initializing tool system with complete settings:');
      console.log(JSON.stringify(completeSettings, null, 2));
      
      // Initialize tool system with complete settings
      const toolSystemResult = await toolSystem.initializeToolSystem(completeSettings);

      // Check if API key is missing
      if (toolSystemResult.GeminiAPIService && toolSystemResult.GeminiAPIService.apiKeyMissing) {
        // Show notification after window is created
        setTimeout(() => {
          if (mainWindow && !mainWindow.isDestroyed()) {
            dialog.showMessageBox(mainWindow, {
              type: 'warning',
              title: 'API Key Missing',
              message: 'Gemini API key not found',
              detail: 'Please configure your Gemini API key in API Settings before using AI tools.',
              buttons: ['OK']
            });
          }
        }, 1000);
      }

    } catch (toolError) {
      console.error('>>> Warning: Tool system initialization failed:', toolError.message);
      // // Show error to user but don't crash the app
      // dialog.showErrorBox(
      //   'API Configuration Warning', 
      //   'Some Claude API settings may be missing. You can update them in Edit → API Settings.'
      // );
      // Don't swallow this error - re-throw it to prevent app from starting with broken tools
      throw toolError;
    }
    
    // Create the main window
    createWindow();
    
    // Check if a project is selected, if not, show the project dialog
    if (!appState.CURRENT_PROJECT && shouldShowProjectDialog) {
      // Give the main window time to load first
      setTimeout(() => {
        showProjectDialog();
      }, 500);
    }
  } catch (error) {
    console.error('Failed to initialize application:', error);
    app.quit();
  }
}

// In main.js, update the logToFile function to make it globally available
// Simple logging function that writes to a file in the user's home directory
function logToFile(message) {
  const logPath = path.join(os.homedir(), 'writers-toolkit-debug.log');
  const timestamp = new Date().toISOString();
  const logLine = `${timestamp}: ${message}\n`;
  
  try {
    fs.appendFileSync(logPath, logLine);
  } catch (e) {
    // Can't do anything if logging itself fails
  }
}

// Make logToFile available globally so other modules can use it
global.logToFile = logToFile;

// Log startup message
logToFile('=== APPLICATION STARTING ===');

// Catch all uncaught exceptions and log them
process.on('uncaughtException', (error) => {
  logToFile(`CRASH ERROR: ${error.message}`);
  logToFile(`STACK TRACE: ${error.stack}`);
  process.exit(1); // Exit with error code
});

// Log basic environment information
logToFile(`App executable: ${process.execPath}`);
logToFile(`Running in ${isPackaged ? 'packaged' : 'development'} mode`);
logToFile(`Current directory: ${process.cwd()}`);
logToFile(`__dirname: ${__dirname}`);
logToFile(`App path: ${app.getAppPath()}`);

// Log additional paths in packaged mode
if (isPackaged) {
  logToFile(`Resources path: ${path.join(app.getAppPath(), '..')}`);
}

// Define Gemini API schema globally
const GEMINI_API_SCHEMA = [
  { name: 'max_retries',            label: 'Max Retries',                       type: 'number', default: 1,       required: true,  description: 'Maximum retry attempts if an API call fails.' },
  { name: 'request_timeout',        label: 'Request Timeout (seconds)',         type: 'number', default: 300,     required: true,  description: 'Seconds to wait for the API to respond.' },
  { name: 'model_name',             label: 'Model Name',                        type: 'text',   default: 'gemini-2.5-pro-preview-05-06', required: true, description: 'Exact model identifier.' },
  { name: 'max_tokens',             label: 'Max Tokens',                   type: 'number', default: 128000,  required: true,  description: 'Absolute cap for output tokens.' }
];

// Global function to get complete settings 
function getCompleteClaudeSettings() {
  // Start with an empty settings object
  const completeSettings = {};
  
  // Add all default values from the schema
  GEMINI_API_SCHEMA.forEach(setting => {
    completeSettings[setting.name] = setting.default;
  });
  
  // Override with any existing user settings
  if (appState.settings_claude_api_configuration) {
    for (const key in appState.settings_claude_api_configuration) {
      completeSettings[key] = appState.settings_claude_api_configuration[key];
    }
  }
  
  return completeSettings;
}

// Store references to windows
let mainWindow = null;
let projectDialogWindow = null;
let apiSettingsWindow = null;
let toolSetupRunWindow = null;

// Flag to control whether to show the project dialog
let shouldShowProjectDialog = true;

// Store the currently selected tool
let currentTool = null;

// Set application name
app.name = "Writer's Toolkit";

// Define menu template
const menuTemplate = [
  {
    label: 'Writer\'s Toolkit',
    submenu: [
      { role: 'about' },
      { type: 'separator' },
      { role: 'quit' }
    ]
  },
  // Edit menu with standard operations
  {
    label: 'Edit',
    submenu: [
      { role: 'copy', accelerator: 'CmdOrCtrl+C' },
      { role: 'paste', accelerator: 'CmdOrCtrl+V' },
      { role: 'cut', accelerator: 'CmdOrCtrl+X' },
      { type: 'separator' },
      { role: 'selectAll', accelerator: 'CmdOrCtrl+A' },
    ]
  }
];
// Set the application menu
const menu = Menu.buildFromTemplate(menuTemplate);
Menu.setApplicationMenu(menu);
// cls: this removes the menu, but copy/paste fails:
// Menu.setApplicationMenu(null);

// Function to create project selection dialog
function createProjectDialog() {
  // Create the dialog window
  projectDialogWindow = new BrowserWindow({
    width: 600,
    height: 650,
    parent: mainWindow,
    modal: true,
    show: false,
    webPreferences: {
      nodeIntegration: false,
      contextIsolation: true,
      preload: path.join(__dirname, 'preload.js')
    },
    backgroundColor: '#121212', // Dark background
    autoHideMenuBar: true,
  });

  // Load the HTML file
  projectDialogWindow.loadFile(path.join(__dirname, 'project-dialog.html'));

  // Show the window when ready
  projectDialogWindow.once('ready-to-show', () => {
    projectDialogWindow.show();
  });

  // Track window destruction
  projectDialogWindow.on('closed', () => {
    projectDialogWindow = null;
  });
  
  return projectDialogWindow;
}

// Show the project dialog
function showProjectDialog() {
  if (!projectDialogWindow || projectDialogWindow.isDestroyed()) {
    createProjectDialog();
    
    // Pass the current theme to the dialog
    if (mainWindow) {
      mainWindow.webContents.executeJavaScript('document.body.classList.contains("light-mode")')
        .then(isLightMode => {
          if (projectDialogWindow && !projectDialogWindow.isDestroyed()) {
            projectDialogWindow.webContents.send('set-theme', isLightMode ? 'light' : 'dark');
          }
        })
        .catch(err => console.error('Error getting theme:', err));
    }
  } else {
    projectDialogWindow.show();
  }
}

function createWindow() {
  // Get the primary display's work area dimensions
  const primaryDisplay = screen.getPrimaryDisplay();
  const { width, height } = primaryDisplay.workAreaSize;
  console.log('*** Screen dimensions:', screen.getPrimaryDisplay().workAreaSize);  

  // Use 90% of the available width and height
  const windowWidth = Math.floor(width * 0.95);
  const windowHeight = Math.floor(height * 0.95);
  
  // Create the browser window
  mainWindow = new BrowserWindow({
    width: windowWidth,
    height: windowHeight,
    webPreferences: {
      nodeIntegration: false,
      contextIsolation: true,
      preload: path.join(__dirname, 'preload.js')
    },
    backgroundColor: '#111111', // Dark background
    autoHideMenuBar: false,
  });

  // Center the window
  mainWindow.center();

  // Load the index.html of the app
  mainWindow.loadFile(path.join(__dirname, 'index.html'));
}

// Setup handlers for project operations
function setupProjectHandlers() {
  // Get list of projects
  ipcMain.handle('get-projects', async () => {
    try {
      // Ensure projects directory exists
      await fs.promises.mkdir(appState.PROJECTS_DIR, { recursive: true });
      
      // List all directories in the projects folder
      const items = await fs.promises.readdir(appState.PROJECTS_DIR);
      
      // Filter to only include directories and exclude hidden directories
      const projects = [];
      for (const item of items) {
        if (item.startsWith('.')) {
          continue; // Skip hidden items
        }
        
        const itemPath = path.join(appState.PROJECTS_DIR, item);
        const stats = await fs.promises.stat(itemPath);
        if (stats.isDirectory()) {
          projects.push(item);
        }
      }
      
      return projects.sort(); // Sort alphabetically
    } catch (error) {
      console.error('Error listing projects:', error);
      return [];
    }
  });
  
  // Open an existing project
  ipcMain.handle('open-project', async (event, projectName) => {
    try {
      const projectPath = path.join(appState.PROJECTS_DIR, projectName);
      
      // Check if the project directory exists
      if (!fs.existsSync(projectPath)) {
        return {
          success: false,
          message: `Project directory does not exist: ${projectPath}`
        };
      }
      
      // Update application state
      appState.CURRENT_PROJECT = projectName;
      appState.CURRENT_PROJECT_PATH = projectPath;
      appState.DEFAULT_SAVE_DIR = projectPath;
      
      // Save to electron-store
      if (appState.store) {
        appState.store.set('settings', {
          default_save_dir: projectPath,
          current_project: projectName,
          current_project_path: projectPath
        });
      }
      
      return {
        success: true,
        projectPath
      };
    } catch (error) {
      console.error('Error opening project:', error);
      return {
        success: false,
        message: error.message
      };
    }
  });
  
  // Create a new project
  ipcMain.handle('create-project', async (event, projectName) => {
    try {
      const projectPath = path.join(appState.PROJECTS_DIR, projectName);
      
      // Check if the project already exists
      if (fs.existsSync(projectPath)) {
        return {
          success: false,
          message: `Project '${projectName}' already exists`
        };
      }
      
      // Create the project directory
      await fs.promises.mkdir(projectPath, { recursive: true });
      
      // Update application state
      appState.CURRENT_PROJECT = projectName;
      appState.CURRENT_PROJECT_PATH = projectPath;
      appState.DEFAULT_SAVE_DIR = projectPath;
      
      // Save to electron-store
      if (appState.store) {
        appState.store.set('settings', {
          default_save_dir: projectPath,
          current_project: projectName,
          current_project_path: projectPath
        });
      }

      return {
        success: true,
        projectPath
      };
    } catch (error) {
      console.error('Error creating project:', error);
      return {
        success: false,
        message: error.message
      };
    }
  });
}

// Function to create the tool setup and run dialog
function createToolSetupRunDialog(toolName) {
  // Create the dialog window
  toolSetupRunWindow = new BrowserWindow({
    width: mainWindow.getSize()[0],
    height: mainWindow.getSize()[1],
    x: mainWindow.getPosition()[0],
    y: mainWindow.getPosition()[1],
    parent: mainWindow,
    modal: true,
    show: false,
    webPreferences: {
      nodeIntegration: false,
      contextIsolation: true,
      preload: path.join(__dirname, 'preload.js')
    },
    backgroundColor: '#121212', // Dark background
    autoHideMenuBar: true,
  });

  // Load the HTML file
  toolSetupRunWindow.loadFile(path.join(__dirname, 'tool-setup-run.html'));

  // Show the window when ready
  toolSetupRunWindow.once('ready-to-show', () => {
    toolSetupRunWindow.show();
    
    // Send the current theme as soon as the window is ready
    if (mainWindow) {
      mainWindow.webContents.executeJavaScript('document.body.classList.contains("light-mode")')
        .then(isLightMode => {
          if (toolSetupRunWindow && !toolSetupRunWindow.isDestroyed()) {
            toolSetupRunWindow.webContents.send('set-theme', isLightMode ? 'light' : 'dark');
          }
        })
        .catch(err => console.error('Error getting theme:', err));
    }
  });

  // Track window destruction
  toolSetupRunWindow.on('closed', () => {
    toolSetupRunWindow = null;
  });
  
  // Prevent the tool window from being resized or moved
  toolSetupRunWindow.setResizable(false);
  toolSetupRunWindow.setMovable(false);
  
  return toolSetupRunWindow;
}

// Show the tool setup dialog - MODIFIED: always recreate the window
function showToolSetupRunDialog(toolName) {
  // Always close any existing tool window first
  if (toolSetupRunWindow && !toolSetupRunWindow.isDestroyed()) {
    toolSetupRunWindow.destroy();
    toolSetupRunWindow = null;
  }
  
  // Store the selected tool
  currentTool = toolName;
  console.log(`Creating new tool setup dialog for: ${toolName}`);
  
  // Create a new dialog window with the current tool
  createToolSetupRunDialog(toolName);
}

function launchEditor(fileToOpen = null) {
  return new Promise((resolve) => {
    try {
      createEditorDialog(fileToOpen);
      resolve(true);
    } catch (error) {
      console.error('Error launching editor:', error);
      if (typeof global.logToFile === 'function') {
        global.logToFile(`Error launching editor: ${error.message}`);
      }
      resolve(false);
    }
  });
}

// Handle opening files directly in the editor
ipcMain.handle('open-file-in-editor', async (event, filePath) => {
  try {
    // Verify the file exists
    if (!fs.existsSync(filePath)) {
      return { success: false, error: 'File not found: ' + filePath };
    }
    
    // Create editor dialog window
    createEditorDialog(filePath);
    
    // Return success
    return { success: true };
  } catch (error) {
    console.error('Error opening file in editor:', error);
    return { success: false, error: error.message };
  }
});

// Handle saving files from the editor dialog
ipcMain.handle('save-file', async (event, data) => {
  try {
    const { filePath, content, saveAs } = data;
    let finalPath = filePath;
    
    // If no path or saveAs is true, show save dialog
    if (!finalPath || saveAs) {
      try {
        // Get the current project path as the default save directory
        const projectPath = appState.CURRENT_PROJECT_PATH || path.join(os.homedir(), 'writing');
        
        const { canceled, filePath: newPath } = await dialog.showSaveDialog(editorDialogWindow, {
          title: 'Save File',
          defaultPath: projectPath,
          filters: [
            { name: 'Text Files', extensions: ['txt'] },
            { name: 'All Files', extensions: ['*'] }
          ]
        });
        
        if (canceled || !newPath) {
          return { success: false };
        }
        
        finalPath = newPath;
      } catch (error) {
        console.error('Error showing save dialog:', error);
        return { success: false };
      }
    }
    
    try {
      fs.writeFileSync(finalPath, content, 'utf8');
      console.log('File saved successfully to:', finalPath);
      return { success: true, filePath: finalPath };
    } catch (error) {
      console.error('Error saving file:', error);
      dialog.showErrorBox('Error', `Failed to save file: ${error.message}`);
      return { success: false };
    }
  } catch (error) {
    console.error('Error in save-file handler:', error);
    return { success: false };
  }
});

// Setup handlers for tool operations
function setupToolHandlers() {
  ipcMain.handle('get-tools', () => {
    // console.log('get-tools handler called');
    
    // Get all tool IDs
    const allToolIds = toolSystem.toolRegistry.getAllToolIds();
    // console.log(`Found ${allToolIds.length} tools in registry:`, allToolIds);
    // console.log('Raw tool IDs from registry:', allToolIds);
    
    // Map IDs to tool objects with required properties
    const tools = allToolIds.map(id => {
      const tool = toolSystem.toolRegistry.getTool(id);
      if (!tool) {
        console.error(`Tool with ID ${id} exists in registry but could not be retrieved`);
        throw new Error(`Tool with ID ${id} exists in registry but could not be retrieved`);
      }
      
      // Log each tool's properties
      // console.log(`Tool ${id} properties:`, {
      //   hasConfig: !!tool.config,
      //   title: tool.config?.title || 'missing',
      //   description: tool.config?.description || 'missing'
      // });

      // console.log(`>>> Tool ${id} description debugging:`, {
      //   'tool.config?.description': tool.config?.description,
      //   'tool.title': tool.config?.title
      // });      

      // Ensure tool has required properties
      return {
        name: id,
        title: tool.config?.title || id,
        description: tool.config?.description || tool.title || `Tool: ${id}`
      };
    });
    
    // console.log(`Returning ${tools.length} tools to renderer`);
    // console.log('Tool details being returned:', tools);
    return tools;
  });

  ipcMain.handle('get-tool-options', (e, toolName) => {
    const t = toolSystem.toolRegistry.getTool(toolName);
    return t ? (t.config.options || []) : [];
  });
  
  // Show tool setup dialog
  ipcMain.on('show-tool-setup-dialog', (event, toolName) => {
    showToolSetupRunDialog(toolName);
  });
  
  // Handle tool dialog closing
  ipcMain.on('close-tool-dialog', (event, action, data) => {
    if (toolSetupRunWindow && !toolSetupRunWindow.isDestroyed()) {
      toolSetupRunWindow.destroy();
      toolSetupRunWindow = null;
    }
  });
  
  // Get current tool
  ipcMain.handle('get-current-tool', () => {
    try {
      if (currentTool) {
        // Try to get from registry first
        const tool = toolSystem.toolRegistry.getTool(currentTool);
        if (tool) {
          return {
            name: currentTool,
            title: tool.config.title || currentTool,
            description: tool.config.description || ''
          };
        }
      }
      return null;
    } catch (error) {
      console.error('Error getting current tool:', error);
      return null;
    }
  });
  
  // When updating the start-tool-run handler:
  ipcMain.handle('start-tool-run', async (event, toolName, optionValues) => {
    try {
      // Generate a unique run ID
      const runId = uuidv4();
      
      // Set up output function
      const sendOutput = (text) => {
        if (toolSetupRunWindow && !toolSetupRunWindow.isDestroyed()) {
          toolSetupRunWindow.webContents.send('tool-output', { 
            runId, 
            text 
          });
        }
      };
      
      // Execute the tool in the background
      (async () => {
        try {
          // Send initial output notification
          sendOutput(`Starting ${toolName}...\n\n`);
          
          // Get the tool
          const tool = toolSystem.toolRegistry.getTool(toolName);
          
          if (!tool) {
            throw new Error(`Tool not found: ${toolName}`);
          }
          
          // Add output function to the tool
          tool.emitOutput = sendOutput;

          fileCache.clear(toolName);

          // Execute the tool
          const result = await toolSystem.executeToolById(toolName, optionValues, runId);
          
          // Get files from cache
          const cachedFiles = fileCache.getFiles(toolName);
          
          // Combine cached files with any files returned by the tool
          const allFiles = [...new Set([
            ...(result.outputFiles || []),
            ...cachedFiles.map(file => file.path)
          ])];
          
          // Send completion notification
          if (toolSetupRunWindow && !toolSetupRunWindow.isDestroyed()) {
            toolSetupRunWindow.webContents.send('tool-finished', { 
              runId, 
              code: 0, 
              createdFiles: allFiles 
            });
          }
        } catch (error) {
          console.error(`Error running tool ${toolName}:`, error);
          if (toolSetupRunWindow && !toolSetupRunWindow.isDestroyed()) {
            toolSetupRunWindow.webContents.send('tool-error', { 
              runId, 
              error: error.message 
            });
          }
        }
      })();
      
      return runId;
    } catch (error) {
      console.error('Error starting tool run:', error);
      throw error;
    }
  });
  
  // Store tool options in app state
  ipcMain.handle('set-tool-options', (event, options) => {
    try {
      appState.OPTION_VALUES = options;
      return true;
    } catch (error) {
      console.error('Error setting tool options:', error);
      return false;
    }
  });
}

// Function to create the API settings dialog
function createApiSettingsDialog() {
  // Create the dialog window
  apiSettingsWindow = new BrowserWindow({
    width: 600,
    height: 800,
    parent: mainWindow,
    modal: true,
    show: false,
    webPreferences: {
      nodeIntegration: false,
      contextIsolation: true,
      preload: path.join(__dirname, 'preload.js')
    },
    backgroundColor: '#121212', // Dark background
    autoHideMenuBar: true,
  });

  // Load the HTML file
  apiSettingsWindow.loadFile(path.join(__dirname, 'api-settings.html'));

  // Wait for the window to be ready before showing
  apiSettingsWindow.once('ready-to-show', () => {
    apiSettingsWindow.show();
    
    // Send the current theme as soon as the window is ready
    if (mainWindow) {
      mainWindow.webContents.executeJavaScript('document.body.classList.contains("light-mode")')
        .then(isLightMode => {
          if (apiSettingsWindow && !apiSettingsWindow.isDestroyed()) {
            apiSettingsWindow.webContents.send('set-theme', isLightMode ? 'light' : 'dark');
          }
        })
        .catch(err => console.error('Error getting theme:', err));
    }
  });

  // Track window destruction
  apiSettingsWindow.on('closed', () => {
    apiSettingsWindow = null;
  });
  
  return apiSettingsWindow;
}

// Show the API settings dialog
function showApiSettingsDialog() {
  if (!apiSettingsWindow || apiSettingsWindow.isDestroyed()) {
    createApiSettingsDialog();
  } else {
    apiSettingsWindow.show();
    
    // Re-apply the theme when showing an existing window
    if (mainWindow) {
      mainWindow.webContents.executeJavaScript('document.body.classList.contains("light-mode")')
        .then(isLightMode => {
          if (apiSettingsWindow && !apiSettingsWindow.isDestroyed()) {
            apiSettingsWindow.webContents.send('set-theme', isLightMode ? 'light' : 'dark');
          }
        })
        .catch(err => console.error('Error getting theme:', err));
    }
  }
}

function createEditorDialog(fileToOpen = null) {
  // If there's already an editor window open, close it first
  if (editorDialogWindow && !editorDialogWindow.isDestroyed()) {
    editorDialogWindow.destroy();
    editorDialogWindow = null;
  }

  // Get the parent window - either the tool window or main window
  const parentWindow = toolSetupRunWindow || mainWindow;

  editorDialogWindow = new BrowserWindow({
    width: parentWindow.getSize()[0],
    height: parentWindow.getSize()[1],
    x: parentWindow.getPosition()[0],
    y: parentWindow.getPosition()[1],
    parent: parentWindow,
    modal: true,
    show: false,
    webPreferences: {
      nodeIntegration: false,
      contextIsolation: true,
      preload: path.join(__dirname, 'preload.js'),
      // Enable clipboard operations without spellcheck
      additionalArguments: ['--enable-clipboard-read', '--enable-clipboard-write']
    },
    backgroundColor: '#121212', // Dark background
    autoHideMenuBar: true, // Hide the menu bar
  });

  // Load the HTML file
  editorDialogWindow.loadFile(path.join(__dirname, 'editor-dialog.html'));

  // Show the window when ready
  editorDialogWindow.once('ready-to-show', () => {
    editorDialogWindow.show();
    
    // Send the current theme as soon as the window is ready
    if (parentWindow) {
      parentWindow.webContents.executeJavaScript('document.body.classList.contains("light-mode")')
        .then(isLightMode => {
          if (editorDialogWindow && !editorDialogWindow.isDestroyed()) {
            editorDialogWindow.webContents.send('set-theme', isLightMode ? 'light' : 'dark');
          }
        })
        .catch(err => console.error('Error getting theme:', err));
    }
    
    // If a file should be opened, send it to the window
    if (fileToOpen) {
      try {
        const content = fs.readFileSync(fileToOpen, 'utf8');
        editorDialogWindow.webContents.send('file-opened', { 
          filePath: fileToOpen, 
          content 
        });
      } catch (error) {
        console.error('Error loading file:', error);
        dialog.showErrorBox('Error', `Failed to load file: ${error.message}`);
      }
    }
  });

  // Track window destruction
  editorDialogWindow.on('closed', () => {
    editorDialogWindow = null;
  });
  
  // Prevent the editor window from being resized or moved
  editorDialogWindow.setResizable(false);
  editorDialogWindow.setMovable(false);
  
  return editorDialogWindow;
}

// Prevent duplicate handler registration
let apiSettingsHandlersRegistered = false;

function setupApiSettingsHandlers() {
  // Skip if handlers are already registered
  if (apiSettingsHandlersRegistered) {
    return;
  }

  // API settings handlers
  ipcMain.handle('get-claude-api-settings', async () => {
    try {
      // Create complete settings from schema defaults and user settings
      const completeSettings = getCompleteClaudeSettings();
      
      // Update appState with the complete settings
      appState.settings_claude_api_configuration = completeSettings;
      
      // Save to store
      if (appState.store) {
        appState.store.set(
          'claude_api_configuration',
          completeSettings
        );
      }
      
      return {
        schema: GEMINI_API_SCHEMA,
        values: completeSettings
      };
    } catch (error) {
      console.error('Error getting Claude API settings:', error);
      return { success: false, message: error.message };
    }
  });

  ipcMain.handle('save-claude-api-settings', async (_event, settings) => {
    try {
      console.log('Saving Claude API settings:', settings);

      // Start with complete settings
      const completeSettings = getCompleteClaudeSettings();
      
      // Update with new values
      for (const key in settings) {
        completeSettings[key] = settings[key];
      }

      // Update appState with complete settings
      appState.settings_claude_api_configuration = completeSettings;
      
      // Save to store
      if (appState.store) {
        appState.store.set(
          'claude_api_configuration',
          completeSettings
        );
      }

      // Re‑instantiate the Claude service with complete settings
      toolSystem.reinitializeGeminiAPIService(completeSettings);

      // Log the complete configuration
      console.log('Complete Claude API configuration:');
      console.log(JSON.stringify(completeSettings, null, 2));

      return { success: true };
    } catch (error) {
      console.error('Error saving Claude API settings:', error);
      return { success: false, message: error.message };
    }
  });

  ipcMain.on('close-api-settings-dialog', (_event, action, data) => {
    if (apiSettingsWindow && !apiSettingsWindow.isDestroyed()) {
      apiSettingsWindow.hide();

      if (action === 'saved' && mainWindow && !mainWindow.isDestroyed()) {
        mainWindow.webContents.send('api-settings-updated', data);
      }
    }
  });
  
  // Mark that handlers have been registered
  apiSettingsHandlersRegistered = true;
}

// Set up all IPC handlers
function setupIPCHandlers() {
  setupProjectHandlers();
  setupToolHandlers();
  setupApiSettingsHandlers();
  
  // Handle quit request from renderer
  ipcMain.on('app-quit', () => {
    console.log('Quit requested from renderer');
    app.quit();
  });
  
  // Show project dialog
  ipcMain.on('show-project-dialog', () => {
    showProjectDialog();
  });
  
  // Show API settings dialog
  ipcMain.on('show-api-settings-dialog', () => {
    showApiSettingsDialog();
  });

  // Show editor dialog
  ipcMain.on('show-editor-dialog', (event, filePath) => {
    createEditorDialog(filePath);
  });
  
  // Close editor dialog
  ipcMain.on('close-editor-dialog', () => {
    if (editorDialogWindow && !editorDialogWindow.isDestroyed()) {
      editorDialogWindow.destroy();
      editorDialogWindow = null;
    }
  });

  // Handler for launching the text editor
  ipcMain.on('launch-editor', async (event) => {
    const result = await launchEditor();
    event.returnValue = result;
  });

  // Also add a handle version for Promise-based calls
  ipcMain.handle('launch-editor', async () => {
    return await launchEditor();
  });
  
  // Get current project info
  ipcMain.handle('get-project-info', () => {
    return {
      current_project: appState.CURRENT_PROJECT,
      current_project_path: appState.CURRENT_PROJECT_PATH
    };
  });
  
  // File selection dialog
  ipcMain.handle('select-file', async (event, options) => {
    try {
      // Ensure base directory is inside ~/writing
      const homePath = os.homedir();
      const writingPath = path.join(homePath, 'writing');
      let startPath = options.defaultPath || appState.DEFAULT_SAVE_DIR || writingPath;
      
      // Force path to be within ~/writing
      if (!startPath.startsWith(writingPath)) {
        startPath = writingPath;
      }
      
      // Set default filters to only show .txt files
      const defaultFilters = [
        { name: 'Text Files', extensions: ['txt'] },
        { name: 'All Files', extensions: ['*'] }
      ];
      
      // For tokens_words_counter.js, only allow .txt files
      if (currentTool === 'tokens_words_counter') {
        // Only use text files filter for this tool
        options.filters = [{ name: 'Text Files', extensions: ['txt', 'md'] }];
      }
      
      const dialogOptions = {
        title: options.title || 'Select File',
        defaultPath: startPath,
        buttonLabel: options.buttonLabel || 'Select',
        filters: options.filters || defaultFilters,
        properties: ['openFile'],
        // Restrict to ~/writing directory
        message: 'Please select a file within your writing projects'
      };
      
      const result = await dialog.showOpenDialog(
        options.parentWindow || toolSetupRunWindow || mainWindow, 
        dialogOptions
      );
      
      if (result.canceled || result.filePaths.length === 0) {
        return null;
      }
      
      const selectedPath = result.filePaths[0];
      
      // Verify the selected path is within ~/writing directory
      if (!selectedPath.startsWith(writingPath)) {
        console.warn('Selected file is outside allowed directory:', selectedPath);
        
        // Show error dialog to user
        await dialog.showMessageBox(toolSetupRunWindow || mainWindow, {
          type: 'error',
          title: 'Invalid File Selection',
          message: 'File Selection Restricted',
          detail: `You must select a file within the ~/writing directory. Please try again.`,
          buttons: ['OK']
        });
        
        return null;
      }
      
      return selectedPath;
    } catch (error) {
      console.error('Error in file selection:', error);
      throw error;
    }
  });
  
  // Directory selection dialog
  ipcMain.handle('select-directory', async (event, options) => {
    try {
      // Ensure base directory is inside ~/writing
      const homePath = os.homedir();
      const writingPath = path.join(homePath, 'writing');
      let startPath = options.defaultPath || appState.DEFAULT_SAVE_DIR || writingPath;
      
      // Force path to be within ~/writing
      if (!startPath.startsWith(writingPath)) {
        startPath = writingPath;
      }
      
      const dialogOptions = {
        title: options.title || 'Select Directory',
        defaultPath: startPath,
        buttonLabel: options.buttonLabel || 'Select',
        properties: ['openDirectory'],
        message: 'Please select a directory within your writing projects'
      };
      
      const result = await dialog.showOpenDialog(
        options.parentWindow || toolSetupRunWindow || mainWindow, 
        dialogOptions
      );
      
      if (result.canceled || result.filePaths.length === 0) {
        return null;
      }
      
      const selectedPath = result.filePaths[0];
      
      // Verify the selected path is within ~/writing directory
      if (!selectedPath.startsWith(writingPath)) {
        console.warn('Selected directory is outside allowed directory:', selectedPath);
        
        // Show error dialog to user
        await dialog.showMessageBox(toolSetupRunWindow || mainWindow, {
          type: 'error',
          title: 'Invalid Directory Selection',
          message: 'Directory Selection Restricted',
          detail: `You must select a directory within the ~/writing directory. Please try again.`,
          buttons: ['OK']
        });
        
        return null;
      }
      
      return selectedPath;
    } catch (error) {
      console.error('Error in directory selection:', error);
      throw error;
    }
  });
  
  // Handle project dialog closing
  ipcMain.on('close-project-dialog', (event, action, data) => {
    if (projectDialogWindow && !projectDialogWindow.isDestroyed()) {
      if (action === 'cancelled') {
        // For Cancel, disable auto-showing and destroy the window
        shouldShowProjectDialog = false;
        projectDialogWindow.destroy();
        projectDialogWindow = null;
      } else {
        // For other actions, just hide the window
        projectDialogWindow.hide();
        
        // If a project was selected or created, notify the main window
        if ((action === 'project-selected' || action === 'project-created') && 
            mainWindow && !mainWindow.isDestroyed()) {
          mainWindow.webContents.send('project-updated', {
            action,
            project: data
          });
        }
      }
    }
  });

  // Convert DOCX to TXT
  ipcMain.handle('convert-docx-to-txt', async (event, docxPath, outputFilename) => {
    try {
      // Ensure we have a current project
      if (!appState.CURRENT_PROJECT_PATH) {
        return {
          success: false,
          message: 'No active project selected'
        };
      }
      
      // Validate output filename
      if (!outputFilename) {
        outputFilename = 'manuscript.txt';
      }
      
      // Ensure it has a .txt extension
      if (!outputFilename.toLowerCase().endsWith('.txt')) {
        outputFilename += '.txt';
      }
      
      // Construct output path
      const outputPath = path.join(appState.CURRENT_PROJECT_PATH, outputFilename);
      
      // Use your existing DOCX to TXT conversion code
      const mammoth = require('mammoth');
      const jsdom = require('jsdom');
      const { JSDOM } = jsdom;
      
      // Load the docx file
      const result = await mammoth.convertToHtml({ path: docxPath });
      const htmlContent = result.value;
      
      // Parse the HTML
      const dom = new JSDOM(htmlContent);
      const document = dom.window.document;
      
      // Get all block elements
      const blocks = document.querySelectorAll("p, h1, h2, h3, h4, h5, h6");
      
      // Process blocks to extract chapters
      let chapters = [];
      let currentChapter = null;
      let ignoreFrontMatter = true;
      let ignoreRest = false;
      
      // Stop headings
      const STOP_TITLES = ["about the author", "website", "acknowledgments", "appendix"];
      
      // Convert NodeList to Array for iteration
      Array.from(blocks).forEach(block => {
        if (ignoreRest) return;
        
        const tagName = block.tagName.toLowerCase();
        const textRaw = block.textContent.trim();
        const textLower = textRaw.toLowerCase();
        
        // Skip everything until first <h1>
        if (ignoreFrontMatter) {
          if (tagName === "h1") {
            ignoreFrontMatter = false;
          } else {
            return;
          }
        }
        
        // If this heading is a "stop" heading, ignore the rest
        if (tagName.startsWith("h") && STOP_TITLES.some(title => textLower.startsWith(title))) {
          ignoreRest = true;
          return;
        }
        
        // If we see a new <h1>, that means a new chapter
        if (tagName === "h1") {
          currentChapter = {
            title: textRaw,
            textBlocks: []
          };
          chapters.push(currentChapter);
        }
        else {
          // If there's no current chapter yet, create one
          if (!currentChapter) {
            currentChapter = { title: "Untitled Chapter", textBlocks: [] };
            chapters.push(currentChapter);
          }
          // Add the block text if not empty
          if (textRaw) {
            currentChapter.textBlocks.push(textRaw);
          }
        }
      });
      
      // Build the manuscript text with proper spacing
      let manuscriptText = "";
      
      chapters.forEach((ch, idx) => {
        // Two newlines before each chapter title
        if (idx === 0) {
          manuscriptText += "\n\n";
        } else {
          manuscriptText += "\n\n\n";
        }
        
        // Add chapter title
        manuscriptText += ch.title;
        
        // One newline after chapter title
        manuscriptText += "\n\n";
        
        // Add paragraphs with one blank line between them
        manuscriptText += ch.textBlocks.join("\n\n");
      });
      
      // Write to output file
      await fs.promises.writeFile(outputPath, manuscriptText);
      
      return {
        success: true,
        outputPath: outputPath,
        outputFilename: outputFilename,
        chapterCount: chapters.length
      };
    } catch (error) {
      console.error('Error converting DOCX to TXT:', error);
      return {
        success: false,
        message: error.message || 'Failed to convert DOCX file'
      };
    }
  });
  // Convert TXT to DOCX - using minimal, version-compatible approach
  ipcMain.handle('convert-txt-to-docx', async (event, txtPath, outputFilename) => {
    try {
      // Ensure we have a current project
      if (!appState.CURRENT_PROJECT_PATH) {
        return {
          success: false,
          message: 'No active project selected'
        };
      }
      
      // Validate output filename
      if (!outputFilename) {
        outputFilename = 'manuscript.docx';
      }
      
      // Ensure it has a .docx extension
      if (!outputFilename.toLowerCase().endsWith('.docx')) {
        outputFilename += '.docx';
      }
      
      // Construct output path
      const outputPath = path.join(appState.CURRENT_PROJECT_PATH, outputFilename);
      
      // Read the txt file
      const textContent = await fs.promises.readFile(txtPath, 'utf8');
      
      // Import docx library
      const docx = require('docx');
      
      // Split text into paragraphs (separated by empty lines)
      const paragraphs = textContent.split(/\n\s*\n/).map(p => p.trim()).filter(p => p);
      
      // Simple function to check if a paragraph looks like a chapter heading
      function isChapterTitle(text) {
        // Common chapter title patterns
        return /^chapter\s+\d+/i.test(text) || // "Chapter X"
               /^chapter\s+[ivxlcdm]+/i.test(text) || // "Chapter IV"
               /^\d+[\.:]\s+/i.test(text); // "1: " or "1. "
      }

      // Create array of document content
      const children = [];
      let chapterCount = 0;
      
      // Process each paragraph
      paragraphs.forEach((paragraph, index) => {
        // Test if it's a chapter title
        if (isChapterTitle(paragraph)) {
          chapterCount++;
          
          // Add page break before chapters (except the first one)
          if (chapterCount > 1) {
            children.push(new docx.Paragraph({ pageBreakBefore: true }));
          }
          
          // Add chapter heading with proper formatting
          children.push(
            new docx.Paragraph({
              text: paragraph,
              heading: docx.HeadingLevel.HEADING_1,
              alignment: docx.AlignmentType.CENTER,
              spacing: { before: 240, after: 120 }
            })
          );
        } else {
          // Regular paragraph with first line indent
          children.push(
            new docx.Paragraph({
              text: paragraph,
              indent: { firstLine: 720 }, // 0.5 inch
              spacing: { line: 480 } // Double spacing
            })
          );
        }
      });

      // Create document with minimal options
      const doc = new docx.Document({
        sections: [
          {
            properties: {
              page: {
                margin: {
                  top: 1440, // 1 inch (1440 twips)
                  right: 1440, 
                  bottom: 1440,
                  left: 1440
                }
              }
            },
            children: children
          }
        ]
      });
      
      // Save the document
      const buffer = await docx.Packer.toBuffer(doc);
      await fs.promises.writeFile(outputPath, buffer);
      
      return {
        success: true,
        outputPath: outputPath,
        outputFilename: outputFilename,
        chapterCount: chapterCount,
        paragraphCount: paragraphs.length
      };
    } catch (error) {
      console.error('Error converting TXT to DOCX:', error);
      return {
        success: false,
        message: error.message || 'Failed to convert TXT file'
      };
    }
  });

  // Get output files for a tool run
  ipcMain.handle('get-tool-output-files', (event, toolId) => {
    try {
      // For simplicity, if toolId is a runId, we just use the tool name part
      // This assumes runIds are in the format toolName-uuid
      const toolName = toolId.includes('-') ? toolId.split('-')[0] : toolId;
      
      // Get files from the cache
      const fileCache = require('./file-cache');
      const files = fileCache.getFiles(toolName);
      
      return files;
    } catch (error) {
      console.error('Error getting tool output files:', error);
      return [];
    }
  });
}

// Quit when all windows are closed
app.on('window-all-closed', () => {
  // On macOS it is common for applications and their menu bar
  // to stay active until the user quits explicitly with Cmd + Q
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('activate', () => {
  // On macOS it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

app.on('before-quit', async (event) => {
  console.log('Application is quitting, cleaning up resources...');
  // Close any active Claude API clients
  for (const toolId of toolSystem.toolRegistry.getAllToolIds()) {
    const tool = toolSystem.toolRegistry.getTool(toolId);
    if (tool && tool.GeminiAPIService) {
      try {
        tool.GeminiAPIService.close();
      } catch (error) {
        // Ignore close errors during shutdown
      } finally {
        tool.GeminiAPIService = null;
      }
    }
  }
});


============================================================
FILE: manuscript-analyzer.js
SIZE: 11115 bytes
LANGUAGE: JS
============================================================

// Manuscript Analyzer with Claude API Token Counting
// This tool analyzes manuscripts to identify chapters and create optimal groupings for line editing

const fs = require('fs');
const path = require('path');

/**
 * Main function to analyze a manuscript file
 * @param {string} filePath - Path to the manuscript text file
 * @param {Object} GeminiAPIService - Claude API service instance
 * @param {number} maxChaptersPerGroup - Maximum chapters per group (default: 5)
 * @param {number} targetTokensPerGroup - Target tokens per group (default: 20000)
 * @returns {Promise<Object>} Analysis results
 */
async function analyzeManuscript(filePath, GeminiAPIService, maxChaptersPerGroup = 5, targetTokensPerGroup = 20000) {
    try {
        // Verify inputs
        if (!filePath || !fs.existsSync(filePath)) {
            throw new Error(`Manuscript file not found: ${filePath}`);
        }
        
        if (!GeminiAPIService) {
            throw new Error('Claude API service is required');
        }
        
        console.log(`Analyzing manuscript: ${filePath}`);
        
        // Read the manuscript file
        const text = fs.readFileSync(filePath, 'utf8');
        
        // Identify chapters in the manuscript
        const chapters = identifyChapters(text);
        console.log(`Identified ${chapters.length} chapters`);
        
        // Count words and tokens for each chapter
        const chaptersWithCounts = await countWordsAndTokens(chapters, GeminiAPIService);
        
        // Create suggested groupings
        const groupings = createChapterGroupings(chaptersWithCounts, maxChaptersPerGroup, targetTokensPerGroup);
        
        // Calculate totals
        const totalWords = chaptersWithCounts.reduce((sum, ch) => sum + ch.wordCount, 0);
        const totalTokens = chaptersWithCounts.reduce((sum, ch) => sum + ch.tokenCount, 0);
        const wordsPerToken = totalWords / totalTokens;
        
        // Return results
        return {
            totalChapters: chapters.length,
            totalWords,
            totalTokens,
            wordsPerToken: wordsPerToken.toFixed(2),
            chapters: chaptersWithCounts,
            suggestedGroupings: groupings
        };
    } catch (error) {
        console.error('Error analyzing manuscript:', error);
        throw error;
    }
}

/**
 * Identifies chapters in the manuscript text
 * @param {string} text - Full manuscript text
 * @returns {Array} Array of chapter objects
 */
function identifyChapters(text) {
    const chapters = [];
    
    // Common chapter patterns
    const patterns = [
        // "Chapter X" or "Chapter X: Title" or "Chapter X - Title"
        /Chapter\s+(\d+|[IVXLCDM]+|[A-Za-z]+)(?:\s*[:|\-|\s]\s*(.+?))?(?=\r?\n)/gi,
        
        // Just the number with a newline (e.g. "1\n" or "I.\n")
        /^(?:\s*)(\d+|[IVXLCDM]+)\.?(?:\s*)(.*?)(?=\r?\n)/gm,
    ];
    
    // Try each pattern to find chapter breaks
    let chapterMatches = [];
    for (const pattern of patterns) {
        pattern.lastIndex = 0;
        let match;
        while ((match = pattern.exec(text)) !== null) {
            chapterMatches.push({
                chapterNumber: match[1].trim(),
                title: match[2] ? match[2].trim() : '',
                index: match.index
            });
        }
        if (chapterMatches.length > 0) break;
    }
    
    // Sort matches by position in text
    chapterMatches.sort((a, b) => a.index - b.index);
    
    // Extract chapter content
    for (let i = 0; i < chapterMatches.length; i++) {
        const current = chapterMatches[i];
        const next = chapterMatches[i + 1];
        
        const startIndex = current.index;
        const endIndex = next ? next.index : text.length;
        const content = text.substring(startIndex, endIndex);
        
        chapters.push({
            number: i + 1,
            originalNumber: current.chapterNumber,
            title: current.title || '',
            content: content.trim()
        });
    }
    
    // If no chapters were found, treat the entire manuscript as a single chapter
    if (chapters.length === 0) {
        chapters.push({
            number: 1,
            originalNumber: '1',
            title: '',
            content: text.trim()
        });
    }
    
    return chapters;
}

/**
 * Counts words and tokens for each chapter
 * @param {Array} chapters - Array of chapter objects
 * @param {Object} GeminiAPIService - Claude API service
 * @returns {Promise<Array>} Chapters with word and token counts
 */
async function countWordsAndTokens(chapters, GeminiAPIService) {
    const updatedChapters = [];
    
    for (let i = 0; i < chapters.length; i++) {
        const chapter = chapters[i];
        
        // Count words
        const words = chapter.content.split(/\s+/).filter(w => w.length > 0);
        const wordCount = words.length;
        
        try {
            // Use Claude API to count tokens
            console.log(`Counting tokens for Chapter ${chapter.number}...`);
            const tokenCount = await GeminiAPIService.countTokens(chapter.content);
            console.log(`Chapter ${chapter.number}: ${wordCount} words, ${tokenCount} tokens`);
            
            updatedChapters.push({
                ...chapter,
                wordCount,
                tokenCount
            });
        } catch (error) {
            console.error(`Error counting tokens for Chapter ${chapter.number}:`, error);
            throw error;
        }
    }
    
    return updatedChapters;
}

/**
 * Creates optimal chapter groupings for line editing
 * @param {Array} chapters - Chapters with word and token counts
 * @param {number} maxChaptersPerGroup - Maximum chapters per group
 * @param {number} targetTokensPerGroup - Target tokens per group
 * @returns {Array} Suggested chapter groupings
 */
function createChapterGroupings(chapters, maxChaptersPerGroup, targetTokensPerGroup) {
    const groupings = [];
    let currentGroup = [];
    let currentTokens = 0;
    
    for (let i = 0; i < chapters.length; i++) {
        const chapter = chapters[i];
        
        // Check if we need to start a new group
        if ((currentGroup.length >= maxChaptersPerGroup) || 
            (currentTokens >= targetTokensPerGroup && currentGroup.length > 0)) {
            
            if (currentGroup.length > 0) {
                // Finalize the current group
                const firstChapter = currentGroup[0].number;
                const lastChapter = currentGroup[currentGroup.length - 1].number;
                
                groupings.push({
                    range: `${firstChapter}-${lastChapter}`,
                    chapters: currentGroup.map(c => c.number),
                    totalTokens: currentTokens,
                    totalWords: currentGroup.reduce((sum, ch) => sum + ch.wordCount, 0),
                    description: generateGroupDescription(currentGroup)
                });
                
                // Reset for next group
                currentGroup = [];
                currentTokens = 0;
            }
        }
        
        // Add chapter to current group
        currentGroup.push(chapter);
        currentTokens += chapter.tokenCount;
    }
    
    // Add any remaining chapters as the final group
    if (currentGroup.length > 0) {
        const firstChapter = currentGroup[0].number;
        const lastChapter = currentGroup[currentGroup.length - 1].number;
        
        groupings.push({
            range: `${firstChapter}-${lastChapter}`,
            chapters: currentGroup.map(c => c.number),
            totalTokens: currentTokens,
            totalWords: currentGroup.reduce((sum, ch) => sum + ch.wordCount, 0),
            description: generateGroupDescription(currentGroup)
        });
    }
    
    return groupings;
}

/**
 * Generates a description for a group of chapters
 * @param {Array} chapters - Chapter objects in the group
 * @returns {string} Group description
 */
function generateGroupDescription(chapters) {
    if (chapters.length === 1) {
        const ch = chapters[0];
        return `Chapter ${ch.number}${ch.title ? `: ${ch.title}` : ''} (${ch.wordCount} words, ${ch.tokenCount} tokens)`;
    } else {
        const firstCh = chapters[0];
        const lastCh = chapters[chapters.length - 1];
        const totalWords = chapters.reduce((sum, ch) => sum + ch.wordCount, 0);
        const totalTokens = chapters.reduce((sum, ch) => sum + ch.tokenCount, 0);
        return `Chapters ${firstCh.number}-${lastCh.number} (${totalWords} words, ${totalTokens} tokens)`;
    }
}

/**
 * Displays analysis results in a readable format
 * @param {Object} results - Analysis results
 */
function displayResults(results) {
    console.log(`\nManuscript Analysis:`);
    console.log(`Total Chapters: ${results.totalChapters}`);
    console.log(`Total Words: ${results.totalWords}`);
    console.log(`Total Tokens: ${results.totalTokens}`);
    console.log(`Words per token ratio: ${results.wordsPerToken}`);
    
    console.log(`\nChapters:`);
    results.chapters.forEach(ch => {
        console.log(`Chapter ${ch.number}${ch.title ? `: ${ch.title}` : ''} - ${ch.wordCount} words, ${ch.tokenCount} tokens`);
    });
    
    console.log(`\nSuggested Groupings for Line Editing:`);
    results.suggestedGroupings.forEach((group, idx) => {
        console.log(`Group ${idx + 1}: ${group.range} - ${group.totalTokens} tokens`);
        console.log(`  ${group.description}`);
    });
}

// Export functions for modules
module.exports = {
    analyzeManuscript,
    identifyChapters,
    countWordsAndTokens,
    createChapterGroupings,
    displayResults
};

// Command-line usage
if (require.main === module) {
    const manuscriptPath = process.argv[2];
    if (!manuscriptPath) {
        console.error('Error: Please provide a manuscript file path');
        console.error('Usage: node manuscript-analyzer.js path/to/manuscript.txt');
        process.exit(1);
    }
    
    // Import the Claude API Service
    const ClaudeAPIService = require('./client');
    
    // Create Claude service with the required configuration
    // Using the same configuration seen in your screenshot and error messages
    const GeminiAPIService = new ClaudeAPIService({
        max_retries: 3,
        request_timeout: 120,
        context_window: 200000,
        thinking_budget_tokens: 32000,
        betas_max_tokens: 128000,
        desired_output_tokens: 8000,
        model_name: 'claude-3-7-sonnet-20250219',
        // The 'extended_thinking' value was causing problems in your API call
        // Let's use an empty string to avoid issues
        betas: 'output-128k-2025-02-19',
        max_thinking_budget: 32000,
        max_tokens: 128000
    });
    
    // Run analysis
    analyzeManuscript(manuscriptPath, GeminiAPIService)
        .then(results => {
            displayResults(results);
            console.log('Analysis complete!');
        })
        .catch(err => {
            console.error('Analysis failed:', err.message);
            process.exit(1);
        });
}


============================================================
FILE: manuscript-extractor-tool.js
SIZE: 38343 bytes
LANGUAGE: JS
============================================================

// manuscript-extractor.js
const BaseTool = require('./base-tool');
const path = require('path');
const fileCache = require('./file-cache');
const appState = require('./state.js');
const fs = require('fs/promises');

/**
 * ManuscriptExtractor Tool
 * Analyzes an existing manuscript and extracts the outline, world elements, and character details
 * to help users transition into the Writer's Toolkit workflow with complete project files.
 */
class ManuscriptExtractor extends BaseTool {
  /**
   * Constructor
   * @param {Object} GeminiAPIService - Claude API service
   * @param {Object} config - Tool configuration
   */
  constructor(GeminiAPIService, config = {}) {
    super('manuscript_extractor', config);
    this.GeminiAPIService = GeminiAPIService;
  }
  
  /**
   * Execute the tool
   * @param {Object} options - Tool options
   * @returns {Promise<Object>} - Execution result
   */
  async execute(options) {
    console.log('Executing ManuscriptExtractor with options:', options);
    
    // Clear the cache for this tool
    const toolName = 'manuscript_extractor';
    fileCache.clear(toolName);
    
    // Extract options
    const manuscriptFile = options.manuscript_file;
    const title = options.title || this.extractTitleFromFileName(manuscriptFile);
    const genre = options.genre || '';
    const language = options.lang || 'English';
    const pov = options.pov || 'undetermined';
    const outlineLevel = options.outline_level || 'standard';
    const worldLevel = options.world_level || 'standard';
    const characterLevel = options.character_level || 'standard';
    const includeTimelineFile = options.include_timeline || false;
    
    const saveDir = options.save_dir || appState.CURRENT_PROJECT_PATH;
    const outputFiles = [];
    
    // Validate save directory
    if (!saveDir) {
      const errorMsg = 'Error: No save directory specified and no current project selected.\n' +
                      'Please select a project or specify a save directory.';
      this.emitOutput(errorMsg);
      throw new Error('No save directory available');
    }
    
    // Ensure file paths are absolute
    const absoluteManuscriptFile = this.ensureAbsolutePath(manuscriptFile, saveDir);
    
    try {
      // Read the manuscript file
      this.emitOutput(`Reading manuscript file: ${absoluteManuscriptFile}\n`);
      const manuscriptContent = await this.readInputFile(absoluteManuscriptFile);
      
      // Generate outline, world, and characters files
      this.emitOutput(`\nAnalyzing manuscript to extract project files...\n`);
      this.emitOutput(`Title: ${title}\n`);
      if (genre) this.emitOutput(`Genre: ${genre}\n`);
      this.emitOutput(`Language: ${language}\n`);
      this.emitOutput(`POV: ${pov}\n`);
      
      // Process each file type in sequence
      const outlineFile = await this.generateOutline(
        title, 
        genre, 
        manuscriptContent, 
        language, 
        outlineLevel, 
        saveDir
      );
      outputFiles.push(...outlineFile);
      
      const characterFile = await this.generateCharacters(
        title, 
        genre, 
        manuscriptContent, 
        language, 
        characterLevel, 
        saveDir
      );
      outputFiles.push(...characterFile);
      
      const worldFile = await this.generateWorld(
        title, 
        genre, 
        pov,
        manuscriptContent, 
        language, 
        worldLevel, 
        saveDir
      );
      outputFiles.push(...worldFile);
      
      // Generate timeline if requested
      if (includeTimelineFile) {
        const timelineFile = await this.generateTimeline(
          title, 
          genre, 
          manuscriptContent, 
          language, 
          saveDir
        );
        outputFiles.push(...timelineFile);
      }
      
      // Add all files to the cache
      for (const file of outputFiles) {
        fileCache.addFile(toolName, file);
      }
      
      // Display final message
      this.emitOutput(`\nExtraction complete! Generated files:\n`);
      outputFiles.forEach(file => {
        this.emitOutput(`- ${path.basename(file)}\n`);
      });
      
      // Return the result
      return {
        success: true,
        outputFiles,
        stats: {
          extractedFiles: outputFiles.length
        }
      };
      
    } catch (error) {
      console.error('Error in ManuscriptExtractor:', error);
      this.emitOutput(`\nError: ${error.message}\n`);
      throw error;
    }
  }
  
  /**
   * Extract title from filename
   * @param {string} filename - Manuscript filename
   * @returns {string} - Extracted title
   */
  extractTitleFromFileName(filename) {
    if (!filename) return 'Untitled Manuscript';
    
    const baseName = path.basename(filename, path.extname(filename));
    
    // Convert snake_case or kebab-case to Title Case
    const title = baseName
      .replace(/[_-]/g, ' ')
      .replace(/\b\w/g, l => l.toUpperCase());
    
    return title;
  }
  
  /**
   * Generate outline file
   * @param {string} title - Title
   * @param {string} genre - Genre
   * @param {string} manuscriptContent - Manuscript content
   * @param {string} language - Language
   * @param {string} outlineLevel - Detail level (basic, standard, detailed)
   * @param {string} saveDir - Directory to save output
   * @returns {Promise<string[]>} - Paths to saved files
   */
  async generateOutline(
    title,
    genre,
    manuscriptContent,
    language,
    outlineLevel,
    saveDir
  ) {
    this.emitOutput(`\n=== Generating outline.txt ===\n`);
    
    // Create prompt for outline extraction
    const prompt = this.createOutlineExtractionPrompt(
      title,
      genre,
      manuscriptContent,
      language,
      outlineLevel
    );
    
    // Count tokens in prompt
    this.emitOutput(`Counting tokens in prompt...\n`);
    const promptTokens = await this.GeminiAPIService.countTokens(prompt);
    
    // Calculate available tokens
    const tokenBudgets = this.GeminiAPIService.calculateTokenBudgets(promptTokens);
    
    // Display token stats
    this.emitOutput(`\nToken stats for outline extraction:\n`);
    this.emitOutput(`Input prompt tokens: [${tokenBudgets.promptTokens}]\n`);
    this.emitOutput(`Available tokens: [${tokenBudgets.availableTokens}]\n`);
    this.emitOutput(`AI model thinking budget: [${tokenBudgets.thinkingBudget}] tokens\n`);
    
    // Check if prompt is too large
    if (tokenBudgets.isPromptTooLarge) {
      this.emitOutput(`Error: prompt is too large for the configured thinking budget!\n`);
      throw new Error(`Prompt is too large for outline extraction - consider reducing manuscript size`);
    }
    
    // Call Claude API with streaming
    this.emitOutput(`Sending request to Claude API (streaming)...\n`);
    
    // Add a waiting message
    this.emitOutput(`****************************************************************************\n`);
    this.emitOutput(`*  Analyzing manuscript structure and extracting outline...                \n`);
    this.emitOutput(`*  This process typically takes several minutes.                           \n`);
    this.emitOutput(`****************************************************************************\n\n`);
    
    const startTime = Date.now();
    let fullResponse = "";
    let thinkingContent = "";
    
    // Create system prompt
    const systemPrompt = "NO Markdown! Never respond with Markdown formatting, plain text only.";
    
    try {
      // Use streaming API call
      await this.GeminiAPIService.streamWithThinking(
        prompt,
        {
          system: systemPrompt,
          max_tokens: tokenBudgets.maxTokens,
          thinking: {
            type: "enabled",
            budget_tokens: tokenBudgets.thinkingBudget
          },
          betas: ["output-128k-2025-02-19"]
        },
        // Callback for thinking content
        (thinkingDelta) => {
          thinkingContent += thinkingDelta;
        },
        // Callback for response text
        (textDelta) => {
          fullResponse += textDelta;
        }
      );
    } catch (error) {
      this.emitOutput(`\nAPI Error: ${error.message}\n`);
      throw error;
    }
    
    // Calculate elapsed time
    const elapsed = (Date.now() - startTime) / 1000;
    const minutes = Math.floor(elapsed / 60);
    const seconds = elapsed % 60;
    
    this.emitOutput(`Outline extraction completed in ${minutes}m ${seconds.toFixed(2)}s.\n`);
    
    // Count words in response
    const wordCount = this.countWords(fullResponse);
    
    // Count tokens in response
    const responseTokens = await this.GeminiAPIService.countTokens(fullResponse);
    
    // Save the outline to a file
    const outlineFilename = 'outline.txt';
    const outlinePath = path.join(saveDir, outlineFilename);
    
    await this.writeOutputFile(fullResponse, saveDir, outlineFilename);
    this.emitOutput(`Outline saved to: ${outlinePath}\n`);
    
    // Save thinking content if available and not skipped
    const outputFiles = [outlinePath];
    
    if (thinkingContent) {
      const timestamp = new Date().toISOString().replace(/[-:.]/g, '').substring(0, 15);
      const thinkingFilename = `outline_thinking_${timestamp}.txt`;
      
      // Create stats
      const stats = `
Stats:
Prompt tokens: ${promptTokens}
Elapsed time: ${minutes} minutes, ${seconds.toFixed(2)} seconds
Word count: ${wordCount}
Token count: ${responseTokens}
`;
      
      const thinkingContent2 = `=== OUTLINE EXTRACTION FROM MANUSCRIPT ===

=== AI'S THINKING PROCESS ===

${thinkingContent}

=== END AI'S THINKING PROCESS ===
${stats}`;
      
      await this.writeOutputFile(thinkingContent2, saveDir, thinkingFilename);
      const thinkingPath = path.join(saveDir, thinkingFilename);
      this.emitOutput(`AI thinking saved to: ${thinkingPath}\n`);
      
      outputFiles.push(thinkingPath);
    }
    
    return outputFiles;
  }
  
  /**
   * Generate characters file
   * @param {string} title - Title
   * @param {string} genre - Genre
   * @param {string} manuscriptContent - Manuscript content
   * @param {string} language - Language
   * @param {string} characterLevel - Detail level (basic, standard, detailed)
   * @param {string} saveDir - Directory to save output
   * @returns {Promise<string[]>} - Paths to saved files
   */
  async generateCharacters(
    title,
    genre,
    manuscriptContent,
    language,
    characterLevel,
    saveDir
  ) {
    this.emitOutput(`\n=== Generating characters.txt ===\n`);
    
    // Create prompt for character extraction
    const prompt = this.createCharacterExtractionPrompt(
      title,
      genre,
      manuscriptContent,
      language,
      characterLevel
    );
    
    // Count tokens in prompt
    this.emitOutput(`Counting tokens in prompt...\n`);
    const promptTokens = await this.GeminiAPIService.countTokens(prompt);
    
    // Calculate available tokens
    const tokenBudgets = this.GeminiAPIService.calculateTokenBudgets(promptTokens);
    
    // Display token stats
    this.emitOutput(`\nToken stats for character extraction:\n`);
    this.emitOutput(`Input prompt tokens: [${tokenBudgets.promptTokens}]\n`);
    this.emitOutput(`Available tokens: [${tokenBudgets.availableTokens}]\n`);
    this.emitOutput(`AI model thinking budget: [${tokenBudgets.thinkingBudget}] tokens\n`);
    
    // Check if prompt is too large
    if (tokenBudgets.isPromptTooLarge) {
      this.emitOutput(`Error: prompt is too large for the configured thinking budget!\n`);
      throw new Error(`Prompt is too large for character extraction - consider reducing manuscript size`);
    }
    
    // Call Claude API with streaming
    this.emitOutput(`Sending request to Claude API (streaming)...\n`);
    
    // Add a waiting message
    this.emitOutput(`****************************************************************************\n`);
    this.emitOutput(`*  Analyzing manuscript and extracting character profiles...               \n`);
    this.emitOutput(`*  This process typically takes several minutes.                           \n`);
    this.emitOutput(`****************************************************************************\n\n`);
    
    const startTime = Date.now();
    let fullResponse = "";
    let thinkingContent = "";
    
    // Create system prompt
    const systemPrompt = "NO Markdown! Never respond with Markdown formatting, plain text only.";
    
    try {
      // Use streaming API call
      await this.GeminiAPIService.streamWithThinking(
        prompt,
        {
          system: systemPrompt,
          max_tokens: tokenBudgets.maxTokens,
          thinking: {
            type: "enabled",
            budget_tokens: tokenBudgets.thinkingBudget
          },
          betas: ["output-128k-2025-02-19"]
        },
        // Callback for thinking content
        (thinkingDelta) => {
          thinkingContent += thinkingDelta;
        },
        // Callback for response text
        (textDelta) => {
          fullResponse += textDelta;
        }
      );
    } catch (error) {
      this.emitOutput(`\nAPI Error: ${error.message}\n`);
      throw error;
    }
    
    // Calculate elapsed time
    const elapsed = (Date.now() - startTime) / 1000;
    const minutes = Math.floor(elapsed / 60);
    const seconds = elapsed % 60;
    
    this.emitOutput(`Character extraction completed in ${minutes}m ${seconds.toFixed(2)}s.\n`);
    
    // Count words in response
    const wordCount = this.countWords(fullResponse);
    
    // Count tokens in response
    const responseTokens = await this.GeminiAPIService.countTokens(fullResponse);
    
    // Save the characters to a file
    const charactersFilename = 'characters.txt';
    const charactersPath = path.join(saveDir, charactersFilename);
    
    await this.writeOutputFile(fullResponse, saveDir, charactersFilename);
    this.emitOutput(`Characters saved to: ${charactersPath}\n`);
    
    // Save thinking content if available and not skipped
    const outputFiles = [charactersPath];
    
    if (thinkingContent) {
      const timestamp = new Date().toISOString().replace(/[-:.]/g, '').substring(0, 15);
      const thinkingFilename = `characters_thinking_${timestamp}.txt`;
      
      // Create stats
      const stats = `
Stats:
Prompt tokens: ${promptTokens}
Elapsed time: ${minutes} minutes, ${seconds.toFixed(2)} seconds
Word count: ${wordCount}
Token count: ${responseTokens}
`;
      
      const thinkingContent2 = `=== CHARACTER EXTRACTION FROM MANUSCRIPT ===

=== AI'S THINKING PROCESS ===

${thinkingContent}

=== END AI'S THINKING PROCESS ===
${stats}`;
      
      await this.writeOutputFile(thinkingContent2, saveDir, thinkingFilename);
      const thinkingPath = path.join(saveDir, thinkingFilename);
      this.emitOutput(`AI thinking saved to: ${thinkingPath}\n`);
      
      outputFiles.push(thinkingPath);
    }
    
    return outputFiles;
  }
  
  /**
   * Generate world file
   * @param {string} title - Title
   * @param {string} genre - Genre
   * @param {string} pov - Point of view
   * @param {string} manuscriptContent - Manuscript content
   * @param {string} language - Language
   * @param {string} worldLevel - Detail level (basic, standard, detailed)
   * @param {string} saveDir - Directory to save output
   * @returns {Promise<string[]>} - Paths to saved files
   */
  async generateWorld(
    title,
    genre,
    pov,
    manuscriptContent,
    language,
    worldLevel,
    saveDir
  ) {
    this.emitOutput(`\n=== Generating world.txt ===\n`);
    
    // Create prompt for world extraction
    const prompt = this.createWorldExtractionPrompt(
      title,
      genre,
      pov,
      manuscriptContent,
      language,
      worldLevel
    );
    
    // Count tokens in prompt
    this.emitOutput(`Counting tokens in prompt...\n`);
    const promptTokens = await this.GeminiAPIService.countTokens(prompt);
    
    // Calculate available tokens
    const tokenBudgets = this.GeminiAPIService.calculateTokenBudgets(promptTokens);
    
    // Display token stats
    this.emitOutput(`\nToken stats for world extraction:\n`);
    this.emitOutput(`Input prompt tokens: [${tokenBudgets.promptTokens}]\n`);
    this.emitOutput(`Available tokens: [${tokenBudgets.availableTokens}]\n`);
    this.emitOutput(`AI model thinking budget: [${tokenBudgets.thinkingBudget}] tokens\n`);
    
    // Check if prompt is too large
    if (tokenBudgets.isPromptTooLarge) {
      this.emitOutput(`Error: prompt is too large for the configured thinking budget!\n`);
      throw new Error(`Prompt is too large for world extraction - consider reducing manuscript size`);
    }
    
    // Call Claude API with streaming
    this.emitOutput(`Sending request to Claude API (streaming)...\n`);
    
    // Add a waiting message
    this.emitOutput(`****************************************************************************\n`);
    this.emitOutput(`*  Analyzing manuscript and extracting world elements...                   \n`);
    this.emitOutput(`*  This process typically takes several minutes.                           \n`);
    this.emitOutput(`****************************************************************************\n\n`);
    
    const startTime = Date.now();
    let fullResponse = "";
    let thinkingContent = "";
    
    // Create system prompt
    const systemPrompt = "NO Markdown! Never respond with Markdown formatting, plain text only.";
    
    try {
      // Use streaming API call
      await this.GeminiAPIService.streamWithThinking(
        prompt,
        {
          system: systemPrompt,
          max_tokens: tokenBudgets.maxTokens,
          thinking: {
            type: "enabled",
            budget_tokens: tokenBudgets.thinkingBudget
          },
          betas: ["output-128k-2025-02-19"]
        },
        // Callback for thinking content
        (thinkingDelta) => {
          thinkingContent += thinkingDelta;
        },
        // Callback for response text
        (textDelta) => {
          fullResponse += textDelta;
        }
      );
    } catch (error) {
      this.emitOutput(`\nAPI Error: ${error.message}\n`);
      throw error;
    }
    
    // Calculate elapsed time
    const elapsed = (Date.now() - startTime) / 1000;
    const minutes = Math.floor(elapsed / 60);
    const seconds = elapsed % 60;
    
    this.emitOutput(`World extraction completed in ${minutes}m ${seconds.toFixed(2)}s.\n`);
    
    // Count words in response
    const wordCount = this.countWords(fullResponse);
    
    // Count tokens in response
    const responseTokens = await this.GeminiAPIService.countTokens(fullResponse);
    
    // Save the world to a file
    const worldFilename = 'world.txt';
    const worldPath = path.join(saveDir, worldFilename);
    
    await this.writeOutputFile(fullResponse, saveDir, worldFilename);
    this.emitOutput(`World document saved to: ${worldPath}\n`);
    
    // Save thinking content if available and not skipped
    const outputFiles = [worldPath];
    
    if (thinkingContent) {
      const timestamp = new Date().toISOString().replace(/[-:.]/g, '').substring(0, 15);
      const thinkingFilename = `world_thinking_${timestamp}.txt`;
      
      // Create stats
      const stats = `
Stats:
Prompt tokens: ${promptTokens}
Elapsed time: ${minutes} minutes, ${seconds.toFixed(2)} seconds
Word count: ${wordCount}
Token count: ${responseTokens}
`;
      
      const thinkingContent2 = `=== WORLD EXTRACTION FROM MANUSCRIPT ===

=== AI'S THINKING PROCESS ===

${thinkingContent}

=== END AI'S THINKING PROCESS ===
${stats}`;
      
      await this.writeOutputFile(thinkingContent2, saveDir, thinkingFilename);
      const thinkingPath = path.join(saveDir, thinkingFilename);
      this.emitOutput(`AI thinking saved to: ${thinkingPath}\n`);
      
      outputFiles.push(thinkingPath);
    }
    
    return outputFiles;
  }
  
  /**
   * Generate timeline file
   * @param {string} title - Title
   * @param {string} genre - Genre
   * @param {string} manuscriptContent - Manuscript content
   * @param {string} language - Language
   * @param {string} saveDir - Directory to save output
   * @returns {Promise<string[]>} - Paths to saved files
   */
  async generateTimeline(
    title,
    genre,
    manuscriptContent,
    language,
    saveDir
  ) {
    this.emitOutput(`\n=== Generating timeline.txt ===\n`);
    
    // Create prompt for timeline extraction
    const prompt = this.createTimelineExtractionPrompt(
      title,
      genre,
      manuscriptContent,
      language
    );
    
    // Count tokens in prompt
    this.emitOutput(`Counting tokens in prompt...\n`);
    const promptTokens = await this.GeminiAPIService.countTokens(prompt);
    
    // Calculate available tokens
    const tokenBudgets = this.GeminiAPIService.calculateTokenBudgets(promptTokens);
    
    // Display token stats
    this.emitOutput(`\nToken stats for timeline extraction:\n`);
    this.emitOutput(`Input prompt tokens: [${tokenBudgets.promptTokens}]\n`);
    this.emitOutput(`Available tokens: [${tokenBudgets.availableTokens}]\n`);
    this.emitOutput(`AI model thinking budget: [${tokenBudgets.thinkingBudget}] tokens\n`);
    
    // Check if prompt is too large
    if (tokenBudgets.isPromptTooLarge) {
      this.emitOutput(`Error: prompt is too large for the configured thinking budget!\n`);
      throw new Error(`Prompt is too large for timeline extraction - consider reducing manuscript size`);
    }
    
    // Call Claude API with streaming
    this.emitOutput(`Sending request to Claude API (streaming)...\n`);
    
    // Add a waiting message
    this.emitOutput(`****************************************************************************\n`);
    this.emitOutput(`*  Analyzing manuscript chronology and creating timeline...                \n`);
    this.emitOutput(`*  This process typically takes several minutes.                           \n`);
    this.emitOutput(`****************************************************************************\n\n`);
    
    const startTime = Date.now();
    let fullResponse = "";
    let thinkingContent = "";
    
    // Create system prompt
    const systemPrompt = "NO Markdown! Never respond with Markdown formatting, plain text only.";
    
    try {
      // Use streaming API call
      await this.GeminiAPIService.streamWithThinking(
        prompt,
        {
          system: systemPrompt,
          max_tokens: tokenBudgets.maxTokens,
          thinking: {
            type: "enabled",
            budget_tokens: tokenBudgets.thinkingBudget
          },
          betas: ["output-128k-2025-02-19"]
        },
        // Callback for thinking content
        (thinkingDelta) => {
          thinkingContent += thinkingDelta;
        },
        // Callback for response text
        (textDelta) => {
          fullResponse += textDelta;
        }
      );
    } catch (error) {
      this.emitOutput(`\nAPI Error: ${error.message}\n`);
      throw error;
    }
    
    // Calculate elapsed time
    const elapsed = (Date.now() - startTime) / 1000;
    const minutes = Math.floor(elapsed / 60);
    const seconds = elapsed % 60;
    
    this.emitOutput(`Timeline extraction completed in ${minutes}m ${seconds.toFixed(2)}s.\n`);
    
    // Count words in response
    const wordCount = this.countWords(fullResponse);
    
    // Count tokens in response
    const responseTokens = await this.GeminiAPIService.countTokens(fullResponse);
    
    // Save the timeline to a file
    const timelineFilename = 'timeline.txt';
    const timelinePath = path.join(saveDir, timelineFilename);
    
    await this.writeOutputFile(fullResponse, saveDir, timelineFilename);
    this.emitOutput(`Timeline saved to: ${timelinePath}\n`);
    
    // Save thinking content if available and not skipped
    const outputFiles = [timelinePath];
    
    if (thinkingContent) {
      const timestamp = new Date().toISOString().replace(/[-:.]/g, '').substring(0, 15);
      const thinkingFilename = `timeline_thinking_${timestamp}.txt`;
      
      // Create stats
      const stats = `
Stats:
Prompt tokens: ${promptTokens}
Elapsed time: ${minutes} minutes, ${seconds.toFixed(2)} seconds
Word count: ${wordCount}
Token count: ${responseTokens}
`;
      
      const thinkingContent2 = `=== TIMELINE EXTRACTION FROM MANUSCRIPT ===

=== AI'S THINKING PROCESS ===

${thinkingContent}

=== END AI'S THINKING PROCESS ===
${stats}`;
      
      await this.writeOutputFile(thinkingContent2, saveDir, thinkingFilename);
      const thinkingPath = path.join(saveDir, thinkingFilename);
      this.emitOutput(`AI thinking saved to: ${thinkingPath}\n`);
      
      outputFiles.push(thinkingPath);
    }
    
    return outputFiles;
  }
  
  /**
   * Create outline extraction prompt
   * @param {string} title - Title of manuscript
   * @param {string} genre - Genre of manuscript
   * @param {string} manuscriptContent - Content of manuscript
   * @param {string} language - Language of manuscript
   * @param {string} outlineLevel - Level of detail (basic, standard, detailed)
   * @returns {string} - Prompt for Claude API
   */
  createOutlineExtractionPrompt(
    title,
    genre,
    manuscriptContent,
    language,
    outlineLevel = "standard"
  ) {
    // Genre inclusion
    const genreText = genre ? `Genre: ${genre}` : 'Please determine the most appropriate genre.';
    
    // Detail level instructions
    const detailInstructions = {
      basic: `
Create a basic outline with:
- 3-5 major parts or acts
- Limited to 15-20 chapters total 
- Brief 1-2 sentence chapter descriptions
- Focus only on the main plot arc`,
      
      standard: `
Create a standard outline with:
- 3-5 major parts or acts
- 20-30 chapters total
- 3-4 bullet points per chapter describing key events
- Include main plot and significant subplots`,
      
      detailed: `
Create a detailed outline with:
- 3-7 major parts or acts
- 25-40 chapters total
- 5-7 bullet points per chapter with detailed scene descriptions
- Include main plot, all subplots, and character arcs
- Note important thematic developments within chapters`
    };
    
    // Select appropriate detail level
    const detailLevel = detailInstructions[outlineLevel] || detailInstructions.standard;
    
    return `=== MANUSCRIPT ===
${manuscriptContent}
=== END MANUSCRIPT ===

You are a skilled story editor and narrative architect helping to extract a comprehensive, well-structured outline from an existing manuscript written in ${language}.

Task: Create an outline document for the novel: "${title}"
${genreText}

${detailLevel}

IMPORTANT FORMATTING INSTRUCTIONS:
1. DO NOT use Markdown formatting (no #, ##, ###, *, **, etc.)
2. Start with "OUTLINE:" followed by the novel title on the next line
3. For parts/sections, use plain text like: "PART I: THE BEGINNING"
4. For chapters, use ONLY simple numbering like: "1. Chapter Title" (no "Chapter" word, just the number and title)
5. Format each bullet point starting with "- " (dash followed by space)
6. Each bullet point should describe a single key event, character moment, or plot development
7. Make bullet points substantive but concise, focusing on important elements
8. Include a brief epilogue section at the end if applicable

The outline should accurately reflect the existing manuscript's structure, timeline, and content. Use actual chapter divisions from the manuscript when possible. Create appropriate chapter titles that capture the essence of each section.

This outline will be saved as 'outline.txt' and used for further development and analysis of the novel, so ensure it provides a complete map of the story.`;
  }
  
  /**
   * Create character extraction prompt
   * @param {string} title - Title of manuscript
   * @param {string} genre - Genre of manuscript
   * @param {string} manuscriptContent - Content of manuscript
   * @param {string} language - Language of manuscript
   * @param {string} characterLevel - Level of detail (basic, standard, detailed)
   * @returns {string} - Prompt for Claude API
   */
  createCharacterExtractionPrompt(
    title,
    genre,
    manuscriptContent,
    language,
    characterLevel = "standard"
  ) {
    // Genre inclusion
    const genreText = genre ? `Genre: ${genre}` : '';
    
    // Detail level instructions
    const detailInstructions = {
      basic: `
Extract basic character information including:
- Character name and role
- Basic physical description
- Core personality traits
- Primary relationships
- Main goal or motivation
Focus only on main and important secondary characters (5-8 characters total).`,
      
      standard: `
Extract standard character information including:
- Character name and role
- Physical description (age, appearance, distinctive features)
- Personality traits, strengths, and flaws
- Background and key history
- Relationships with other characters
- Goals, motivations, and conflicts
- Character arc across the story
Include all main characters, important secondary characters, and notable minor characters (8-15 characters total).`,
      
      detailed: `
Extract detailed character information including:
- Character name, role, and significance
- Comprehensive physical description
- Detailed personality profile with traits, strengths, weaknesses, fears, and desires
- Complete background and personal history
- Complex web of relationships with all other characters
- Deep motivations, conflicting desires, and inner struggles
- Complete character arc with transformation points
- Speech patterns and mannerisms
- Symbolic significance in the story
- Key scenes that define the character
Include all characters with any significant role in the story (15+ characters, depending on the manuscript).`
    };
    
    // Select appropriate detail level
    const detailLevel = detailInstructions[characterLevel] || detailInstructions.standard;
    
    return `=== MANUSCRIPT ===
${manuscriptContent}
=== END MANUSCRIPT ===

You are a skilled character analyst and story editor helping to extract comprehensive character profiles from an existing manuscript written in ${language}.

Task: Create a characters document for the novel: "${title}"
${genreText}

${detailLevel}

IMPORTANT FORMATTING INSTRUCTIONS:
1. DO NOT use Markdown formatting (no #, ##, ###, *, **, etc.)
2. Start with "CHARACTERS:" followed by the novel title
3. For each character, clearly indicate their name in ALL CAPS as a header
4. Use consistent section headers for each aspect of the character (PHYSICAL DESCRIPTION, PERSONALITY, etc.)
5. Format information in clean paragraphs without bullet points
6. Separate each character profile with a row of dashes (-------)
7. Present characters in order of importance to the story
8. Be specific and concrete rather than vague or general
9. Include exact details as described in the manuscript, not generic assumptions

Important: This document will be used for further development and analysis of the novel. Focus on extracting factual information about the characters as they appear in the text. Arrange the information in a logical, organized manner that makes it easy to reference character details.

Aim to capture the essence of each character and their role in the story, while providing enough specific detail to be useful for world-building and narrative analysis.`;
  }
  
  /**
   * Create world extraction prompt
   * @param {string} title - Title of manuscript
   * @param {string} genre - Genre of manuscript
   * @param {string} pov - Point of view
   * @param {string} manuscriptContent - Content of manuscript
   * @param {string} language - Language of manuscript
   * @param {string} worldLevel - Level of detail (basic, standard, detailed)
   * @returns {string} - Prompt for Claude API
   */
  createWorldExtractionPrompt(
    title,
    genre,
    pov,
    manuscriptContent,
    language,
    worldLevel = "standard"
  ) {
    // Genre inclusion
    const genreText = genre ? `Genre: ${genre}` : '';
    
    // POV inclusion
    const povText = pov !== 'undetermined' ? `Point of View: ${pov}` : '';
    
    // Detail level instructions
    const detailInstructions = {
      basic: `
Extract basic world information including:
- Setting overview (time period, general location)
- Social structure basics
- Key locations mentioned
- Basic rules or limitations of the world
Focus on the most important elements needed to understand the story context.`,
      
      standard: `
Extract standard world information including:
- Detailed setting overview (time, place, era)
- Geography and environment
- Social structure and governance
- History relevant to the plot
- Technology or magic systems
- Economy and resources
- Cultural norms and values
- Important locations with descriptions
- Rules and limitations of the world
- Themes and symbols
Include all worldbuilding elements that appear in the manuscript.`,
      
      detailed: `
Extract comprehensive world information including:
- Exhaustive setting details (specific time period, exact locations, climate, ecology)
- Complete geographical layout and environmental features
- Intricate social hierarchies and political structures
- Detailed historical timeline with significant events
- Comprehensive technological or magical systems with rules and limitations
- Economic systems, trade networks, and resource distribution
- Rich cultural details including customs, beliefs, languages, arts
- All locations with complete physical descriptions and significance
- Legal systems, taboos, and societal norms
- Symbolic elements and thematic motifs embedded in the world
- Sensory aspects of the world (sounds, smells, tastes, textures)
Include every worldbuilding detail mentioned directly or implied in the manuscript.`
    };
    
    // Select appropriate detail level
    const detailLevel = detailInstructions[worldLevel] || detailInstructions.standard;
    
    return `=== MANUSCRIPT ===
${manuscriptContent}
=== END MANUSCRIPT ===

You are a skilled worldbuilding expert and literary analyst helping to extract a comprehensive world document from an existing manuscript written in ${language}.

Task: Create a world-building document for the novel: "${title}"
${genreText}
${povText}

${detailLevel}

IMPORTANT FORMATTING INSTRUCTIONS:
1. DO NOT use Markdown formatting (no #, ##, ###, *, **, etc.)
2. Start with "WORLD: [TITLE]" as the header
3. Organize information in clear thematic sections with ALL CAPS headers
4. Use consistent formatting throughout
5. Separate major sections with a row of dashes (-------)
6. Be specific and detailed rather than vague or general
7. Include only information that is explicitly stated or strongly implied in the manuscript
8. Do not include character profiles (these will be in a separate file)

REQUIRED SECTIONS (at minimum):
- SETTING OVERVIEW
- SOCIAL STRUCTURE
- HISTORY
- TECHNOLOGY AND/OR MAGIC
- ECONOMY
- THEMES AND SYMBOLS
- RULES OF THE WORLD
- KEY LOCATIONS

This document will serve as the definitive reference for the novel's world and setting, to be used for further analysis and development. Extract all relevant world-building information from the manuscript and organize it in a clear, logical manner that makes the world easy to understand.`;
  }
  
  /**
   * Create timeline extraction prompt
   * @param {string} title - Title of manuscript
   * @param {string} genre - Genre of manuscript
   * @param {string} manuscriptContent - Content of manuscript
   * @param {string} language - Language of manuscript
   * @returns {string} - Prompt for Claude API
   */
  createTimelineExtractionPrompt(
    title,
    genre,
    manuscriptContent,
    language
  ) {
    // Genre inclusion
    const genreText = genre ? `Genre: ${genre}` : '';
    
    return `=== MANUSCRIPT ===
${manuscriptContent}
=== END MANUSCRIPT ===

You are a skilled story analyst and timeline expert helping to extract a comprehensive chronological timeline from an existing manuscript written in ${language}.

Task: Create a detailed timeline document for the novel: "${title}"
${genreText}

Extract a complete chronological timeline from the manuscript, including:
- All explicit time markers and dates mentioned in the text
- The sequence of events as they occur in the story world (not necessarily as presented in the narrative)
- Important backstory events mentioned or referenced
- Relative time periods (before/after significant events)
- Duration of events when specified
- Time jumps and their approximate lengths
- Flashbacks placed in their proper chronological position
- Future events mentioned or foreshadowed

IMPORTANT FORMATTING INSTRUCTIONS:
1. DO NOT use Markdown formatting (no #, ##, ###, *, **, etc.)
2. Start with "TIMELINE: [TITLE]" as the header
3. Format entries chronologically from earliest to latest
4. Use clear time markers or relative time indicators for each entry
5. Include brief descriptions of events tied to each time marker
6. Group events that happen simultaneously or in the same time period
7. Use consistent formatting throughout
8. Separate major time periods with a row of dashes (-------)
9. Note any ambiguities or uncertainties in the chronology

This timeline will serve as a reference document for the novel's chronological structure, to be used for further analysis and development. Extract all time-related information from the manuscript and organize it in a clear, logical manner that represents the true chronology of events in the story world.`;
  }
  
  /**
   * Count words in text
   * @param {string} text - Text to count words in
   * @returns {number} - Word count
   */
  countWords(text) {
    return text.replace(/(\r\n|\r|\n)/g, ' ').split(/\s+/).filter(word => word.length > 0).length;
  }
  
  /**
   * Ensure file path is absolute
   * @param {string} filePath - File path (may be relative or absolute)
   * @param {string} basePath - Base path to prepend for relative paths
   * @returns {string} - Absolute file path
   */
  ensureAbsolutePath(filePath, basePath) {
    if (!filePath) return filePath;
    
    // Check if the path is already absolute
    if (path.isAbsolute(filePath)) {
      return filePath;
    }
    
    // Make the path absolute by joining with the base path
    return path.join(basePath, filePath);
  }
}

module.exports = ManuscriptExtractor;

============================================================
FILE: manuscript-to-outline-characters-world.js
SIZE: 20721 bytes
LANGUAGE: JS
============================================================

// manuscript-to-outline-characters-world.js
const BaseTool = require('./base-tool');
const path = require('path');
const fileCache = require('./file-cache');
const appState = require('./state.js');
const fs = require('fs/promises');

/**
 * ManuscriptToOutlineCharactersWorld Tool
 * Analyzes a manuscript file and generates three output files:
 * 1. outline.txt - Structured outline of the manuscript
 * 2. characters.txt - List of characters from the manuscript
 * 3. world.txt - Description of the world/setting in the manuscript
 */
class ManuscriptToOutlineCharactersWorld extends BaseTool {
  /**
   * Constructor
   * @param {Object} GeminiAPIService - Claude API service
   * @param {Object} config - Tool configuration
   */
  constructor(GeminiAPIService, config = {}) {
    super('manuscript_to_outline_characters_world', config);
    this.GeminiAPIService = GeminiAPIService;
  }
  
  /**
   * Execute the tool
   * @param {Object} options - Tool options
   * @returns {Promise<Object>} - Execution result
   */
  async execute(options) {
    console.log('Executing ManuscriptToOutlineCharactersWorld with options:', options);
    console.log('appState.CURRENT_PROJECT=', appState.CURRENT_PROJECT);

    // Extract options
    let manuscriptFile = options.manuscript_file;
    const description = options.description;

    // the only logical OR allowed:
    const saveDir = options.save_dir || appState.CURRENT_PROJECT_PATH;
    console.log('execute: saveDir', saveDir);
    
    if (!saveDir) {
      const errorMsg = 'Error: No save directory specified and no current project selected.\n' +
                       'Please select a project or specify a save directory.';
      this.emitOutput(errorMsg);
      throw new Error('No save directory available');
    }

    // Ensure manuscript file is provided
    if (!manuscriptFile) {
      const errorMsg = 'Error: No manuscript file specified.\n' +
                       'Please specify a manuscript file with the manuscript_file parameter.';
      this.emitOutput(errorMsg);
      throw new Error('No manuscript file specified');
    }

    // Ensure file paths are absolute
    manuscriptFile = this.ensureAbsolutePath(manuscriptFile, saveDir);
    
    // Log the full paths for debugging
    console.log('Using manuscript file:', manuscriptFile);

    const outputFiles = [];
    
    try {
      // Read the manuscript file
      this.emitOutput(`Reading manuscript file: ${manuscriptFile}\n`);
      const manuscriptContent = await this.readInputFile(manuscriptFile);
      
      const outlineFile = await this.generateOutline(manuscriptContent, saveDir, description);
      outputFiles.push(outlineFile);
    
      const charactersFile = await this.generateCharacters(manuscriptContent, saveDir, description);
      outputFiles.push(charactersFile);
    
      const worldFile = await this.generateWorld(manuscriptContent, saveDir, description);
      outputFiles.push(worldFile);
      
      // Add files to the cache
      const toolName = 'manuscript_to_outline_characters_world';
      outputFiles.forEach(file => {
        fileCache.addFile(toolName, file);
      });
      
      // Return the result
      return {
        success: true,
        outputFiles
      };
    } catch (error) {
      console.error('Error in ManuscriptToOutlineCharactersWorld:', error);
      this.emitOutput(`\nError: ${error.message}\n`);
      throw error;
    }
  }
  
  /**
   * Generate outline from manuscript
   * @param {string} manuscriptContent - Manuscript content
   * @param {string} saveDir - Directory to save to
   * @param {string} description - Optional description
   * @returns {Promise<string>} - Path to the saved outline file
   */
  async generateOutline(manuscriptContent, saveDir, description) {
    this.emitOutput(`\n\nGenerating outline...\n`);
    
    // Create the prompt for outline
    const prompt = this.createOutlinePrompt(manuscriptContent);
    
    // Call Claude API
    const { content, thinking, promptTokens, responseTokens } = await this.callClaudeAPI(prompt, 'Outline');
    
    // Save the outline to a file
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const desc = description ? `_${description}` : '';
    const outlineFilename = `outline${desc}_${timestamp}.txt`;
    const outlinePath = path.join(saveDir, outlineFilename);
    
    await this.writeOutputFile(content, saveDir, outlineFilename);
    this.emitOutput(`Outline saved to: ${outlinePath}\n`);
    
    // Save thinking if available and not skipped
    // if (thinking) {
    //   const thinkingFilename = `outline_thinking${desc}_${timestamp}.txt`;
    //   await this.saveThinking(thinking, saveDir, thinkingFilename, promptTokens, responseTokens, 'Outline');
    // }
    
    return outlinePath;
  }
  
  /**
   * Generate characters list from manuscript
   * @param {string} manuscriptContent - Manuscript content
   * @param {string} saveDir - Directory to save to
   * @param {string} description - Optional description
   * @returns {Promise<string>} - Path to the saved characters file
   */
  async generateCharacters(manuscriptContent, saveDir, description) {
    this.emitOutput(`\n\nGenerating characters list...\n`);
    
    // Create the prompt for character
    const prompt = this.createCharactersPrompt(manuscriptContent);
    
    // Call Claude API
    const { content, thinking, promptTokens, responseTokens } = await this.callClaudeAPI(prompt, 'Characters');
    
    // Save the characters to a file
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const desc = description ? `_${description}` : '';
    const charactersFilename = `characters${desc}_${timestamp}.txt`;
    const charactersPath = path.join(saveDir, charactersFilename);
    
    await this.writeOutputFile(content, saveDir, charactersFilename);
    this.emitOutput(`Characters saved to: ${charactersPath}\n`);
    
    // Save thinking if available and not skipped
    // if (thinking) {
    //   const thinkingFilename = `characters_thinking${desc}_${timestamp}.txt`;
    //   await this.saveThinking(thinking, saveDir, thinkingFilename, promptTokens, responseTokens, 'Characters');
    // }
    
    return charactersPath;
  }
  
  /**
   * Generate world description from manuscript
   * @param {string} manuscriptContent - Manuscript content
   * @param {string} saveDir - Directory to save to
   * @param {string} description - Optional description
   * @returns {Promise<string>} - Path to the saved world file
   */
  async generateWorld(manuscriptContent, saveDir, description) {
    this.emitOutput(`\n\nGenerating world description...\n`);
    
    // Create the prompt for world
    const prompt = this.createWorldPrompt(manuscriptContent);
    
    // Call Claude API
    const { content, thinking, promptTokens, responseTokens } = await this.callClaudeAPI(prompt, 'World');
    
    // Save the world description to a file
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const desc = description ? `_${description}` : '';
    const worldFilename = `world${desc}_${timestamp}.txt`;
    const worldPath = path.join(saveDir, worldFilename);
    
    await this.writeOutputFile(content, saveDir, worldFilename);
    this.emitOutput(`World description saved to: ${worldPath}\n`);
    
    // Save thinking if available and not skipped
    // if (thinking) {
    //   const thinkingFilename = `world_thinking${desc}_${timestamp}.txt`;
    //   await this.saveThinking(thinking, saveDir, thinkingFilename, promptTokens, responseTokens, 'World');
    // }
    
    return worldPath;
  }
  
  /**
   * Call Claude API with thinking
   * @param {string} prompt - Prompt for Claude API
   * @param {string} label - Label for logging
   * @returns {Promise<Object>} - API response
   */
  async callClaudeAPI(prompt, label) {
    // Count tokens in the prompt
    this.emitOutput(`Counting tokens for: ${label} prompt...\n`);
    const promptTokens = await this.GeminiAPIService.countTokens(prompt);

    // Call the shared token budget calculator
    const tokenBudgets = this.GeminiAPIService.calculateTokenBudgets(promptTokens);

    // Handle logging based on the returned values
    this.emitOutput(`\n${label} Token stats:\n`);
    this.emitOutput(`Max AI model context window: [${tokenBudgets.contextWindow}] tokens\n`);
    this.emitOutput(`Input prompt tokens: [${tokenBudgets.promptTokens}] tokens\n`);
    this.emitOutput(`Available tokens: [${tokenBudgets.availableTokens}] tokens\n`);
    this.emitOutput(`Desired output tokens: [${tokenBudgets.desiredOutputTokens}] tokens\n`);
    this.emitOutput(`AI model thinking budget: [${tokenBudgets.thinkingBudget}] tokens\n`);
    this.emitOutput(`Max output tokens: [${tokenBudgets.maxTokens}] tokens\n`);

    // Check for special conditions
    if (tokenBudgets.capThinkingBudget) {
      this.emitOutput(`Warning: thinking budget is larger than 32K, set to 32K.\n`);
    }

    // Check if the prompt is too large
    if (tokenBudgets.isPromptTooLarge) {
      this.emitOutput(`Error: prompt is too large to have a ${tokenBudgets.configuredThinkingBudget} thinking budget!\n`);
      this.emitOutput(`Run aborted!\n`);
      throw new Error(`Prompt is too large for ${tokenBudgets.configuredThinkingBudget} thinking budget - run aborted`);
    }
    
    // Call Claude API with streaming
    this.emitOutput(`\n\nSending request to Claude API (streaming) for ${label}...\n`);
    
    // Add a message about waiting
    this.emitOutput(`****************************************************************************\n`);
    this.emitOutput(`*  Generating ${label} content from your manuscript...                     \n`);
    this.emitOutput(`*  This process typically takes several minutes.                           \n`);
    this.emitOutput(`*                                                                          \n`);
    this.emitOutput(`*  It's recommended to keep this window the sole 'focus'                   \n`);
    this.emitOutput(`*  and to avoid browsing online or running other apps, as these API        \n`);
    this.emitOutput(`*  network connections are often flakey, like delicate echoes of whispers. \n`);
    this.emitOutput(`*                                                                          \n`);
    this.emitOutput(`*  So breathe, remove eye glasses, stretch, relax, and be like water 🥋 🧘🏽‍♀️\n`);
    this.emitOutput(`****************************************************************************\n\n`);
    
    const startTime = Date.now();
    let fullResponse = "";
    let thinkingContent = "";
    
    // Create system prompt to avoid markdown
    const systemPrompt = "CRITICAL INSTRUCTION: NO Markdown formatting of ANY kind. Never use headers, bullets, or any formatting symbols. Plain text only with standard punctuation.";

    // Use the calculated values in the API call
    try {
      await this.GeminiAPIService.streamWithThinking(
        prompt,
        {
          system: systemPrompt,
          max_tokens: tokenBudgets.maxTokens,
          thinking: {
            type: "enabled",
            budget_tokens: tokenBudgets.thinkingBudget
          }
        },
        // Callback for thinking content
        (thinkingDelta) => {
          thinkingContent += thinkingDelta;
        },
        // Callback for response text
        (textDelta) => {
          fullResponse += textDelta;
        }
      );
    } catch (error) {
      this.emitOutput(`\nAPI Error: ${error.message}\n`);
      throw error;
    }

    const elapsed = (Date.now() - startTime) / 1000;
    const minutes = Math.floor(elapsed / 60);
    const seconds = elapsed % 60;
    
    this.emitOutput(`\n${label} generation completed in ${minutes}m ${seconds.toFixed(2)}s.\n`);
    
    // Count words in response
    const wordCount = this.countWords(fullResponse);
    this.emitOutput(`${label} has approximately ${wordCount} words.\n`);
    
    // Count tokens in response
    const responseTokens = await this.GeminiAPIService.countTokens(fullResponse);
    this.emitOutput(`${label} response token count: ${responseTokens}\n`);

    // Remove any markdown formatting
    fullResponse = this.removeMarkdown(fullResponse);
    
    return {
      content: fullResponse,
      thinking: thinkingContent,
      promptTokens,
      responseTokens
    };
  }
  
  /**
   * Save thinking content to file
   * @param {string} thinking - Thinking content
   * @param {string} saveDir - Directory to save to
   * @param {string} filename - Filename for thinking content
   * @param {number} promptTokens - Prompt token count
   * @param {number} responseTokens - Response token count
   * @param {string} label - Label for the thinking content
   */
  async saveThinking(thinking, saveDir, filename, promptTokens, responseTokens, label) {
    const thinkingPath = path.join(saveDir, filename);
    
    const formatter = new Intl.DateTimeFormat('en-US', {
      weekday: 'long',
      month: 'long',
      day: 'numeric',
      year: 'numeric',
      hour: 'numeric',
      minute: '2-digit',
      hour12: true
    });
    const dateTimeStr = formatter.format(new Date());
    
    // Create stats for thinking file
    const stats = `
Details:  ${dateTimeStr}
Analysis type: ${label} from manuscript
Max request timeout: ${this.config.request_timeout} seconds
Max AI model context window: ${this.config.context_window} tokens
AI model thinking budget: ${this.config.thinking_budget_tokens} tokens
Desired output tokens: ${this.config.desired_output_tokens} tokens

Input tokens: ${promptTokens}
Output tokens: ${responseTokens}
`;
    
    const thinkingContent = `=== ${label.toUpperCase()} EXTRACTION ===

=== AI'S THINKING PROCESS ===

${thinking}

=== END AI'S THINKING PROCESS ===
${stats}`;
    
    await this.writeOutputFile(thinkingContent, saveDir, filename);
    this.emitOutput(`AI thinking saved to: ${thinkingPath}\n`);
  }
  
  /**
   * Create outline extraction prompt
   * @param {string} manuscriptContent - Manuscript content
   * @returns {string} - Prompt for Claude API
   */
  createOutlinePrompt(manuscriptContent) {
    return `=== MANUSCRIPT ===
${manuscriptContent}
=== END MANUSCRIPT ===

=== PROJECT TITLE ===
${appState.CURRENT_PROJECT}
=== END PROJECT TITLE ===

CRITICAL INSTRUCTION: This project is titled "${appState.CURRENT_PROJECT}". Do NOT create or suggest a new title. Always refer to this work by its existing title shown above.

IMPORTANT: NO Markdown formatting

You are an expert fiction editor and story analyst. Your task is to extract a detailed outline from the provided manuscript. Create an outline that includes chapter divisions, key plot points, and story structure.

Focus on:

1. OVERALL STORY STRUCTURE:
   - Identify the major sections or acts of the story
   - Note key turning points in the narrative
   - Outline the main storyline from beginning to end

2. CHAPTER BREAKDOWN:
   - Create outline entries for each chapter or major section
   - Provide a title or number for each chapter
   - Summarize the key events and developments in each chapter

3. SCENE MAPPING:
   - Within each chapter, note important scene transitions
   - Identify significant locations, time periods, or POV shifts
   - Track subplot developments

The outline should be comprehensive enough to serve as a blueprint for the entire story, capturing all major developments and character arcs. Use ONLY plain text formatting with standard paragraph structure.

Format the outline consistently, with clear chapter/section designations. Use numbering for chapters and dashes for bullet points rather than Markdown symbols. The outline should be usable as a reference document for other editing tools.`;
  }
  
  /**
   * Create characters extraction prompt
   * @param {string} manuscriptContent - Manuscript content
   * @returns {string} - Prompt for Claude API
   */
  createCharactersPrompt(manuscriptContent) {
    return `=== MANUSCRIPT ===
${manuscriptContent}
=== END MANUSCRIPT ===

=== PROJECT TITLE ===
${appState.CURRENT_PROJECT}
=== END PROJECT TITLE ===

CRITICAL INSTRUCTION: This project is titled "${appState.CURRENT_PROJECT}". Do NOT create or suggest a new title. Always refer to this work by its existing title shown above.

IMPORTANT: NO Markdown formatting

You are an expert fiction editor and character analyst. Your task is to extract a comprehensive list of characters from the provided manuscript. Create detailed character profiles for all significant characters in the story.

Focus on:

1. CHARACTER IDENTIFICATION:
   - Identify ALL named characters in the manuscript
   - Note characters who appear multiple times or have significant roles
   - Include minor but notable characters

2. CHARACTER PROFILES:
   - For each significant character, provide:
     a) Full name and any aliases or titles
     b) Role in the story (protagonist, antagonist, supporting character, etc.)
     c) Physical description based on details in the manuscript
     d) Personality traits and characteristics shown in the text
     e) Background information revealed in the manuscript
     f) Key relationships with other characters
     g) Character arc or development through the story

3. CHARACTER HIERARCHY:
   - Clearly distinguish between main characters, supporting characters, and minor characters
   - Group related characters (families, teams, organizations)
   - Note characters' relative importance to the plot

The character list should be comprehensive and detailed enough to serve as a reference document for the story. Use ONLY plain text formatting with standard paragraph structure and indentation.

Format each character profile consistently, starting with the character's name followed by their details. Use dashes for bullet points rather than Markdown symbols. The character list should be usable as a reference document for other editing tools.`;
  }
  
  /**
   * Create world extraction prompt
   * @param {string} manuscriptContent - Manuscript content
   * @returns {string} - Prompt for Claude API
   */
  createWorldPrompt(manuscriptContent) {
    return `=== MANUSCRIPT ===
${manuscriptContent}
=== END MANUSCRIPT ===

=== PROJECT TITLE ===
${appState.CURRENT_PROJECT}
=== END PROJECT TITLE ===

CRITICAL INSTRUCTION: This project is titled "${appState.CURRENT_PROJECT}". Do NOT create or suggest a new title. Always refer to this work by its existing title shown above.

IMPORTANT: NO Markdown formatting

You are an expert fiction editor and world-building analyst. Your task is to extract a comprehensive description of the story world from the provided manuscript. Create a detailed document that catalogs the setting, rules, history, and other world elements.

Focus on:

1. SETTING OVERVIEW:
   - Identify the time period and general setting of the story
   - Note the primary locations and environments
   - Describe the overall atmosphere and mood of the world

2. WORLD ELEMENTS:
   - Physical geography and locations
   - Social structures, governments, and organizations
   - Cultural elements, customs, and traditions
   - Technology, magic systems, or special rules of the world
   - Historical events mentioned that shape the current world

3. WORLD RULES AND LOGIC:
   - Identify any special rules or laws (natural, supernatural, or societal)
   - Note unique aspects of how this world functions
   - Document any limitations or constraints established in the text

The world description should be comprehensive enough to serve as a reference for understanding the story's setting and rules. Use ONLY plain text formatting with standard paragraph structure.

Format the world document with clear sections and consistent structure. Use dashes for bullet points rather than Markdown symbols. The document should be usable as a reference for other editing tools.`;
  }
  
  /**
   * Count words in text
   * @param {string} text - Text to count words in
   * @returns {number} - Word count
   */
  countWords(text) {
    return text.split(/\s+/).filter(word => word.length > 0).length;
  }
  
  /**
   * Ensure file path is absolute
   * @param {string} filePath - File path (may be relative or absolute)
   * @param {string} basePath - Base path to prepend for relative paths
   * @returns {string} - Absolute file path
   */
  ensureAbsolutePath(filePath, basePath) {
    if (!filePath) return filePath;
    
    // Check if the path is already absolute
    if (path.isAbsolute(filePath)) {
      return filePath;
    }
    
    // Make the path absolute by joining with the base path
    return path.join(basePath, filePath);
  }
}

module.exports = ManuscriptToOutlineCharactersWorld;


============================================================
FILE: narrative-integrity.js
SIZE: 21266 bytes
LANGUAGE: JS
============================================================

// narrative-integrity.js
const BaseTool = require('./base-tool');
const path = require('path');
const fileCache = require('./file-cache');
const appState = require('./state.js');
const fs = require('fs/promises');

// You've identified exactly what makes the Narrative Integrity tool so
// valuable in a comprehensive editing toolkit. Let me expand on why its
// focus on consistency issues specifically makes it worth keeping in
// the lineup:

// Why Consistency Checking Deserves Its Own Tool

// The focus on consistency issues rather than general improvement suggestions gives this tool unique value because:

// 1. Objectivity vs. Subjectivity
//    Most developmental editing is inherently subjective—suggestions about making characters more compelling or plots more engaging involve personal judgment. Consistency issues, however, are largely objective problems with clear right/wrong answers (either something contradicts established facts or it doesn't).

// 2. The Cognitive Blind Spot Problem
//    Writers and even human editors are notoriously bad at catching their own consistency errors. Our brains tend to "fill in" what we expect to see rather than what's actually on the page. This is why we miss when a character's car changes from blue to red between chapters.

// 3. Scale and Complexity Challenge
//    In longer works (novels, series), the sheer volume of details to track becomes overwhelming. No human editor can realistically hold hundreds of character traits, world rules, and previously established facts in working memory while reading.

// 4. Different Mental Process
//    Looking for inconsistencies requires a different mental approach than improving story elements. It's systematic cross-referencing rather than creative enhancement. Having a dedicated tool for this prevents this critical task from getting lost in broader revision processes.

// 5. Foundational to Other Editing
//    Consistency issues undermine reader trust and engagement. If these fundamental problems aren't addressed first, more advanced stylistic improvements may be built on shaky ground.

// The tool fills a crucial gap between developmental editing
// (which focuses on making the story better) and copy editing
// (which focuses on correctness and style). Without it, consistency
// checking often falls between the cracks or is handled incompletely
// during these other phases.

// What makes this particularly valuable is that consistency errors are
// both the most damaging to reader experience and among the hardest for
// writers to self-identify without technological assistance.

/**
 * NarrativeIntegrity Tool
 * Checks a manuscript for integrity against:
 *    a world document and optionally an outline
 * Supports different types of consistency/integrity checks: 
 *    world, internal, development, unresolved
 */
class NarrativeIntegrity extends BaseTool {
  /**
   * Constructor
   * @param {Object} GeminiAPIService - Claude API service
   * @param {Object} config - Tool configuration
   */
  constructor(GeminiAPIService, config = {}) {
    super('narrative_integrity', config);
    this.GeminiAPIService = GeminiAPIService;
  }
  
  /**
   * Execute the tool
   * @param {Object} options - Tool options
   * @returns {Promise<Object>} - Execution result
   */
  async execute(options) {
    // Extract options
    let manuscriptFile = options.manuscript_file;
    let worldFile = options.world_file;
    let outlineFile = options.outline_file;
    const checkType = options.check_type;
    let saveDir = options.save_dir || appState.CURRENT_PROJECT_PATH;
    
    // Check if we have a valid save directory
    if (!saveDir) {
      const errorMsg = 'Error: No save directory specified and no current project selected.\n' +
                      'Please select a project or specify a save directory.';
      this.emitOutput(errorMsg);
      throw new Error('No save directory available');
    }

    // Ensure file paths are absolute by prepending the project path if needed
    manuscriptFile = this.ensureAbsolutePath(manuscriptFile, saveDir);
    worldFile = this.ensureAbsolutePath(worldFile, saveDir);
    if (outlineFile) {
      outlineFile = this.ensureAbsolutePath(outlineFile, saveDir);
    }
    
    // Log the full paths for debugging
    // console.log('Using full paths:');
    // console.log(`Manuscript: ${manuscriptFile}`);
    // console.log(`World: ${worldFile}`);
    // if (outlineFile) {
    //   console.log(`Outline: ${outlineFile}`);
    // }

    const outputFiles = [];
    
    try {
      // Read the input files
      this.emitOutput(`Reading files...\n`);

      // Read the manuscript file
      this.emitOutput(`Reading manuscript file: ${manuscriptFile}\n`);
      const manuscriptContent = await this.readInputFile(manuscriptFile);
      
      // Read the outline file if provided
      let outlineContent = '';
      if (outlineFile) {
        this.emitOutput(`Reading outline file: ${outlineFile}\n`);
        outlineContent = await this.readInputFile(outlineFile);
      }
      
      // Read the world file
      this.emitOutput(`Reading world file: ${worldFile}\n`);
      const worldContent = await this.readInputFile(worldFile);
      
      // Prepare check types to run
      const checkTypes = checkType === 'all' 
        ? ['world', 'internal', 'development', 'unresolved']
        : [checkType];
      
      // Run each check type
      for (const type of checkTypes) {
        this.emitOutput(`\nRunning ${type.toUpperCase()} integrity check...\n`);
        
        // Create the prompt for this check type
        const prompt = this.createPrompt(type, outlineContent, worldContent, manuscriptContent);

        // Count tokens in the prompt
        this.emitOutput(`Counting tokens in prompt...\n`);
        const promptTokens = await this.GeminiAPIService.countTokens(prompt);

        // Call the shared token budget calculator
        const tokenBudgets = this.GeminiAPIService.calculateTokenBudgets(promptTokens);

        // Handle logging based on the returned values
        this.emitOutput(`\nToken stats:\n`);
        this.emitOutput(`Max AI model context window: [${tokenBudgets.contextWindow}] tokens\n`);
        this.emitOutput(`Input prompt tokens: [${tokenBudgets.promptTokens}]\n`);
        this.emitOutput(`Available tokens: [${tokenBudgets.availableTokens}]  = ${tokenBudgets.contextWindow} - ${tokenBudgets.promptTokens} = context_window - prompt\n`);
        this.emitOutput(`Desired output tokens: [${tokenBudgets.desiredOutputTokens}]\n`);
        this.emitOutput(`AI model thinking budget: [${tokenBudgets.thinkingBudget}] tokens\n`);
        this.emitOutput(`Max output tokens: [${tokenBudgets.maxTokens}] tokens\n`);

        // Check for special conditions
        if (tokenBudgets.capThinkingBudget) {
          this.emitOutput(`Warning: thinking budget is larger than 32K, set to 32K.\n`);
        }

        // Check if the prompt is too large
        if (tokenBudgets.isPromptTooLarge) {
          this.emitOutput(`Error: prompt is too large to have a ${tokenBudgets.configuredThinkingBudget} thinking budget!\n`);
          this.emitOutput(`Run aborted!\n`);
          throw new Error(`Prompt is too large for ${tokenBudgets.configuredThinkingBudget} thinking budget - run aborted`);
        }
        
        // Call Claude API with streaming
        this.emitOutput(`Sending request to Claude API (streaming)...\n`);
        
        const startTime = Date.now();
        let fullResponse = "";
        let thinkingContent = "";
        
        // Create system prompt to avoid markdown
        const systemPrompt = "CRITICAL INSTRUCTION: NO Markdown formatting of ANY kind. Never use headers, bullets, or any formatting symbols. Plain text only with standard punctuation.";

        // Use the calculated values in the API call
        try {
          await this.GeminiAPIService.streamWithThinking(
            prompt,
            {
              system: systemPrompt,
              max_tokens: tokenBudgets.maxTokens,
              thinking: {
                type: "enabled",
                budget_tokens: tokenBudgets.thinkingBudget
              }
            },
            // Callback for thinking content
            (thinkingDelta) => {
              thinkingContent += thinkingDelta;
            },
            // Callback for response text
            (textDelta) => {
              fullResponse += textDelta;
            }
          );
        } catch (error) {
          console.log(`\n*** client.js: execute:\nAPI Error: ${error.message}\n`);
          // client.js: execute:
          // API Error: 400 {
          //     "type":"error",
          //     "error":{
          //       "type":"invalid_request_error",
          //       "message":"input length and `max_tokens` exceed 
          //          context limit: 107398 + 128000 > 200000, 
          //          decrease input length or `max_tokens` and try again"
          //     }}
          this.emitOutput(`\nAPI Error: ${error.message}\n`);
          throw error;
        }

        const elapsed = (Date.now() - startTime) / 1000;
        const minutes = Math.floor(elapsed / 60);
        const seconds = elapsed % 60;
        
        this.emitOutput(`\nCompleted in ${minutes}m ${seconds.toFixed(2)}s.\n`);
        
        // Count words in response
        const wordCount = this.countWords(fullResponse);
        this.emitOutput(`Report has approximately ${wordCount} words.\n`);
        
        // Count tokens in response
        const responseTokens = await this.GeminiAPIService.countTokens(fullResponse);
        this.emitOutput(`Response token count: ${responseTokens}\n`);

        fullResponse = this.removeMarkdown(fullResponse);

        // Save the report
        const outputFile = await this.saveReport(
          type,
          fullResponse,
          thinkingContent,
          promptTokens,
          responseTokens,
          saveDir
        );
        
        // Use spread operator to push all elements individually
        outputFiles.push(...outputFile);
      }
      
      // Return the result
      return {
        success: true,
        outputFiles,
        stats: {
          checkTypes: checkTypes
        }
      };
    } catch (error) {
      console.error('Error in NarrativeIntegrity:', error);
      this.emitOutput(`\nError: ${error.message}\n`);
      throw error;
    }
  }
  
  /**
   * Ensure file path is absolute
   * @param {string} filePath - File path (may be relative or absolute)
   * @param {string} basePath - Base path to prepend for relative paths
   * @returns {string} - Absolute file path
   */
  ensureAbsolutePath(filePath, basePath) {
    if (!filePath) return filePath;
    
    // Check if the path is already absolute
    if (path.isAbsolute(filePath)) {
      return filePath;
    }
    
    // Make the path absolute by joining with the base path
    return path.join(basePath, filePath);
  }
  
  /**
   * Count words in text
   * @param {string} text - Text to count words in
   * @returns {number} - Word count
   */
  countWords(text) {
    return text.split(/\s+/).filter(word => word.length > 0).length;
  }
  
  /**
   * Create prompt based on check type
   * @param {string} checkType - Type of integrity check
   * @param {string} outlineContent - Outline content
   * @param {string} worldContent - World content
   * @param {string} manuscriptContent - Manuscript content
   * @returns {string} - Prompt for Claude API
   */
  createPrompt(checkType, outlineContent, worldContent, manuscriptContent) {
    // cls: to be honest this has no effect:
    const noMarkdown = "IMPORTANT: - NO Markdown formatting";
    
    const prompts = {
      "world": `=== OUTLINE ===
${outlineContent}
=== END OUTLINE ===

=== WORLD ===
${worldContent}
=== END WORLD ===

=== MANUSCRIPT ===
${manuscriptContent}
=== END MANUSCRIPT ===

${noMarkdown}

You are an expert fiction editor with exceptional attention to detail.
Using the WORLD document as the established source of truth, analyze
the MANUSCRIPT for any inconsistencies or contradictions with the
established facts. Focus on:

1. CHARACTER INTEGRITY:
   - Are characters acting in ways that match their established
     personality traits?
   - Does dialogue reflect their documented speech patterns and
     knowledge level?
   - Are relationships developing consistently with established
     dynamics?
   - Are physical descriptions matching those in the WORLD document?

2. SETTING & WORLD INTEGRITY:
   - Are locations described consistently with their established
     features?
   - Does the manuscript respect the established rules of the world?

3. TIMELINE COHERENCE:
   - Does the manuscript respect the established historical events and
     their sequence?
   - Are there any temporal contradictions with established dates?
   - Is character knowledge appropriate for their place in the
     timeline?
   - Are seasonal elements consistent with the story's temporal
     placement?

4. THEMATIC INTEGRITY:
   - Are the established themes being consistently developed?
   - Are symbolic elements used consistently with their established meanings?

For each inconsistency, lacking integrity, provide:
- The specific element in the manuscript that contradicts the WORLD
- The established fact in the WORLD it contradicts
- The location in the manuscript where this occurs using verbatim text
- A suggested correction that would maintain narrative integrity

Use the extensive thinking space to thoroughly cross-reference the
manuscript against the story's world before identifying issues.
`,

      "internal": `=== MANUSCRIPT ===
${manuscriptContent}
=== END MANUSCRIPT ===

${noMarkdown}

You are an expert fiction editor focusing on internal narrative
consistency and integrity. Analyze the MANUSCRIPT to identify elements that are
internally inconsistent or contradictory or lacking integrity, regardless of the
established story world. Focus on:

1. NARRATIVE CONTINUITY:
   - Events that contradict earlier established facts within the
     manuscript itself
   - Description inconsistencies (characters, objects, settings
     changing without explanation)
   - Dialogue that contradicts earlier statements by the same
     character
   - Emotional arcs that show sudden shifts without sufficient
     development

2. SCENE-TO-SCENE COHERENCE:
   - Physical positioning and transitions between locations
   - Time of day and lighting inconsistencies
   - Character presence/absence in scenes without explanation
   - Weather or environmental conditions that change illogically

3. PLOT LOGIC:
   - Character motivations that seem inconsistent with their actions
   - Convenient coincidences that strain credibility
   - Information that characters possess without logical means of
     acquisition
   - Plot developments that contradict earlier established rules or
     limitations

4. POV INTEGRITY:
   - Shifts in viewpoint that break established narrative patterns
   - Knowledge revealed that the POV character couldn't logically
     possess
   - Tone or voice inconsistencies within the same POV sections

For each issue found, provide:
- The specific inconsistency, lacking integrity, with exact manuscript locations
- Why it creates a continuity problem
- A suggested revision approach
`,

      "development": `=== OUTLINE ===
${outlineContent}
=== END OUTLINE ===

=== WORLD ===
${worldContent}
=== END WORLD ===

=== MANUSCRIPT ===
${manuscriptContent}
=== END MANUSCRIPT ===

${noMarkdown}

You are an expert fiction editor analyzing character and plot
development. Track how key elements evolve throughout the manuscript
and identify any development issues:

1. CHARACTER ARC TRACKING:
   - For each major character, trace their development through the manuscript
   - Identify key transformation moments and their emotional progression
   - Highlight any character development that feels rushed, stalled,
     or inconsistent
   - Note if their arc is following the trajectory established in the
     WORLD document

2. MYSTERY DEVELOPMENT:
   - Track the progression of the central mystery
   - Ensure clues are being revealed at an appropriate pace
   - Identify any critical information that's missing or presented out
     of logical sequence
   - Check if red herrings and misdirections are properly balanced
     with genuine progress

3. RELATIONSHIP EVOLUTION:
   - Track how key relationships develop
   - Ensure relationship changes are properly motivated and paced
   - Identify any significant jumps in relationship dynamics that need
     development

4. THEME DEVELOPMENT:
   - Track how the core themes from the WORLD document are being
     developed
   - Identify opportunities to strengthen thematic elements
   - Note if any established themes are being neglected

Provide a structured analysis showing the progression points for each
tracked element, identifying any gaps, pacing issues, or development
opportunities.
`,

      "unresolved": `=== MANUSCRIPT ===
${manuscriptContent}
=== END MANUSCRIPT ===

${noMarkdown}

You are an expert fiction editor specializing in narrative
completeness. Analyze the MANUSCRIPT to identify elements that have
been set up but not resolved:

1. UNRESOLVED PLOT ELEMENTS:
   - Mysteries or questions raised but not answered
   - Conflicts introduced but not addressed
   - Promises made to the reader (through foreshadowing or explicit
     setup) without payoff
   - Character goals established but not pursued

2. CHEKHOV'S GUNS:
   - Significant objects introduced but not used
   - Skills or abilities established but never employed
   - Locations described in detail but not utilized in the plot
   - Information revealed but not made relevant

3. CHARACTER THREADS:
   - Side character arcs that begin but don't complete
   - Character-specific conflicts that don't reach resolution
   - Backstory elements introduced but not integrated into the main
     narrative
   - Relationship dynamics that are established but not developed

For each unresolved element, provide:
- What was introduced and where in the manuscript
- Why it creates an expectation of resolution
- Suggested approaches for resolution or intentional non-resolution
`
    };
    
    return prompts[checkType] || "";
  }

  /**
   * Save report and thinking content to files
   * @param {string} checkType - Type of integrity check
   * @param {string} content - Response content
   * @param {string} thinking - Thinking content
   * @param {number} promptTokens - Prompt token count
   * @param {number} responseTokens - Response token count
   * @param {string} saveDir - Directory to save to
   * @param {string} description - Optional description
   * @returns {Promise<string[]>} - Array of paths to saved files
   */
  async saveReport(checkType, content, thinking, promptTokens, responseTokens, saveDir, description) {
    try {
      const formatter = new Intl.DateTimeFormat('en-US', {
        weekday: 'long',
        month: 'long',
        day: 'numeric',
        year: 'numeric',
        hour: 'numeric',
        minute: '2-digit',
        hour12: true
      });
      const dateTimeStr2 = formatter.format(new Date());

      // Create timestamp for filename
      const timestamp = new Date().toISOString().replace(/[-:.]/g, '').substring(0, 15);
      
      // Create descriptive filename
      const desc = description ? `_${description}` : '';
      const baseFilename = `narrative_integrity_${checkType}${desc}_${timestamp}`;
      
      // Array to collect all saved file paths
      const savedFilePaths = [];
      
      // Create stats for thinking file
      const stats = `
Details:  ${dateTimeStr2}
Check type: ${checkType} narrative integrity check
Max request timeout: ${this.config.request_timeout} seconds
Max AI model context window: ${this.config.context_window} tokens
AI model thinking budget: ${this.config.thinking_budget_tokens} tokens
Desired output tokens: ${this.config.desired_output_tokens} tokens

Input tokens: ${promptTokens}
Output tokens: ${responseTokens}
`;
      
      // Save full response
      const reportFilename = `${baseFilename}.txt`;
      const reportPath = path.join(saveDir, reportFilename);
      await this.writeOutputFile(content, saveDir, reportFilename);
      savedFilePaths.push(reportPath);
      
      // Save thinking content if available and not skipped
      if (thinking) {
        const thinkingFilename = `${baseFilename}_thinking.txt`;
        const thinkingPath = path.join(saveDir, thinkingFilename);
        const thinkingContent = `=== NARRATIVE INTEGRITY CHECK TYPE ===
${checkType}

=== AI'S THINKING PROCESS ===

${thinking}

=== END AI'S THINKING PROCESS ===
${stats}`;
        
        await this.writeOutputFile(thinkingContent, saveDir, thinkingFilename);
        this.emitOutput(`AI thinking saved to: ${thinkingPath}\n`);
        savedFilePaths.push(thinkingPath);
      }

      this.emitOutput(`Report saved to: ${reportPath}\n`);
      return savedFilePaths;
    } catch (error) {
      console.error(`Error saving report:`, error);
      this.emitOutput(`Error saving report: ${error.message}\n`);
      throw error;
    }
  }
}

module.exports = NarrativeIntegrity;


============================================================
FILE: nonstreaming-example.js
SIZE: 7239 bytes
LANGUAGE: JS
============================================================

// Load environment variables from ~/.env
require('dotenv').config({ path: require('os').homedir() + '/.env' });
const anthropic = require('@anthropic-ai/sdk');
const fs = require('fs/promises');
const path = require('path');
const os = require('os');

// Usage: node nonstreaming-example.js <path-to-manuscript.txt>
const manuscriptPath = process.argv[2];
if (!manuscriptPath) {
  console.error('Error: Please provide the path to your manuscript .txt file.');
  console.error('Usage: node nonstreaming-example.js path/to/book.txt');
  process.exit(1);
}

// Ensure API key is set
const apiKey = process.env.ANTHROPIC_API_KEY;
if (!apiKey) {
  console.error('Error: `ANTHROPIC_API_KEY` environment variable not found.');
  process.exit(1);
}

// Instantiate Anthropic client with custom timeout and no retries
const client = new anthropic.Anthropic({
  apiKey: apiKey,
  timeout: 300 * 1000,   // 300 seconds in milliseconds
  maxRetries: 0,
});

// Read the manuscript text from disk
async function loadManuscript(filePath) {
  try {
    console.log(`Reading manuscript from: ${path.resolve(filePath)}`);
    return await fs.readFile(path.resolve(filePath), 'utf-8');
  } catch (err) {
    console.error(`Failed to read manuscript at ${filePath}:`, err.message);
    process.exit(1);
  }
}

/**
 * Send a non-streaming analysis request with dynamic prompts and display rate limit headers.
 * @param {string} num - The sequence number of the analysis
 * @param {{type:string,text:string,cache_control:object}} bookTextBlock - The manuscript content
 * @param {string} userQuery - The query to send to the API
 */
async function analyzeWith(num, bookTextBlock, userQuery) {
  console.log('Sending request to Claude API...');
  console.log(`Query: "${userQuery}"`);
  
  try {
    // Use beta.messages.create for non-streaming
    console.log('Using beta.messages.create API...');
    
    const systemMessages = [
      bookTextBlock
    ];
    
    // Make the non-streaming request
    const response = await client.beta.messages.create({
      model: 'claude-3-7-sonnet-20250219',
      max_tokens: 50000,
      system: systemMessages,
      messages: [{ role: 'user', content: userQuery }],
      thinking: { type: 'enabled', budget_tokens: 32000 },
      betas: ['output-128k-2025-02-19']
    });
    console.log(`client:\n${client}\n`);

    // Debug: Log the structure of the response object
    console.log('\n=== RESPONSE STRUCTURE ===');
    console.log(`response:\n${JSON.stringify(response)}\n`);
    console.log('Response keys:', Object.keys(response));
    
    // Attempt to access headers through various possible paths
    let headers = null;
    let headerSource = 'Not found';
    
    try {
      // Try different possible locations of headers
      if (response._response && response._response.headers) {
        headers = response._response.headers;
        headerSource = 'response._response.headers';
      } else if (response.httpResponse && response.httpResponse.headers) {
        headers = response.httpResponse.headers;
        headerSource = 'response.httpResponse.headers';
      } else if (response.metadata && response.metadata.headers) {
        headers = response.metadata.headers;
        headerSource = 'response.metadata.headers';
      }
      
      console.log('Headers found at:', headerSource);
      
      if (!headers) {
        // If still not found, log entire response for debugging
        console.log('Full response structure:');
        console.dir(response, { depth: 3 });
        console.log('=== END RESPONSE STRUCTURE ===\n');
        console.log('Unable to find headers in response object');
        return;
      }
    } catch (error) {
      console.error('Error accessing headers:', error);
      return;
    }
    
    console.log('\n=== RATE LIMIT HEADERS ===');
    const rateLimitHeaders = [
      'retry-after',
      'anthropic-ratelimit-requests-limit',
      'anthropic-ratelimit-requests-remaining',
      'anthropic-ratelimit-requests-reset',
      'anthropic-ratelimit-tokens-limit',
      'anthropic-ratelimit-tokens-remaining',
      'anthropic-ratelimit-tokens-reset',
      'anthropic-ratelimit-input-tokens-limit',
      'anthropic-ratelimit-input-tokens-remaining',
      'anthropic-ratelimit-input-tokens-reset',
      'anthropic-ratelimit-output-tokens-limit',
      'anthropic-ratelimit-output-tokens-remaining',
      'anthropic-ratelimit-output-tokens-reset'
    ];
    
    // Handle both Map-like headers (with .get()) and plain objects
    for (const header of rateLimitHeaders) {
      let value;
      if (typeof headers.get === 'function') {
        value = headers.get(header);
      } else {
        value = headers[header];
      }
      
      if (value) {
        console.log(`${header}: ${value}`);
      } else {
        console.log(`${header}: [not present]`);
      }
    }
    console.log('=== END RATE LIMIT HEADERS ===\n');
    
    // Display usage information if available
    if (response.usage) {
      console.log('\n=== USAGE METRICS ===');
      console.log('input_tokens:', response.usage.input_tokens || 0);
      console.log('output_tokens:', response.usage.output_tokens || 0);
      
      // Display cache metrics if available
      if (response.usage.cache_creation_input_tokens !== undefined ||
          response.usage.cache_read_input_tokens !== undefined) {
        console.log('cache_creation_input_tokens:', response.usage.cache_creation_input_tokens || 0);
        console.log('cache_read_input_tokens:', response.usage.cache_read_input_tokens || 0);
      }
      console.log('=== END USAGE METRICS ===\n');
    }
    
    // Display the response content
    console.log(`\n--- ${num}. CLAUDE RESPONSE ---\n`);
    
    // Extract and display the text content
    if (response.content) {
      for (const block of response.content) {
        if (block.type === 'text') {
          console.log(block.text);
        } else {
          console.log(`[Non-text content of type: ${block.type}]`);
        }
      }
    }
    
    console.log('\n\n--- END OF RESPONSE ---');
  } catch (error) {
    console.error('Error during API call:', error);
    console.error('Error details:', error.message);
    if (error.response) {
      console.error('Response error:', error.response);
    }
  }
}

// Main IIFE
;(async () => {
  try {
    console.log('Starting manuscript analysis...');
    const manuscriptContent = await loadManuscript(manuscriptPath);
    console.log(`Manuscript size: ${manuscriptContent.length} characters`);
    
    const BOOK_TEXT = { 
      type: 'text', 
      text: `=== MANUSCRIPT: A Darker Roast ===\n${manuscriptContent}\n=== END MANUSCRIPT: A Darker Roast ===`,
      cache_control: { type: 'ephemeral' } 
    };
    
    await analyzeWith(
      "1",
      BOOK_TEXT,
      'What is the last word in my manuscript.'
    );
    console.log('Analysis 1 complete.');
    
    await analyzeWith(
      "2",
      BOOK_TEXT,
      'You are an AI assistant specializing in thematic analysis of fiction. ' +
      'List the names of all of the characters in my manuscript.'
    );
    console.log('Analysis 2 complete.');
    
  } catch (error) {
    console.error('Unexpected error:', error);
  }
})();

============================================================
FILE: outline-writer.js
SIZE: 21296 bytes
LANGUAGE: JS
============================================================

// outline-writer.js
const BaseTool = require('./base-tool');
const path = require('path');
const fileCache = require('./file-cache');
const appState = require('./state.js');
const fs = require('fs/promises');

/**
 * OutlineWriter Tool
 * Generates a plot outline from your brainstorming file.
 * You can provide your own outline skeleton and let the AI fill in details.
 */
class OutlineWriter extends BaseTool {
  /**
   * Constructor
   * @param {Object} GeminiAPIService - Claude API service
   * @param {Object} config - Tool configuration
   */
  constructor(GeminiAPIService, config = {}) {
    super('outline_writer', config);
    this.GeminiAPIService = GeminiAPIService;
    // console.log('OutlineWriter Tool initialized with config:', config);
  }
  
  /**
   * Execute the tool
   * @param {Object} options - Tool options
   * @returns {Promise<Object>} - Execution result
   */
  async execute(options) {
    console.log('Executing OutlineWriter with options:', options);
    
    // Clear the cache for this tool
    const toolName = 'outline_writer';
    fileCache.clear(toolName);
    
    // Extract options
    const premiseFile = options.premise_file;
    const conceptFile = options.concept_file || null;
    const charactersFile = options.characters_file || null;
    const exampleOutline = options.example_outline || null;
    const sections = options.sections || 5;
    const chapters = options.chapters || 25;
    const language = options.lang || 'English';
    const title = options.title || null;
    const genre = options.genre || null;
    const detailed = options.detailed || false;
    
    const saveDir = options.save_dir || appState.CURRENT_PROJECT_PATH;
    const outputFiles = [];
    
    // Validate save directory
    if (!saveDir) {
      const errorMsg = 'Error: No save directory specified and no current project selected.\n' +
                      'Please select a project or specify a save directory.';
      this.emitOutput(errorMsg);
      throw new Error('No save directory available');
    }
    
    try {
      // Read premise file (required)
      this.emitOutput(`Reading premise file: ${premiseFile}\n`);
      const premiseContent = await this.readInputFile(this.ensureAbsolutePath(premiseFile, saveDir));
      
      // Read concept file if provided
      let conceptContent = "";
      if (conceptFile) {
        try {
          this.emitOutput(`Reading concept file: ${conceptFile}\n`);
          conceptContent = await this.readInputFile(this.ensureAbsolutePath(conceptFile, saveDir));
        } catch (error) {
          this.emitOutput(`Note: Concept file not found or couldn't be read: ${error.message}\n`);
          this.emitOutput("Continuing with just the premise description.\n");
        }
      }
      
      // Read characters file if provided
      let charactersContent = "";
      if (charactersFile) {
        try {
          this.emitOutput(`Reading characters file: ${charactersFile}\n`);
          charactersContent = await this.readInputFile(this.ensureAbsolutePath(charactersFile, saveDir));
        } catch (error) {
          this.emitOutput(`Note: Characters file not found or couldn't be read: ${error.message}\n`);
          this.emitOutput("Continuing without characters information.\n");
        }
      }
      
      // Read example outline if provided
      let exampleOutlineContent = "";
      if (exampleOutline) {
        try {
          this.emitOutput(`Reading example outline: ${exampleOutline}\n`);
          exampleOutlineContent = await this.readInputFile(this.ensureAbsolutePath(exampleOutline, saveDir));
        } catch (error) {
          this.emitOutput(`Note: Example outline file not found or couldn't be read: ${error.message}\n`);
          this.emitOutput("Continuing without example outline.\n");
        }
      }
      
      // Create prompt
      const prompt = this.createPrompt(
        premiseContent,
        conceptContent,
        charactersContent,
        exampleOutlineContent,
        sections,
        chapters,
        language,
        title,
        genre,
        detailed
      );
      
      // Count tokens in prompt
      this.emitOutput(`Counting tokens in prompt...\n`);
      const promptTokens = await this.GeminiAPIService.countTokens(prompt);
      
      // Calculate available tokens after prompt
      const contextWindow = this.config.context_window || 200000;
      const desiredOutputTokens = this.config.desired_output_tokens || 12000;
      const configuredThinkingBudget = this.config.thinking_budget_tokens || 32000;
      
      const availableTokens = contextWindow - promptTokens;
      
      // For API call, max_tokens must respect the API limit
      const maxTokens = Math.min(availableTokens, 128000); // Limited by beta feature
      
      // Thinking budget must be LESS than max_tokens to leave room for visible output
      let thinkingBudget = maxTokens - desiredOutputTokens;
      if (thinkingBudget > 32000) {
        this.emitOutput("Warning: thinking budget is larger than 32K, set to 32K.\n");
        thinkingBudget = 32000;
      }
      
      // Display token stats
      this.emitOutput(`\nToken stats:\n`);
      this.emitOutput(`Max AI model context window: [${contextWindow}] tokens\n`);
      this.emitOutput(`Input prompt tokens: [${promptTokens}] ...\n`);
      this.emitOutput(`                     = premise + concept + characters + example outline + prompt instructions\n`);
      this.emitOutput(`Available tokens: [${availableTokens}]  = ${contextWindow} - ${promptTokens} = context_window - prompt\n`);
      this.emitOutput(`Desired output tokens: [${desiredOutputTokens}]\n`);
      this.emitOutput(`AI model thinking budget: [${thinkingBudget}] tokens  = ${maxTokens} - ${desiredOutputTokens}\n`);
      this.emitOutput(`Max output tokens (max_tokens): [${maxTokens}] tokens  = min(${availableTokens}, 128000)\n`);
      this.emitOutput(`                                = can not exceed: 'betas=["output-128k-2025-02-19"]'\n`);
      
      // Check if prompt is too large for the configured thinking budget
      if (thinkingBudget < configuredThinkingBudget) {
        this.emitOutput(`Error: prompt is too large to have a ${configuredThinkingBudget} thinking budget!\n`);
        this.emitOutput(`Run aborted!\n`);
        throw new Error(`Prompt is too large for ${configuredThinkingBudget} thinking budget - run aborted`);
      }
      
      // Call Claude API with streaming
      this.emitOutput(`\nSending request to Claude API (streaming)...\n`);
      
      // Add a message about waiting
      this.emitOutput(`****************************************************************************\n`);
      this.emitOutput(`*  This usually takes a few minutes...\n`);
      this.emitOutput(`*  \n`);
      this.emitOutput(`*  It's recommended to keep this window the sole 'focus'\n`);
      this.emitOutput(`*  and to avoid browsing online or running other apps, as these API\n`);
      this.emitOutput(`*  network connections are often flakey, like delicate echoes of whispers.\n`);
      this.emitOutput(`*  \n`);
      this.emitOutput(`*  So breathe, remove eye glasses, stretch, relax, and be like water 🥋 🧘🏽‍♀️\n`);
      this.emitOutput(`****************************************************************************\n\n`);
      
      const startTime = Date.now();
      let fullResponse = "";
      let thinkingContent = "";
      
      // Create system prompt to avoid markdown
      const systemPrompt = "NO Markdown! Never respond with Markdown formatting, plain text only.";
      
      try {
        // Use streaming API call
        await this.GeminiAPIService.streamWithThinking(
          prompt,
          {
            model: "claude-3-7-sonnet-20250219",
            system: systemPrompt,
            max_tokens: maxTokens,
            thinking: {
              type: "enabled",
              budget_tokens: thinkingBudget
            },
            betas: ["output-128k-2025-02-19"]
          },
          // Callback for thinking content
          (thinkingDelta) => {
            thinkingContent += thinkingDelta;
          },
          // Callback for response text
          (textDelta) => {
            fullResponse += textDelta;
          }
        );
      } catch (error) {
        this.emitOutput(`\nAPI Error: ${error.message}\n`);
        throw error;
      }
      
      // Calculate time elapsed
      const elapsed = (Date.now() - startTime) / 1000;
      const minutes = Math.floor(elapsed / 60);
      const seconds = elapsed % 60;
      
      this.emitOutput(`\nCompleted in ${minutes}m ${seconds.toFixed(2)}s.\n`);
      
      // Process response - remove markdown formatting if any
      const cleanedResponse = this.removeMarkdownFormat(fullResponse);
      
      // Count words in response
      const wordCount = this.countWords(cleanedResponse);
      this.emitOutput(`Outline has approximately ${wordCount} words.\n`);
      
      // Count tokens in response
      const responseTokens = await this.GeminiAPIService.countTokens(cleanedResponse);
      this.emitOutput(`Outline token count: ${responseTokens}\n`);
      
      // Save the outline to a file
      const timestamp = new Date().toISOString().replace(/[-:.]/g, '').substring(0, 15);
      const outlineFilename = `outline_${timestamp}.txt`;
      const outlinePath = path.join(saveDir, outlineFilename);
      
      await this.writeOutputFile(cleanedResponse, saveDir, outlineFilename);
      this.emitOutput(`Outline saved to: ${outlinePath}\n`);
      
      // Add to output files list
      outputFiles.push(outlinePath);
      
      // Add to the file cache
      fileCache.addFile(toolName, outlinePath);
      
      // Save thinking content if available and not skipped
      if (thinkingContent) {
        const thinkingFilename = `outline_thinking_${timestamp}.txt`;
        
        // Create stats for thinking file
        const stats = `
Details:
Max request timeout: ${this.config.request_timeout || 300} seconds
Max AI model context window: ${this.config.context_window || 200000} tokens
AI model thinking budget: ${this.config.thinking_budget_tokens || 32000} tokens
Desired output tokens: ${this.config.desired_output_tokens || 12000} tokens

Estimated input/prompt tokens: ${promptTokens}
Setting max_tokens to: ${maxTokens}

elapsed time: ${minutes} minutes, ${seconds.toFixed(2)} seconds
Outline has ${wordCount} words
Outline token count: ${responseTokens}
Outline saved to: ${outlinePath}
`;
        
        // Create a prompt log without the full content
        const promptForLogging = this.createPromptForLogging(
          sections,
          chapters,
          language,
          title,
          genre,
          detailed
        );
        
        const thinkingContent2 = `=== PROMPT USED (EXCLUDING REFERENCE CONTENT) ===
${promptForLogging}

note: The actual prompt included any example outline, characters, and concept which are not logged here to save space.

=== AI'S THINKING PROCESS ===

${thinkingContent}

=== END AI'S THINKING PROCESS ===
${stats}`;
        
        await this.writeOutputFile(thinkingContent2, saveDir, thinkingFilename);
        const thinkingPath = path.join(saveDir, thinkingFilename);
        this.emitOutput(`AI thinking saved to: ${thinkingPath}\n`);
        
        // Add thinking file to output files and cache
        outputFiles.push(thinkingPath);
        fileCache.addFile(toolName, thinkingPath);
      }
      
      // Return the result
      return {
        success: true,
        outputFiles,
        stats: {
          wordCount,
          tokenCount: responseTokens,
          elapsedTime: `${minutes}m ${seconds.toFixed(2)}s`
        }
      };
      
    } catch (error) {
      console.error('Error in OutlineWriter:', error);
      this.emitOutput(`\nError: ${error.message}\n`);
      throw error;
    }
  }
  
  /**
   * Create prompt based on input content
   * @param {string} premiseContent - Premise content
   * @param {string} conceptContent - Concept content
   * @param {string} charactersContent - Characters content
   * @param {string} exampleOutlineContent - Example outline content
   * @param {number} sections - Number of sections
   * @param {number} chapters - Number of chapters
   * @param {string} language - Language
   * @param {string} title - Title
   * @param {string} genre - Genre
   * @param {boolean} detailed - Whether to generate detailed outline
   * @returns {string} - Prompt for Claude API
   */
  createPrompt(
    premiseContent,
    conceptContent,
    charactersContent,
    exampleOutlineContent,
    sections,
    chapters,
    language,
    title,
    genre,
    detailed
  ) {
    // Title and genre placeholders
    const titleSuggestion = title ? 
      `Suggested title: ${title}` : 
      "Please create an appropriate title for this novel.";
    
    const genreSuggestion = genre ? `Genre: ${genre}` : "";
    
    let prompt = `You are a skilled novelist and story architect helping to create a detailed novel outline in fluent, authentic ${language}.
Draw upon your knowledge of worldwide literary traditions, narrative structure, and plot development approaches from across cultures,
while expressing everything in natural, idiomatic ${language} that honors its unique linguistic character.

=== PREMISE ===
${premiseContent}
=== END PREMISE ===

=== CONCEPT ===
${conceptContent}
=== END CONCEPT ===

=== CHARACTERS ===
${charactersContent}
=== END CHARACTERS ===

=== EXAMPLE OUTLINE FORMAT ===
${exampleOutlineContent}
=== END EXAMPLE OUTLINE FORMAT ===

Create a detailed novel outline with approximately ${chapters} chapters organized into ${sections} main parts or sections.
${titleSuggestion}
${genreSuggestion}
Your outline should follow the general format and level of detail shown in the example (if provided), while being completely original.

Consider the following in your thinking:
- Refer to the included CHARACTERS, if provided
- Follow the structure of the EXAMPLE OUTLINE, if provided, but make proper adjustments for this novel
- Do NOT create new characters unless incidental ones like: cashiers, passers-by, if any, and these should remain without names
- Create a compelling narrative arc with rising tension, climax, and resolution
- Develop character arcs that show growth and change
- Include key plot points, conflicts, and important scenes
- Balance external plot with internal character development
- Ensure that each chapter has a clear purpose in advancing the story

IMPORTANT FORMATTING INSTRUCTIONS:
1. DO NOT use Markdown formatting (no #, ##, ###, *, **, etc.)
2. Start with "OUTLINE:" followed by the novel title on the next line
3. For parts/sections, use plain text like: "PART I: THE BEGINNING"
4. For chapters, use ONLY simple numbering like: "1. Chapter Title" (no "Chapter" word, just the number and title)
5. DO NOT include POV markers like "POV: Character"
6. For each chapter, include 4-6 bullet points describing key events and developments
7. Format each bullet point starting with "- " (dash followed by space)
8. Each bullet point should describe a single key event, character moment, or plot development
9. Make bullet points substantive but concise, focusing on important elements
10. Include an optional brief epilogue with bullet points if appropriate for the story
`;

    if (detailed) {
      prompt += `
11. For each chapter, include additional bullet points (up to 7-8 total) covering:
    - Key plot developments
    - Important character moments or revelations
    - Setting details
    - Thematic elements being developed
12. Keep all bullet points in the same format with "- " at the start of each point
`;
    }
    
    return prompt;
  }
  
  /**
   * Create a logging version of the prompt without file contents
   * @param {number} sections - Number of sections
   * @param {number} chapters - Number of chapters
   * @param {string} language - Language
   * @param {string} title - Title
   * @param {string} genre - Genre
   * @param {boolean} detailed - Whether to generate detailed outline
   * @returns {string} - Prompt for logging
   */
  createPromptForLogging(
    sections,
    chapters,
    language,
    title,
    genre,
    detailed
  ) {
    // Title and genre placeholders
    const titleSuggestion = title ? 
      `Suggested title: ${title}` : 
      "Please create an appropriate title for this novel.";
    
    const genreSuggestion = genre ? `Genre: ${genre}` : "";
    
    let prompt = `You are a skilled novelist and story architect helping to create a detailed novel outline in fluent, authentic ${language}.
Draw upon your knowledge of worldwide literary traditions, narrative structure, and plot development approaches from across cultures,
while expressing everything in natural, idiomatic ${language} that honors its unique linguistic character.

Create a detailed novel outline with approximately ${chapters} chapters organized into ${sections} main parts or sections.
${titleSuggestion}
${genreSuggestion}
Your outline should follow the general format and level of detail shown in the example (if provided), while being completely original.

Consider the following in your thinking:
- Refer to the included CHARACTERS, if provided
- Follow the structure of the EXAMPLE OUTLINE if provided
- Do NOT create new characters unless incidental ones like: cashiers, passers-by, if any, and these should remain without names
- Create a compelling narrative arc with rising tension, climax, and resolution
- Develop character arcs that show growth and change
- Include key plot points, conflicts, and important scenes
- Balance external plot with internal character development
- Ensure that each chapter has a clear purpose in advancing the story

IMPORTANT FORMATTING INSTRUCTIONS:
1. DO NOT use Markdown formatting (no #, ##, ###, *, **, etc.)
2. Start with "OUTLINE:" followed by the novel title on the next line
3. For parts/sections, use plain text like: "PART I: THE BEGINNING"
4. For chapters, use ONLY simple numbering like: "1. Chapter Title" (no "Chapter" word, just the number and title)
5. DO NOT include POV markers like "POV: Character"
6. For each chapter, include 4-6 bullet points describing key events and developments
7. Format each bullet point starting with "- " (dash followed by space)
8. Each bullet point should describe a single key event, character moment, or plot development
9. Make bullet points substantive but concise, focusing on important elements
10. Include an optional brief epilogue with bullet points if appropriate for the story
`;

    if (detailed) {
      prompt += `
11. For each chapter, include additional bullet points (up to 7-8 total) covering:
    - Key plot developments
    - Important character moments or revelations
    - Setting details
    - Thematic elements being developed
12. Keep all bullet points in the same format with "- " at the start of each point
`;
    }
    
    return prompt;
  }
  
  /**
   * Remove Markdown formatting from text
   * @param {string} text - Text with possible Markdown
   * @returns {string} - Cleaned text
   */
  removeMarkdownFormat(text) {
    // Replace Markdown headers with plain text format
    let cleaned = text.replace(/^#{1,6}\s+Chapter\s+(\d+):\s+(.*?)$/gm, '$1. $2');
    cleaned = cleaned.replace(/^#{1,6}\s+PART\s+([IVXLCDM]+):\s+(.*?)$/gm, 'PART $1: $2');
    cleaned = cleaned.replace(/^#{1,6}\s+(.*?)$/gm, '$1');
    
    // Remove POV markers
    cleaned = cleaned.replace(/POV:\s+\w+\s*$/gm, '');
    cleaned = cleaned.replace(/POV:\s+\w+\s*\n/gm, '\n');
    
    // Replace special quotes with regular quotes
    cleaned = cleaned.replace(/[""]/g, '"');
    cleaned = cleaned.replace(/['']/g, "'");
    
    // Remove Markdown formatting
    cleaned = cleaned.replace(/\*\*(.*?)\*\*/g, '$1');  // Bold
    cleaned = cleaned.replace(/\*(.*?)\*/g, '$1');      // Italic
    cleaned = cleaned.replace(/`(.*?)`/g, '$1');        // Code
    cleaned = cleaned.replace(/^\s*[-*+]\s+/gm, '- ');  // Standardize bullet points
    
    // Clean up any extra spaces but preserve line breaks
    cleaned = cleaned.replace(/ +/g, ' ');
    cleaned = cleaned.replace(/ +\n/g, '\n');
    cleaned = cleaned.replace(/\n +/g, '\n');
    
    // Ensure consistent chapter formatting when numbers are present
    cleaned = cleaned.replace(/^Chapter\s+(\d+):\s+(.*?)$/gm, '$1. $2');
    
    return cleaned;
  }
  
  /**
   * Count words in text
   * @param {string} text - Text to count words in
   * @returns {number} - Word count
   */
  countWords(text) {
    return text.replace(/(\r\n|\r|\n)/g, ' ').split(/\s+/).filter(word => word.length > 0).length;
  }
  
  /**
   * Ensure file path is absolute
   * @param {string} filePath - File path (may be relative or absolute)
   * @param {string} basePath - Base path to prepend for relative paths
   * @returns {string} - Absolute file path
   */
  ensureAbsolutePath(filePath, basePath) {
    if (!filePath) return filePath;
    
    // Check if the path is already absolute
    if (path.isAbsolute(filePath)) {
      return filePath;
    }
    
    // Make the path absolute by joining with the base path
    return path.join(basePath, filePath);
  }
}

module.exports = OutlineWriter;

============================================================
FILE: plot-thread-tracker.js
SIZE: 20539 bytes
LANGUAGE: JS
============================================================

// plot-thread-tracker.js
const BaseTool = require('./base-tool');
const path = require('path');
const util = require('util');
const fileCache = require('./file-cache');
const appState = require('./state.js');
const fs = require('fs/promises');

/**
 * Plot Thread Tracker Tool
 * Analyzes manuscript to identify and track distinct plot threads using the Claude API.
 * Shows how plot threads interconnect, converge, and diverge throughout the narrative.
 */
class PlotThreadTracker extends BaseTool {
  /**
   * Constructor
   * @param {Object} GeminiAPIService - Claude API service
   * @param {Object} config - Tool configuration
   */
  constructor(GeminiAPIService, config = {}) {
    super('plot_thread_tracker', config);
    this.GeminiAPIService = GeminiAPIService;
  }

  /**
   * Execute the tool
   * @param {Object} options - Tool options
   * @returns {Promise<Object>} - Execution result
   */
  async execute(options) {
    console.log('Executing Plot Thread Tracker with options:', options);
    
    // Extract options
    let manuscriptFile = options.manuscript_file;
    const analysisDepth = options.analysis_depth;
    const outlineFile = options.outline_file;
    const threadFocus = options.thread_focus;
    const useAsciiArt = options.ascii_art;
    const saveDir = options.save_dir || appState.CURRENT_PROJECT_PATH;
    
    if (!saveDir) {
      const errorMsg = 'Error: No save directory specified and no current project selected.\n' +
                      'Please select a project or specify a save directory.';
      this.emitOutput(errorMsg);
      throw new Error('No save directory available');
    }

    // Ensure file paths are absolute
    manuscriptFile = this.ensureAbsolutePath(manuscriptFile, saveDir);
    let outlineFilePath = null;
    if (outlineFile) {
      outlineFilePath = this.ensureAbsolutePath(outlineFile, saveDir);
    }
    
    // Log the full paths for debugging
    console.log('Using full paths:');
    console.log(`Manuscript: ${manuscriptFile}`);
    if (outlineFilePath) {
      console.log(`Outline: ${outlineFilePath}`);
    }

    const outputFiles = [];
    
    try {
      // Read the input files
      this.emitOutput(`Reading files...\n`);

      // Read the manuscript file
      this.emitOutput(`Reading manuscript file: ${manuscriptFile}\n`);
      const manuscriptContent = await this.readInputFile(manuscriptFile);
      
      // Read the outline file if provided
      let outlineContent = "";
      if (outlineFilePath) {
        this.emitOutput(`Reading outline file: ${outlineFilePath}\n`);
        outlineContent = await this.readInputFile(outlineFilePath);
      } else {
        this.emitOutput(`No outline file provided.\n`);
      }
      
      // Create the prompt
      const prompt = this.createPlotThreadPrompt(
        analysisDepth, 
        outlineContent, 
        manuscriptContent,
        threadFocus,
        useAsciiArt
      );

      // Count tokens in the prompt
      this.emitOutput(`Counting tokens in prompt...\n`);
      const promptTokens = await this.GeminiAPIService.countTokens(prompt);

      // Call the shared token budget calculator
      const tokenBudgets = this.GeminiAPIService.calculateTokenBudgets(promptTokens);

      // Handle logging based on the returned values
      this.emitOutput(`\nToken stats:\n`);
      this.emitOutput(`Max AI model context window: [${tokenBudgets.contextWindow}] tokens\n`);
      this.emitOutput(`Input prompt tokens: [${tokenBudgets.promptTokens}] ...\n`);
      this.emitOutput(`                     = manuscript + outline + prompt instructions\n`);
      this.emitOutput(`Available tokens: [${tokenBudgets.availableTokens}]  = ${tokenBudgets.contextWindow} - ${tokenBudgets.promptTokens} = context_window - prompt\n`);
      this.emitOutput(`Desired output tokens: [${tokenBudgets.desiredOutputTokens}]\n`);
      this.emitOutput(`AI model thinking budget: [${tokenBudgets.thinkingBudget}] tokens\n`);
      this.emitOutput(`Max output tokens: [${tokenBudgets.maxTokens}] tokens\n`);

      // Check for special conditions
      if (tokenBudgets.capThinkingBudget) {
        this.emitOutput(`Warning: thinking budget is larger than 32K, set to 32K.\n`);
      }

      // Check if the prompt is too large
      if (tokenBudgets.isPromptTooLarge) {
        this.emitOutput(`Error: prompt is too large to have a ${tokenBudgets.configuredThinkingBudget} thinking budget!\n`);
        this.emitOutput(`Run aborted!\n`);
        throw new Error(`Prompt is too large for ${tokenBudgets.configuredThinkingBudget} thinking budget - run aborted`);
      }
      
      // Call Claude API with streaming
      this.emitOutput(`>>> Sending request to Claude API (streaming)...\n`);

      // Add a message about waiting
      this.emitOutput(`****************************************************************************\n`);
      this.emitOutput(`*  Analyzing plot threads in your manuscript...                            \n`);
      this.emitOutput(`*  This process typically takes several minutes.                           \n`);
      this.emitOutput(`*                                                                          \n`);
      this.emitOutput(`*  It's recommended to keep this window the sole 'focus'                   \n`);
      this.emitOutput(`*  and to avoid browsing online or running other apps, as these API        \n`);
      this.emitOutput(`*  network connections are often flakey, like delicate echoes of whispers. \n`);
      this.emitOutput(`*                                                                          \n`);
      this.emitOutput(`*  So breathe, remove eye glasses, stretch, relax, and be like water 🥋 🧘🏽‍♀️\n`);
      this.emitOutput(`****************************************************************************\n\n`);
      
      const startTime = Date.now();
      let fullResponse = "";
      let thinkingContent = "";
      
      // Create system prompt to avoid markdown
      const systemPrompt = "CRITICAL INSTRUCTION: NO Markdown formatting of ANY kind. Never use headers, bullets, or any formatting symbols. Plain text only with standard punctuation.";

      // Use the calculated values in the API call
      try {
        await this.GeminiAPIService.streamWithThinking(
          prompt,
          {
            system: systemPrompt,
            max_tokens: tokenBudgets.maxTokens,
            thinking: {
              type: "enabled",
              budget_tokens: tokenBudgets.thinkingBudget
            }
          },
          // Callback for thinking content
          (thinkingDelta) => {
            thinkingContent += thinkingDelta;
          },
          // Callback for response text
          (textDelta) => {
            fullResponse += textDelta;
          }
        );
      } catch (error) {
        this.emitOutput(`\nAPI Error: ${error.message}\n`);
        throw error;
      }

      const elapsed = (Date.now() - startTime) / 1000;
      const minutes = Math.floor(elapsed / 60);
      const seconds = elapsed % 60;
      
      this.emitOutput(`\nCompleted in ${minutes}m ${seconds.toFixed(2)}s.\n`);
      
      // Count words in response
      const wordCount = this.countWords(fullResponse);
      this.emitOutput(`Report has approximately ${wordCount} words.\n`);
      
      // Count tokens in response
      const responseTokens = await this.GeminiAPIService.countTokens(fullResponse);
      this.emitOutput(`Response token count: ${responseTokens}\n`);

      // Remove any markdown formatting
      fullResponse = this.removeMarkdown(fullResponse);

      // Format thread focus for reporting
      const threadFocusStr = threadFocus ? (Array.isArray(threadFocus) ? threadFocus.join(", ") : threadFocus) : "All threads";

      // Save the report
      const outputFile = await this.saveReport(
        analysisDepth,
        threadFocusStr,
        useAsciiArt,
        fullResponse,
        thinkingContent,
        promptTokens,
        responseTokens,
        saveDir
      );
      
      // Add all output files to the result
      outputFiles.push(...outputFile);
      
      // Add files to the cache
      const toolName = 'plot_thread_tracker';
      outputFiles.forEach(file => {
        fileCache.addFile(toolName, file);
      });
      
      // Return the result
      return {
        success: true,
        outputFiles,
        stats: {
          wordCount,
          tokenCount: responseTokens,
          elapsedTime: `${minutes}m ${seconds.toFixed(2)}s`,
          analysisDepth,
          threadFocus: threadFocusStr,
          useAsciiArt
        }
      };
    } catch (error) {
      console.error('Error in PlotThreadTracker:', error);
      this.emitOutput(`\nError: ${error.message}\n`);
      throw error;
    }
  }
  
  /**
   * Create plot thread analysis prompt
   * @param {string} analysisDepth - Analysis depth (basic, detailed, comprehensive)
   * @param {string} outlineContent - Outline content
   * @param {string} manuscriptContent - Manuscript content
   * @param {Array|string} threadFocus - Optional specific threads to focus on
   * @param {boolean} useAsciiArt - Whether to include ASCII art visualizations
   * @returns {string} - Prompt for Claude API
   */
  createPlotThreadPrompt(analysisDepth = "comprehensive", outlineContent = "", manuscriptContent, threadFocus = null, useAsciiArt = false) {
    const noMarkdown = "IMPORTANT: - NO Markdown formatting";
    
    let threadFocusStr = "";
    if (threadFocus) {
      if (Array.isArray(threadFocus)) {
        threadFocusStr = `Pay special attention to these specific plot threads: ${threadFocus.join(', ')}.`;
      } else {
        threadFocusStr = `Pay special attention to these specific plot threads: ${threadFocus}.`;
      }
    }
    
    let asciiInstruction = "";
    if (useAsciiArt) {
      asciiInstruction = `
Include simple ASCII art visualizations to represent:
- Thread progressions using horizontal timelines (e.g., Thread A: ----*----*------>)
- Thread connections using branching symbols (e.g., +-- for connections)
- Thread intensity using symbols like | (low), || (medium), ||| (high)
`;
    }
    
    const prompts = {
      "basic": `=== OUTLINE ===
${outlineContent}
=== END OUTLINE ===

=== MANUSCRIPT ===
${manuscriptContent}
=== END MANUSCRIPT ===

${noMarkdown}

You are an expert fiction editor specializing in narrative structure and plot analysis. Conduct a BASIC plot thread analysis of the manuscript, focusing on the main storylines and how they progress. ${threadFocusStr}

Focus on identifying:

1. MAIN PLOT THREADS:
   - Identify 3-5 major plot threads running through the manuscript
   - Provide a clear name and short description for each thread
   - Note the primary characters involved in each thread

2. THREAD PROGRESSION:
   - For each identified thread, track where it appears in the manuscript
   - Note key progression points (beginning, major developments, resolution)
   - Provide manuscript locations (using exact text excerpts) for each point

3. BASIC THREAD CONNECTIONS:
   - Identify where major plot threads intersect or influence each other
   - Note convergence points where multiple threads come together
   - Highlight any threads that remain isolated from others

${asciiInstruction}

Organize your analysis by thread, showing each thread's progression and key connection points with other threads. For each thread, include:
- Thread name and description
- Key progression points with manuscript locations
- Major connections to other threads

Present the information in a clear, structured format that makes the plot architecture easy to understand without requiring graphics.`,

      "detailed": `=== OUTLINE ===
${outlineContent}
=== END OUTLINE ===

=== MANUSCRIPT ===
${manuscriptContent}
=== END MANUSCRIPT ===

${noMarkdown}

You are an expert fiction editor specializing in narrative structure and plot analysis. Conduct a DETAILED plot thread analysis of the manuscript, tracking how multiple storylines develop and interconnect. ${threadFocusStr}

Focus on identifying:

1. PLOT THREAD IDENTIFICATION:
   - Identify all significant plot threads running through the manuscript
   - Classify threads as main plot, subplot, character arc, thematic thread, etc.
   - Provide a clear name and description for each thread
   - Note the primary and secondary characters involved in each thread

2. THREAD PROGRESSION MAPPING:
   - For each thread, track its complete progression through the manuscript
   - Map the initiation, development stages, climax, and resolution
   - Note the intensity/prominence of the thread at different points
   - Identify when threads go dormant and reactivate

3. INTERCONNECTION ANALYSIS:
   - Map where and how plot threads connect to each other
   - Identify causal relationships between thread developments
   - Note where threads converge, diverge, or conflict
   - Analyze how threads support or undermine each other

4. NARRATIVE STRUCTURE ASSESSMENT:
   - Identify how threads align with overall narrative structure
   - Note how multiple threads build toward key story moments
   - Assess thread balance and pacing across the manuscript

${asciiInstruction}

Present your analysis as:
1. A thread directory listing all identified threads with descriptions
2. A progression map for each thread showing its development points
3. An interconnection analysis showing how threads relate to each other
4. A narrative assessment of the overall plot architecture

For each thread entry, include:
- Thread name, type, and key characters
- Detailed progression points with manuscript locations
- Connection points with other threads
- Assessment of thread effectiveness

Use text formatting to create a clear visual structure that shows the relationships between threads without requiring graphics.`,

      "comprehensive": `=== OUTLINE ===
${outlineContent}
=== END OUTLINE ===

=== MANUSCRIPT ===
${manuscriptContent}
=== END MANUSCRIPT ===

${noMarkdown}

You are an expert fiction editor specializing in narrative structure and plot architecture. Conduct a COMPREHENSIVE plot thread analysis of the manuscript, creating a detailed visualization of how all narrative elements interconnect. ${threadFocusStr}

Focus on identifying:

1. COMPLETE THREAD IDENTIFICATION:
   - Identify ALL plot threads: main plot, subplots, character arcs, thematic threads, mystery threads, etc.
   - Provide a clear name, type classification, and detailed description for each thread
   - Note all characters involved in each thread with their roles
   - Identify the narrative purpose of each thread

2. DETAILED PROGRESSION TRACKING:
   - For each thread, map its complete journey through the manuscript
   - Track the setup, development stages, complications, climax, resolution
   - Measure thread intensity/prominence at each appearance (minor mention vs. focal point)
   - Note when threads transform or evolve in purpose
   - Track emotional tone shifts within threads

3. COMPLEX INTERCONNECTION MAPPING:
   - Create a detailed map of all thread connections and relationships
   - Identify direct and indirect influences between threads
   - Note where threads support, undermine, mirror, or contrast each other
   - Map causal chains that span multiple threads
   - Identify connection hubs where multiple threads converge

4. STRUCTURAL ARCHITECTURE ANALYSIS:
   - Analyze how threads combine to create the overall narrative structure
   - Identify patterns in how threads are arranged and interwoven
   - Note rhythm and pacing across multiple threads
   - Identify structural strengths and weaknesses in the thread architecture

${asciiInstruction}

Present your analysis in four main sections:
1. THREAD DIRECTORY - Comprehensive listing of all threads with detailed descriptions
2. PROGRESSION MAPS - Detailed development tracking for each thread
3. INTERCONNECTION ATLAS - Mapping of how all threads relate to and influence each other
4. ARCHITECTURAL ASSESSMENT - Analysis of the overall narrative structure created by the threads

For the Interconnection Atlas, create a text-based visualization that shows:
- Direct connections between threads (with connection types)
- Hub points where multiple threads converge
- Patterns of thread interaction throughout the manuscript

Use precise manuscript locations (with exact quotes) to anchor your analysis throughout.`
    };
    
    return prompts[analysisDepth] || prompts["comprehensive"];
  }

  /**
   * Count words in text
   * @param {string} text - Text to count words in
   * @returns {number} - Word count
   */
  countWords(text) {
    return text.replace(/(\r\n|\r|\n)/g, ' ').split(/\s+/).filter(word => word.length > 0).length;
  }
  
  /**
   * Ensure file path is absolute
   * @param {string} filePath - File path (may be relative or absolute)
   * @param {string} basePath - Base path to prepend for relative paths
   * @returns {string} - Absolute file path
   */
  ensureAbsolutePath(filePath, basePath) {
    if (!filePath) return filePath;
    
    // Check if the path is already absolute
    if (path.isAbsolute(filePath)) {
      return filePath;
    }
    
    // Make the path absolute by joining with the base path
    return path.join(basePath, filePath);
  }
  
  /**
   * Save report and thinking content to files
   * @param {string} analysisDepth - Analysis depth (basic, detailed, comprehensive)
   * @param {string} threadFocusStr - Thread focus string
   * @param {boolean} useAsciiArt - Whether ASCII art was used
   * @param {string} content - Response content
   * @param {string} thinking - Thinking content
   * @param {number} promptTokens - Prompt token count
   * @param {number} responseTokens - Response token count
   * @param {string} saveDir - Directory to save to
   * @returns {Promise<string[]>} - Array of paths to saved files
   */
  async saveReport(
    analysisDepth,
    threadFocusStr,
    useAsciiArt,
    content,
    thinking,
    promptTokens,
    responseTokens,
    saveDir
  ) {
    try {
      const formatter = new Intl.DateTimeFormat('en-US', {
        weekday: 'long',
        month: 'long',
        day: 'numeric',
        year: 'numeric',
        hour: 'numeric',
        minute: '2-digit',
        hour12: true
      });
      const dateTimeStr = formatter.format(new Date());

      // Create timestamp for filename
      const timestamp = new Date().toISOString().replace(/[-:.]/g, '').substring(0, 15);
      
      // Create descriptive filename
      const desc = description ? `_${description}` : '';
      const level = analysisDepth !== 'comprehensive' ? `_${analysisDepth}` : '';
      const baseFilename = `plot_thread_analysis${desc}${level}_${timestamp}`;
      
      // Array to collect all saved file paths
      const savedFilePaths = [];
      
      // Create stats for thinking file
      const stats = `
Details:  ${dateTimeStr}
Analysis type: Plot thread analysis
Analysis depth: ${analysisDepth}
Thread focus: ${threadFocusStr}
ASCII art: ${useAsciiArt ? 'Enabled' : 'Disabled'}
Max request timeout: ${this.config.request_timeout} seconds
Max AI model context window: ${this.config.context_window} tokens
AI model thinking budget: ${this.config.thinking_budget_tokens} tokens
Desired output tokens: ${this.config.desired_output_tokens} tokens

Input tokens: ${promptTokens}
Output tokens: ${responseTokens}
`;
      
      // Save full response
      const reportFilename = `${baseFilename}.txt`;
      const reportPath = path.join(saveDir, reportFilename);
      await this.writeOutputFile(content, saveDir, reportFilename);
      savedFilePaths.push(reportPath);
      
      // Save thinking content if available and not skipped
      if (thinking) {
        const thinkingFilename = `${baseFilename}_thinking.txt`;
        const thinkingPath = path.join(saveDir, thinkingFilename);
        const thinkingContent = `=== PLOT THREAD ANALYSIS ===

=== AI'S THINKING PROCESS ===

${thinking}

=== END AI'S THINKING PROCESS ===
${stats}`;
        
        await this.writeOutputFile(thinkingContent, saveDir, thinkingFilename);
        this.emitOutput(`AI thinking saved to: ${thinkingPath}\n`);
        savedFilePaths.push(thinkingPath);
      }

      this.emitOutput(`Report saved to: ${reportPath}\n`);
      return savedFilePaths;
    } catch (error) {
      console.error(`Error saving report:`, error);
      this.emitOutput(`Error saving report: ${error.message}\n`);
      throw error;
    }
  }
}

module.exports = PlotThreadTracker;


============================================================
FILE: preload.js
SIZE: 3756 bytes
LANGUAGE: JS
============================================================

const { contextBridge, ipcRenderer } = require('electron');

// Expose protected methods that allow the renderer process to use
// the ipcRenderer without exposing the entire object
contextBridge.exposeInMainWorld('electronAPI', {
  // Quit application
  quitApp: () => ipcRenderer.send('app-quit'),
  
  // Project management
  getProjects: () => ipcRenderer.invoke('get-projects'),
  getProjectInfo: () => ipcRenderer.invoke('get-project-info'),
  selectProject: () => ipcRenderer.send('show-project-dialog'),
  openProject: (projectName) => ipcRenderer.invoke('open-project', projectName),
  createProject: (projectName) => ipcRenderer.invoke('create-project', projectName),
  closeDialog: (action, data) => ipcRenderer.send('close-project-dialog', action, data),
  onProjectUpdated: (callback) => ipcRenderer.on('project-updated', (_, data) => callback(data)),
  // Launch the text editor
  launchEditor: () => ipcRenderer.invoke('launch-editor'),
  
  // General file handling
  selectFile: (options) => ipcRenderer.invoke('select-file', options),
  selectDirectory: (options) => ipcRenderer.invoke('select-directory', options),
  
  // Tool management
  getTools: () => ipcRenderer.invoke('get-tools'),
  getToolOptions: (toolName) => ipcRenderer.invoke('get-tool-options', toolName),
  showToolSetupDialog: (toolName) => ipcRenderer.send('show-tool-setup-dialog', toolName),
  closeToolDialog: (action, data) => ipcRenderer.send('close-tool-dialog', action, data),
  getCurrentTool: () => ipcRenderer.invoke('get-current-tool'),
  startToolRun: (toolName, options) => ipcRenderer.invoke('start-tool-run', toolName, options),
  stopTool: (runId) => ipcRenderer.invoke('stop-tool', runId),
  setToolOptions: (options) => ipcRenderer.invoke('set-tool-options', options),
  onToolOutput: (callback) => ipcRenderer.on('tool-output', (_, data) => callback(data)),
  onToolFinished: (callback) => ipcRenderer.on('tool-finished', (_, data) => callback(data)),
  onToolError: (callback) => ipcRenderer.on('tool-error', (_, data) => callback(data)),
  removeAllListeners: (channel) => {
    if (channel === 'tool-output') ipcRenderer.removeAllListeners('tool-output');
    if (channel === 'tool-finished') ipcRenderer.removeAllListeners('tool-finished');
    if (channel === 'tool-error') ipcRenderer.removeAllListeners('tool-error');
  },
  // Get output files for a tool run
  getToolOutputFiles: (toolId) => ipcRenderer.invoke('get-tool-output-files', toolId),

  // Open a file in the editor - UNCOMMENTED THIS LINE
  openFileInEditor: (filePath) => ipcRenderer.invoke('open-file-in-editor', filePath),  
  
  // Editor dialog functions
  showEditorDialog: (filePath) => ipcRenderer.send('show-editor-dialog', filePath),
  saveFile: (data) => ipcRenderer.invoke('save-file', data),
  closeEditorDialog: () => ipcRenderer.send('close-editor-dialog'),
  onFileOpened: (callback) => ipcRenderer.on('file-opened', (_, data) => callback(data)),

  // API settings
  getClaudeApiSettings: () => ipcRenderer.invoke('get-claude-api-settings'),
  saveClaudeApiSettings: (settings) => ipcRenderer.invoke('save-claude-api-settings', settings),
  showApiSettingsDialog: () => ipcRenderer.send('show-api-settings-dialog'),
  closeApiSettingsDialog: (action, data) => ipcRenderer.send('close-api-settings-dialog', action, data),
  onApiSettingsUpdated: (callback) => ipcRenderer.on('api-settings-updated', (_, data) => callback(data)),
  
  onSetTheme: (callback) => ipcRenderer.on('set-theme', (_, theme) => callback(theme)),

  convertDocxToTxt: (docxPath, outputFilename) => ipcRenderer.invoke('convert-docx-to-txt', docxPath, outputFilename),

  convertTxtToDocx: (txtPath, outputFilename) => ipcRenderer.invoke('convert-txt-to-docx', txtPath, outputFilename),
});


============================================================
FILE: project-dialog.js
SIZE: 5016 bytes
LANGUAGE: JS
============================================================

// Get references to DOM elements
const projectSelect = document.getElementById('project-select');
const newProjectNameInput = document.getElementById('new-project-name');
const openProjectBtn = document.getElementById('open-project-btn');
const createProjectBtn = document.getElementById('create-project-btn');
const cancelBtn = document.getElementById('cancel-btn');

// Disable the open button initially (until a project is selected)
openProjectBtn.disabled = true;
openProjectBtn.style.opacity = '0.6';
openProjectBtn.style.cursor = 'not-allowed';

// When the page loads, fetch the list of existing projects
document.addEventListener('DOMContentLoaded', async () => {
  try {
    // Get the list of projects from the main process
    const projects = await window.electronAPI.getProjects();
    
    // Clear any existing options (except the placeholder)
    while (projectSelect.options.length > 1) {
      projectSelect.remove(1);
    }
    
    // Add projects to the select dropdown
    projects.forEach(project => {
      const option = document.createElement('option');
      option.value = project;
      option.textContent = project;
      projectSelect.appendChild(option);
    });
    
    // If there are no projects, show a message
    if (projects.length === 0) {
      const option = document.createElement('option');
      option.value = "";
      option.textContent = "No existing projects found";
      option.disabled = true;
      projectSelect.appendChild(option);
    }
  } catch (error) {
    console.error('Error fetching projects:', error);
    showError('Failed to load projects. Please try again.');
  }
});

// Enable/disable the open button based on selection
projectSelect.addEventListener('change', () => {
  if (projectSelect.value) {
    openProjectBtn.disabled = false;
    openProjectBtn.style.opacity = '1';
    openProjectBtn.style.cursor = 'pointer';
  } else {
    openProjectBtn.disabled = true;
    openProjectBtn.style.opacity = '0.6';
    openProjectBtn.style.cursor = 'not-allowed';
  }
});

// Handle opening an existing project
openProjectBtn.addEventListener('click', async () => {
  const selectedProject = projectSelect.value;
  
  if (!selectedProject) {
    showError('Please select a project first');
    return;
  }
  
  try {
    const result = await window.electronAPI.openProject(selectedProject);
    
    if (result.success) {
      // Close the dialog and notify the parent window
      window.electronAPI.closeDialog('project-selected', { 
        projectName: selectedProject,
        projectPath: result.projectPath
      });
    } else {
      showError(result.message || 'Failed to open project');
    }
  } catch (error) {
    console.error('Error opening project:', error);
    showError('An error occurred while opening the project');
  }
});

// Handle creating a new project
createProjectBtn.addEventListener('click', async () => {
  const projectName = newProjectNameInput.value.trim();
  
  if (!projectName) {
    showError('Please enter a project name');
    return;
  }
  
  // Validate project name (no special characters)
  const invalidChars = /[<>:"/\\|?*]/;
  if (invalidChars.test(projectName)) {
    showError('Project name contains invalid characters');
    return;
  }
  
  try {
    const result = await window.electronAPI.createProject(projectName);
    
    if (result.success) {
      // Close the dialog and notify the parent window
      window.electronAPI.closeDialog('project-created', {
        projectName: projectName,
        projectPath: result.projectPath
      });
    } else {
      showError(result.message || 'Failed to create project');
    }
  } catch (error) {
    console.error('Error creating project:', error);
    showError('An error occurred while creating the project');
  }
});

// Handle cancel button
cancelBtn.addEventListener('click', () => {
  window.electronAPI.closeDialog('cancelled');
});

// Helper function to show errors
function showError(message) {
  // Create a simple error notification
  const notification = document.createElement('div');
  notification.textContent = message;
  notification.style.cssText = `
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    background-color: #f44336;
    color: white;
    padding: 12px 24px;
    border-radius: 4px;
    z-index: 1000;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
  `;
  
  document.body.appendChild(notification);
  
  // Remove after 3 seconds
  setTimeout(() => {
    notification.style.opacity = '0';
    notification.style.transition = 'opacity 0.5s';
    setTimeout(() => {
      document.body.removeChild(notification);
    }, 500);
  }, 3000);
}

// Listen for theme messages from the main process
window.electronAPI.onSetTheme((theme) => {
  if (theme === 'light') {
    document.body.classList.remove('dark-mode');
    document.body.classList.add('light-mode');
  } else {
    document.body.classList.remove('light-mode');
    document.body.classList.add('dark-mode');
  }
});


============================================================
FILE: proofreader_cached_gemini25.js
SIZE: 24050 bytes
LANGUAGE: JS
============================================================

// proofreader_gemini25_cached.js
const {
    GoogleGenAI,
    HarmCategory,
    HarmBlockThreshold,
    createUserContent,
    createPartFromUri,
} = require('@google/genai');
const fs = require('fs');
const path = require('path');

async function main() {
  const apiKeyFromEnv = process.env.GEMINI_API_KEY;
  if (!apiKeyFromEnv) {
    console.error("ERROR: GEMINI_API_KEY environment variable is not set.");
    process.exit(1);
  }

  const ai = new GoogleGenAI({ apiKey: apiKeyFromEnv });

  const manuscriptFilePath = 'cls_manuscript.txt';
  let manuscriptContent = ''; // For size log

  try {
    if (!fs.existsSync(manuscriptFilePath)) {
      console.error(`ERROR: Manuscript file not found at: ${manuscriptFilePath}`);
      process.exit(1);
    }
    manuscriptContent = fs.readFileSync(manuscriptFilePath, 'utf8');
    console.log(`Successfully read content from ${manuscriptFilePath} (Size: ${Buffer.byteLength(manuscriptContent, 'utf8')} bytes).`);
  } catch (fileReadError) {
    console.error(`ERROR: Failed to read file '${manuscriptFilePath}'.`);
    console.error("File read error details:", fileReadError.message);
    process.exit(1);
  }

  let uploadedFileMetadata;
  try {
    console.log(`\n--- Uploading File to Gemini via ai.files.upload: ${manuscriptFilePath} ---`);
    const uploadStartTime = new Date();

    const uploadParams = {
      file: manuscriptFilePath,
      config: {
        mimeType: 'text/plain',
        displayName: `Manuscript: ${path.basename(manuscriptFilePath)}`
      }
    };

    if (!(ai.files && typeof ai.files.upload === 'function')) {
      console.error("CRITICAL ERROR: 'ai.files.upload' is NOT a function. Cannot proceed with file upload.");
      process.exit(1);
    }
    console.log("Using ai.files.upload() with params:", JSON.stringify(uploadParams, null, 2));
    const uploadResponse = await ai.files.upload(uploadParams);

    if (uploadResponse && uploadResponse.uri && uploadResponse.mimeType) {
      uploadedFileMetadata = uploadResponse;
    } else {
      console.error("ERROR: Uploaded file response from 'ai.files.upload' is not in the expected 'File' object format or is missing 'uri'/'mimeType'.");
      console.error("Received response:", JSON.stringify(uploadResponse, null, 2));
      process.exit(1);
    }

    const uploadEndTime = new Date();
    const uploadDurationMs = uploadEndTime.getTime() - uploadStartTime.getTime();
    console.log(`File uploaded successfully via ai.files in ${(uploadDurationMs / 1000).toFixed(2)} seconds.`);
    console.log(`Uploaded File URI: ${uploadedFileMetadata.uri}`);
    console.log(`Uploaded File MIME Type: ${uploadedFileMetadata.mimeType}`);
    if (uploadedFileMetadata.name) console.log(`Uploaded File Name (ID): ${uploadedFileMetadata.name}`);
    if (uploadedFileMetadata.displayName) console.log(`Uploaded File Display Name: ${uploadedFileMetadata.displayName}`);
    if (uploadedFileMetadata.sizeBytes) console.log(`Uploaded File Size (from API): ${uploadedFileMetadata.sizeBytes} bytes`);
    console.log(`--- End of File Upload ---`);

  } catch (uploadError) {
    console.error(`\nERROR: Failed to upload file '${manuscriptFilePath}' to Gemini via ai.files.`);
    console.error("File upload error details:", uploadError.message);
    if (uploadError.stack) console.error("Stack:", uploadError.stack);
    if (uploadError.response && uploadError.response.data) {
        console.error("API Error Data:", JSON.stringify(uploadError.response.data, null, 2));
    } else if (uploadError.cause) {
        console.error("Cause:", uploadError.cause);
    }
    process.exit(1);
  }

  const modelName = 'gemini-2.5-pro-preview-05-06'; // Ensure this model supports caching
  let createdCache;

  // --- Define the BASE instructions (will go into the cache's systemInstruction) ---
  const baseInstructionsFormat = `Your responses must be in PLAIN TEXT ONLY.
ABSOLUTELY DO NOT use any Markdown formatting (such as **, *, #, lists with -, etc.) in any part of your response.

You will analyze the creative fiction manuscript provided (which has been cached along with these base instructions) for the specific issues described in the user's follow-up prompt.
DO NOT include any introductory or concluding remarks (e.g., "Okay, here's the analysis...", "Overall, the manuscript is...").
DO NOT repeat any parts of the manuscript that are correct or do not have issues related to the current focus.
Your response should ONLY consist of the identified issues, formatted as follows for EACH issue found:

Original: [The complete original sentence or a relevant short passage from the manuscript with the issue, exactly as it appears, with no extra quotation marks added by you around the sentence itself.]
Issue(s): [A brief description of the specific problem(s) in that sentence/passage related to the current focus.]
Correction/Suggestion: [The complete corrected sentence if applicable, OR a suggestion on how to address the consistency issue. For consistency issues, clearly explain the inconsistency and suggest what to review or how to align it.]

After each "Correction/Suggestion:", add two newlines before presenting the "Original:" of the next identified issue.

For example, if the manuscript contained these lines related to the current focus:
Its a lovely day. The dog runned fast. See the cat. [Example for grammar/spelling]
John, who was allergic to cats, later adopted a cat without explanation. [Example for consistency]

Your response for grammar/spelling might be:
Original: Its a lovely day.
Issue(s): Spelling - "Its" should be "It's" (contraction of "it is" or "it has").
Correction/Suggestion: It's a lovely day.

Original: The dog runned fast.
Issue(s): Grammar - Incorrect past tense of "run".
Correction/Suggestion: The dog ran fast.

Your response for character consistency might be:
Original: John, who was allergic to cats, later adopted a cat without explanation.
Issue(s): Character Inconsistency - John was previously stated to be allergic to cats, but later adopts one without addressing the allergy.
Correction/Suggestion: Review John's character details. Either establish how his allergy was resolved, or reconsider the cat adoption to maintain consistency.

Now, please provide the analysis based on the cached manuscript and these general guidelines, focusing on the specific area outlined in the user's prompt.`;

  try {
    console.log(`\n--- Creating Cache with Uploaded File and Base Instructions ---`);
    const cacheCreationStartTime = new Date();

    if (!(ai.caches && typeof ai.caches.create === 'function')) {
        console.error("CRITICAL ERROR: 'ai.caches.create' is NOT a function. Cannot proceed with caching.");
        process.exit(1);
    }

    const cacheConfig = {
        model: modelName, // Cache is model-specific
        config: {
            contents: [createUserContent(createPartFromUri(uploadedFileMetadata.uri, uploadedFileMetadata.mimeType))],
            systemInstruction: baseInstructionsFormat,
            ttl: `${30 * 60}s` // 30 minutes in seconds (e.g., "900s") - cache will auto-delete after this if not explicitly deleted
        },
        displayName: `Cache for ${path.basename(manuscriptFilePath)} - ${new Date().toISOString()}`
    };

    console.log("Creating cache with config:", JSON.stringify({
        ...cacheConfig,
        config: {
            ...cacheConfig.config,
            contents: `[Content from URI: ${uploadedFileMetadata.uri}]`, // Avoid logging full content object
            systemInstruction: `[Base Instructions - ${baseInstructionsFormat.length} chars]`
        }
    }, null, 2));

    createdCache = await ai.caches.create(cacheConfig);

    if (!createdCache || !createdCache.name) {
        console.error("ERROR: Cache creation response is not in the expected format or is missing 'name'.");
        console.error("Received response:", JSON.stringify(createdCache, null, 2));
        process.exit(1);
    }
    const cacheCreationEndTime = new Date();
    const cacheCreationDurationMs = cacheCreationEndTime.getTime() - cacheCreationStartTime.getTime();
    console.log(`Cache created successfully in ${(cacheCreationDurationMs / 1000).toFixed(2)} seconds.`);
    console.log(`Cache Name (ID): ${createdCache.name}`);
    console.log(`Cache Model: ${createdCache.model}`);
    console.log(`Cache Display Name: ${createdCache.displayName}`);
    console.log(`Cache TTL: ${createdCache.ttl} (Expires: ${new Date(createdCache.expireTime).toLocaleString()})`);
    if (createdCache.usageMetadata) {
        console.log(`Cache Input Token Count: ${createdCache.usageMetadata.totalTokenCount || createdCache.usageMetadata.cachedContentTokenCount || 'N/A'}`);
    }
    console.log(`--- End of Cache Creation ---`);

  } catch (cacheError) {
    console.error(`\nERROR: Failed to create cache for file '${manuscriptFilePath}'.`);
    console.error("Cache creation error details:", cacheError.message);
    if (cacheError.stack) console.error("Stack:", cacheError.stack);
    if (cacheError.response && cacheError.response.data) {
        console.error("API Error Data:", JSON.stringify(cacheError.response.data, null, 2));
    } else if (cacheError.cause) {
        console.error("Cause:", cacheError.cause);
    }
    process.exit(1);
  }

  const generationConfiguration = {
    responseMimeType: 'text/plain',
  };
  const safetySettings = [
    { category: HarmCategory.HARM_CATEGORY_HARASSMENT, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE },
    { category: HarmCategory.HARM_CATEGORY_HATE_SPEECH, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE },
    { category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE },
    { category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE },
  ];

  // --- Define the tasks (focus prompts only) ---
  const tasks = [
    {
      name: "Grammar, Spelling, and Punctuation",
      focusPrompt: `FOCUS AREA: Grammar, spelling, and punctuation issues.\nFor the "Correction/Suggestion:" line, provide the directly corrected sentence.`
    },
    {
      name: "Character Consistency",
      focusPrompt: `FOCUS AREA: Character consistency issues. This includes:\n- Consistent naming of characters.\n- Consistent physical descriptions (unless changes are clearly part of the plot/development).\n- Consistent personality traits, voice, and behavior (unless character development is explicitly shown and justified).\n- Consistent memories, skills, or knowledge attributed to characters.\n- Consistent relationships between characters.\nFor the "Correction/Suggestion:" line, describe the inconsistency and suggest how to make it consistent or what parts of the manuscript to review for alignment.`
    },
    {
      name: "Plot Consistency",
      focusPrompt: `FOCUS AREA: Plot consistency issues. This includes:\n- Timeline consistency (logical sequence of events, no unexplained time jumps or contradictions).\n- Cause and effect (actions having believable consequences, or lack of consequences being addressed).\n- Adherence to established rules or logic of the story world (e.g., magic systems, technology).\n- Unresolved plot threads or plot holes.\n- Consistency in objects, locations, or significant plot devices.\n- Character motivations aligning with their actions within the plot.\nFor the "Correction/Suggestion:" line, describe the plot inconsistency, plot hole, or unresolved thread, and suggest how it might be resolved or what parts of the manuscript to review for alignment.`
    }
  ];

  try {
    for (const task of tasks) {
      console.log(`\n\n======================================================================`);
      console.log(`--- Starting Task: ${task.name} (using cached content) ---`);
      console.log(`======================================================================`);

      // The manuscript and base instructions are in the cache.
      // We only send the task-specific focus prompt.
      const contentsForRequest = [
        {
          role: 'user',
          parts: [
            { text: task.focusPrompt }, // Only the task-specific part
          ],
        }
      ];

      const instructionsTextForLogging = contentsForRequest[0].parts[0].text;
      console.log(`\n--- Sending Task-Specific Prompt to Model (${modelName}) for task: ${task.name} ---`);
      console.log(`(Manuscript and base instructions are referenced from cache: ${createdCache.name})`);
      console.log(`Task-Specific Instructions Sent:\n${instructionsTextForLogging.substring(0, 500)}... (truncated if long)`);
      console.log(`--- End of Task-Specific Instructions Sent ---`);

      let taskSpecificTimerInterval;
      try {
        if (!(ai.models && typeof ai.models.generateContentStream === 'function')) {
          console.error("CRITICAL ERROR: 'ai.models.generateContentStream' is NOT a function. Skipping task.");
          continue;
        }

        const apiCallStartTime = new Date();
        console.log(`\nAPI Call Start Time: ${apiCallStartTime.toLocaleTimeString()}\n`);
        process.stdout.write("elapsed: 0m 0s");
        const updateTimer = () => {
          const now = new Date();
          const elapsedMs = now.getTime() - apiCallStartTime.getTime();
          const totalSeconds = Math.floor(elapsedMs / 1000);
          const minutes = Math.floor(totalSeconds / 60);
          const seconds = totalSeconds % 60;
          process.stdout.cursorTo(0);
          process.stdout.clearLine(0);
          process.stdout.write(`elapsed: ${minutes}m ${seconds}s`);
        };
        taskSpecificTimerInterval = setInterval(updateTimer, 1000);

        let lastUsageMetadata = null;
        const responseStream = await ai.models.generateContentStream({
          model: modelName, // Must match the model used for caching
          contents: contentsForRequest,
          generationConfig: generationConfiguration,
          safetySettings: safetySettings,
          cachedContent: createdCache.name, // Referencing the cache
        });

        clearInterval(taskSpecificTimerInterval);
        process.stdout.write('\n');

        const callEndTime = new Date();
        console.log(`\nAPI Call End Time (stream initiated): ${callEndTime.toLocaleTimeString()}\n`);
        const durationMs = callEndTime.getTime() - apiCallStartTime.getTime();
        const durationSeconds = durationMs / 1000;
        const displayTotalSeconds = Math.floor(durationSeconds);
        const displayMinutes = Math.floor(displayTotalSeconds / 60);
        const displayRemainingSeconds = displayTotalSeconds % 60;
        console.log(`Time to initiate stream: ${displayMinutes}m ${displayRemainingSeconds}s`);

        console.log(`\nTask '${task.name}' has returned, processing stream...`);
        console.log("\n--- Gemini Response Stream ---");
        let output = "";
        let chunkCount = 0;
        const streamProcessingStartTime = new Date();

        for await (const chunk of responseStream) {
          chunkCount++;
          if (chunk.usageMetadata) {
            lastUsageMetadata = chunk.usageMetadata;
          }
          if (chunk && chunk.candidates && chunk.candidates.length > 0 &&
              chunk.candidates[0].content && chunk.candidates[0].content.parts &&
              chunk.candidates[0].content.parts.length > 0 &&
              typeof chunk.candidates[0].content.parts[0].text === 'string') {
            const textContent = chunk.candidates[0].content.parts[0].text;
            output += textContent;
            process.stdout.write(textContent);
          } else if (chunk && chunk.error) {
            console.error(`\nERROR in stream chunk ${chunkCount}:`, JSON.stringify(chunk.error));
            break;
          } else {
            console.warn(`\nSkipping unrecognized or non-text chunk structure in stream (chunk ${chunkCount}):`, JSON.stringify(chunk));
          }
        }
        process.stdout.write('\n');

        if (lastUsageMetadata) {
          console.log(`\n--- Usage Statistics (from last relevant chunk for task: ${task.name}) ---`);
          console.log(`Prompt Token Count: ${lastUsageMetadata.promptTokenCount} (This is for the task-specific prompt)`);
          if (lastUsageMetadata.cachedContentTokenCount !== undefined) { // Check if this field exists in the response
             console.log(`Cached Content Token Count: ${lastUsageMetadata.cachedContentTokenCount} (Tokens from the cache)`);
          }
          console.log(`Candidates Token Count: ${lastUsageMetadata.candidatesTokenCount}`);
          console.log(`Total Token Count: ${lastUsageMetadata.totalTokenCount} (Includes prompt, cached, and candidates)`);
          if (lastUsageMetadata.thoughtsTokenCount !== undefined) {
            console.log(`Thoughts Token Count: ${lastUsageMetadata.thoughtsTokenCount}`);
          }
          console.log(`--- End Usage Statistics ---`);
        } else {
          console.log("\nNo usage metadata was found in the response stream for this task.");
        }

        const streamProcessingEndTime = new Date();
        const streamDurationMs = streamProcessingEndTime.getTime() - streamProcessingStartTime.getTime();
        const streamDurationSeconds = streamDurationMs / 1000;

        if (chunkCount === 0) {
            console.log(`WARNING: Stream for task '${task.name}' completed with 0 chunks containing parsable text.`);
        }
        console.log(`--- End of Stream for task '${task.name}' (processed ${chunkCount} chunks in ${streamDurationSeconds.toFixed(2)} seconds) ---`);

      } catch (taskError) {
        if (taskSpecificTimerInterval) {
            clearInterval(taskSpecificTimerInterval);
            process.stdout.write('\n');
        }
        console.error(`\nERROR during task '${task.name}':`);
        console.error("Error message:", taskError.message);
        if (taskError.stack) console.error("Stack:", taskError.stack);
        if (taskError.cause) console.error("Cause:", taskError.cause);
        if (taskError.response) {
            console.error("API Response (if available from error object):", JSON.stringify(taskError.response, null, 2));
        }
        console.log(`--- Skipping to next task due to error in '${task.name}' ---`);
      }
    }
  } catch (fatalError) {
      console.error("\n--- A FATAL ERROR OCCURRED BEFORE OR DURING TASK LOOP ---");
      console.error("Error message:", fatalError.message);
      if (fatalError.stack) console.error("Stack trace:", fatalError.stack);
  } finally {
    if (createdCache && createdCache.name) {
      console.log(`\n\n======================================================================`);
      console.log(`--- Attempting to delete created cache: ${createdCache.name} ---`);
      console.log(`======================================================================`);
      try {
        if (ai.caches && typeof ai.caches.delete === 'function') {
          const deleteParams = { name: createdCache.name };
          console.log("Calling ai.caches.delete() with params:", JSON.stringify(deleteParams));
          await ai.caches.delete(deleteParams);
          console.log(`Cache ${createdCache.name} deleted successfully.`);
        } else {
          console.warn("WARN: 'ai.caches.delete' is not a function. Cannot delete created cache.");
        }
      } catch (deleteError) {
        console.error(`ERROR: Failed to delete cache '${createdCache.name}'.`);
        console.error("Cache deletion error details:", deleteError.message);
        if (deleteError.stack) console.error("Deletion Stack:", deleteError.stack);
      }
      console.log(`--- End of Cache Deletion Attempt ---`);
    }

    if (uploadedFileMetadata && uploadedFileMetadata.name) {
      console.log(`\n\n======================================================================`);
      console.log(`--- Attempting to delete uploaded file: ${uploadedFileMetadata.name} ---`);
      console.log(`======================================================================`);
      try {
        if (ai.files && typeof ai.files.delete === 'function') {
          const deleteParams = { name: uploadedFileMetadata.name };
          console.log("Calling ai.files.delete() with params:", JSON.stringify(deleteParams));
          await ai.files.delete(deleteParams);
          console.log(`File ${uploadedFileMetadata.name} deleted successfully.`);
        } else {
          console.warn("WARN: 'ai.files.delete' is not a function. Cannot delete uploaded file.");
        }
      } catch (deleteError) {
        console.error(`ERROR: Failed to delete file '${uploadedFileMetadata.name}'.`);
        console.error("File deletion error details:", deleteError.message);
        if (deleteError.stack) console.error("Deletion Stack:", deleteError.stack);
      }
      console.log(`--- End of File Deletion Attempt ---`);
    }

    console.log(`\n\n======================================================================`);
    console.log(`--- Listing all project caches (after potential deletion) ---`);
    console.log(`======================================================================`);
    try {
        if (ai.caches && typeof ai.caches.list === 'function') {
            const listParams = { pageSize: 10 }; // Example pageSize
            console.log("Calling ai.caches.list() with params:", JSON.stringify(listParams));
            const listResponsePager = await ai.caches.list(listParams);

            let cachesFound = false;
            for await (const cache of listResponsePager) {
                cachesFound = true;
                console.log(`  - Name: ${cache.name}, Model: ${cache.model}, DisplayName: ${cache.displayName || 'N/A'}, TTL: ${cache.ttl}, Expires: ${new Date(cache.expireTime).toLocaleString()}`);
            }
            if (!cachesFound) {
                console.log("  No caches found for this project.");
            }
        } else {
            console.warn("WARN: 'ai.caches.list' is not a function. Cannot list project caches.");
        }
    } catch (listError) {
        console.error(`ERROR: Failed to list project caches.`);
        console.error("Cache listing error details:", listError.message);
        if (listError.stack) console.error("Listing Stack:", listError.stack);
    }
    console.log(`--- End of Cache Listing ---`);


    console.log(`\n\n======================================================================`);
    console.log(`--- Listing all project files (after potential deletion) ---`);
    console.log(`======================================================================`);
    try {
      if (ai.files && typeof ai.files.list === 'function') {
        const listParams = {};
        console.log("Calling ai.files.list() with params:", JSON.stringify(listParams));
        const listResponsePager = await ai.files.list(listParams);

        let filesFound = false;
        for await (const file of listResponsePager) {
          filesFound = true;
          console.log(`  - Name: ${file.name}, DisplayName: ${file.displayName || 'N/A'}, URI: ${file.uri}, Size: ${file.sizeBytes || 'N/A'} bytes, MIME: ${file.mimeType}`);
        }
        if (!filesFound) {
          console.log("  No files found for this project.");
        }
      } else {
        console.warn("WARN: 'ai.files.list' is not a function. Cannot list project files.");
      }
    } catch (listError) {
      console.error(`ERROR: Failed to list project files.`);
      console.error("File listing error details:", listError.message);
      if (listError.stack) console.error("Listing Stack:", listError.stack);
    }
    console.log(`--- End of File Listing ---`);
  }
}

main().catch(error => {
  console.error("\n--- A FATAL UNHANDLED ERROR OCCURRED IN main() AND WASN'T CAUGHT BY INNER BLOCKS ---");
  console.error("Error message:", error.message);
  if (error.stack) console.error("Stack trace:", error.stack);
  if (error.cause) console.error("Cause:", error.cause);
  process.exit(1);
});


============================================================
FILE: proofreader_gemini25.js
SIZE: 24682 bytes
LANGUAGE: JS
============================================================

const { GoogleGenAI, HarmCategory, HarmBlockThreshold } = require('@google/genai');
const fs = require('fs');
const path = require('path');
const http = require('http');
const https = require('https');
const { _getActiveHandles } = require('node:process');

// Better socket cleanup function
function cleanupConnections() {
  console.log('>>> Beginning connection cleanup...');
  
  // Close all active HTTP/HTTPS connections
  // This is more reliable than trying to find TLSSocket objects
  let closedConnections = 0;
  
  // Close HTTP keep-alive connections
  if (http.globalAgent && http.globalAgent.destroy) {
    console.log('>>> Destroying HTTP global agent connections');
    http.globalAgent.destroy();
    closedConnections++;
  }
  
  // Close HTTPS keep-alive connections (this is critical for Google API calls)
  if (https.globalAgent && https.globalAgent.destroy) {
    console.log('>>> Destroying HTTPS global agent connections');
    https.globalAgent.destroy();
    closedConnections++;
  }
  
  // Get all active handles that might be sockets
  const handles = _getActiveHandles();
  
  console.log(`>>> Found ${handles.length} active handles`);
  
  for (const handle of handles) {
    // We need to check for both TLSSocket and Socket
    if (handle && handle.constructor && 
        (handle.constructor.name === 'TLSSocket' || 
         handle.constructor.name === 'Socket')) {
      
      console.log(`>>> Destroying ${handle.constructor.name} to ${handle.servername || handle.remoteAddress || 'unknown'}`);
      
      // For sockets, we first end() then destroy() to ensure clean closure
      if (typeof handle.end === 'function') {
        handle.end();
      }
      
      if (typeof handle.destroy === 'function') {
        handle.destroy();
        closedConnections++;
      }
    }
  }
  
  console.log(`>>> Closed ${closedConnections} connections`);
  return closedConnections;
}

// Helper to gracefully close the Gemini API client
async function closeGeminiClient(aiClient) {
  if (!aiClient) return;
  
  console.log('>>> Closing Gemini API client...');
  
  // Some API clients have a close() method
  if (typeof aiClient.close === 'function') {
    await aiClient.close();
    console.log('>>> Successfully closed Gemini client via close() method');
    return;
  }
  
  // If no explicit close method, we can try to clean up internal resources
  // by checking various internal properties that might exist
  if (aiClient.models) {
    // Some API clients have internal transport objects with cleanup methods
    if (aiClient.models._transport && typeof aiClient.models._transport.close === 'function') {
      await aiClient.models._transport.close();
      console.log('>>> Successfully closed Gemini client transport');
    }
    
    // Try to null out internal references that might be keeping connections alive
    if (aiClient.models.client) {
      console.log('>>> Nullifying internal client references');
      aiClient.models.client = null;
    }
    
    // If there's any internal HTTP agent, try to destroy it
    if (aiClient.models.agent && typeof aiClient.models.agent.destroy === 'function') {
      aiClient.models.agent.destroy();
      console.log('>>> Destroyed internal HTTP agent');
    }
  }
  
  // Check for file client references
  if (aiClient.files) {
    console.log('>>> Cleaning up files client references');
    if (aiClient.files.client) {
      aiClient.files.client = null;
    }
  }
  
  // Force garbage collection to release resources if available
  // Note: This requires running Node with --expose-gc flag
  if (global.gc) {
    console.log('>>> Forcing garbage collection');
    global.gc();
  }
}

async function main() {
  let ai = null;
  let uploadedFileMetadata = null;
  let cleanExitSuccessful = false;
  
  try {
    const apiKeyFromEnv = process.env.GEMINI_API_KEY;
    if (!apiKeyFromEnv) {
      console.error("ERROR: GEMINI_API_KEY environment variable is not set.");
      return; // Using return instead of process.exit() allows for finally block to run
    }

    // Initialize with timeout
    ai = new GoogleGenAI({
      apiKey: apiKeyFromEnv,
      httpOptions: {
        timeout: 900000 // 15 minutes in milliseconds
      }
    });

    const manuscriptFilePath = 'cls_short_manuscript.txt';
    let manuscriptContent = '';

    try {
      if (!fs.existsSync(manuscriptFilePath)) {
        console.error(`ERROR: Manuscript file not found at: ${manuscriptFilePath}`);
        return;
      }
      manuscriptContent = fs.readFileSync(manuscriptFilePath, 'utf8');
      console.log(`Successfully read content from ${manuscriptFilePath} (Size: ${Buffer.byteLength(manuscriptContent, 'utf8')} bytes).`);
    } catch (fileReadError) {
      console.error(`ERROR: Failed to read file '${manuscriptFilePath}'.`);
      console.error("File read error details:", fileReadError.message);
      return;
    }

    try {
      console.log(`\n--- Uploading File to Gemini via ai.files.upload: ${manuscriptFilePath} ---`);
      const uploadStartTime = new Date();

      const uploadParams = {
        file: manuscriptFilePath,
        config: {
          mimeType: 'text/plain',
          displayName: `Manuscript: ${path.basename(manuscriptFilePath)}`
        }
      };

      let uploadResponse;

      if (ai.files && typeof ai.files.upload === 'function') {
        console.log("Using ai.files.upload() with params:", JSON.stringify(uploadParams, null, 2));
        uploadResponse = await ai.files.upload(uploadParams);
      } else {
        console.error("CRITICAL ERROR: 'ai.files.upload' is NOT a function on the initialized 'ai' object. Cannot proceed with file upload.");
        return;
      }

      if (uploadResponse && uploadResponse.uri && uploadResponse.mimeType) {
        uploadedFileMetadata = uploadResponse;
      } else {
        console.error("ERROR: Uploaded file response from 'ai.files.upload' is not in the expected 'File' object format or is missing 'uri'/'mimeType'.");
        console.error("Received response:", JSON.stringify(uploadResponse, null, 2));
        return;
      }

      const uploadEndTime = new Date();
      const uploadDurationMs = uploadEndTime.getTime() - uploadStartTime.getTime();
      console.log(`File uploaded successfully via ai.files in ${(uploadDurationMs / 1000).toFixed(2)} seconds.`);
      console.log(`Uploaded File URI: ${uploadedFileMetadata.uri}`);
      console.log(`Uploaded File MIME Type: ${uploadedFileMetadata.mimeType}`);
      if (uploadedFileMetadata.name) console.log(`Uploaded File Name (ID): ${uploadedFileMetadata.name}`);
      if (uploadedFileMetadata.displayName) console.log(`Uploaded File Display Name: ${uploadedFileMetadata.displayName}`);
      if (uploadedFileMetadata.sizeBytes) console.log(`Uploaded File Size (from API): ${uploadedFileMetadata.sizeBytes} bytes`);
      console.log(`--- End of File Upload ---`);

    } catch (uploadError) {
      console.error(`\nERROR: Failed to upload file '${manuscriptFilePath}' to Gemini via ai.files.`);
      console.error("File upload error details:", uploadError.message);
      if (uploadError.stack) console.error("Stack:", uploadError.stack);
      if (uploadError.response && uploadError.response.data) {
        console.error("API Error Data:", JSON.stringify(uploadError.response.data, null, 2));
      } else if (uploadError.cause) {
        console.error("Cause:", uploadError.cause);
      }
      return;
    }

    const modelName = 'gemini-2.5-pro-preview-05-06';
    const generationConfiguration = {
      responseMimeType: 'text/plain',
    };
    const safetySettings = [
      { category: HarmCategory.HARM_CATEGORY_HARASSMENT, threshold: HarmBlockThreshold.OFF },
      { category: HarmCategory.HARM_CATEGORY_HATE_SPEECH, threshold: HarmBlockThreshold.OFF },
      { category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT, threshold: HarmBlockThreshold.OFF },
      { category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT, threshold: HarmBlockThreshold.OFF },
    ];

    // Define the tasks
    const baseInstructionsFormat = `Your responses must be in PLAIN TEXT ONLY.
ABSOLUTELY DO NOT use any Markdown formatting (such as **, *, #, lists with -, etc.) in any part of your response.

You will analyze the creative fiction manuscript provided (as an uploaded file) for the specific issues described below.
DO NOT include any introductory or concluding remarks (e.g., "Okay, here's the analysis...", "Overall, the manuscript is...").
DO NOT repeat any parts of the manuscript that are correct or do not have issues related to the current focus.
Your response should ONLY consist of the identified issues, formatted as follows for EACH issue found:

Original: [The complete original sentence or a relevant short passage from the manuscript with the issue, exactly as it appears, with no extra quotation marks added by you around the sentence itself.]
Issue(s): [A brief description of the specific problem(s) in that sentence/passage related to the current focus.]
Correction/Suggestion: [The complete corrected sentence if applicable, OR a suggestion on how to address the consistency issue. For consistency issues, clearly explain the inconsistency and suggest what to review or how to align it.]

After each "Correction/Suggestion:", add two newlines before presenting the "Original:" of the next identified issue.

Now, please provide the analysis for the manuscript above using this exact format and focusing on the specific area outlined below.`;

    const tasks = [
      {
        name: "Grammar, Spelling, and Punctuation",
        instructions: `${baseInstructionsFormat}\n\nFOCUS AREA: Grammar, spelling, and punctuation issues.\nFor the "Correction/Suggestion:" line, provide the directly corrected sentence.`
      },
      // Limiting to just one task for demonstration purposes
      // You can uncomment and add more tasks as needed
      /*
      {
        name: "Character Consistency",
        instructions: `${baseInstructionsFormat}\n\nFOCUS AREA: Character consistency issues. This includes:\n- Consistent naming of characters.\n- Consistent physical descriptions (unless changes are clearly part of the plot/development).\n- Consistent personality traits, voice, and behavior (unless character development is explicitly shown and justified).\n- Consistent memories, skills, or knowledge attributed to characters.\n- Consistent relationships between characters.\nFor the "Correction/Suggestion:" line, describe the inconsistency and suggest how to make it consistent or what parts of the manuscript to review for alignment.`
      },
      {
        name: "Plot Consistency",
        instructions: `${baseInstructionsFormat}\n\nFOCUS AREA: Plot consistency issues. This includes:\n- Timeline consistency (logical sequence of events, no unexplained time jumps or contradictions).\n- Cause and effect (actions having believable consequences, or lack of consequences being addressed).\n- Adherence to established rules or logic of the story world (e.g., magic systems, technology).\n- Unresolved plot threads or plot holes.\n- Consistency in objects, locations, or significant plot devices.\n- Character motivations aligning with their actions within the plot.\nFor the "Correction/Suggestion:" line, describe the plot inconsistency, plot hole, or unresolved thread, and suggest how it might be resolved or what parts of the manuscript to review for alignment.`
      }
      */
    ];

    // Process each task one at a time, properly awaiting each one to complete
    for (const task of tasks) {
      console.log(`\n\n======================================================================`);
      console.log(`--- Starting Task: ${task.name} ---`);
      console.log(`======================================================================`);

      const contentsForRequest = [
        {
          role: 'user',
          parts: [
            {
              fileData: {
                mimeType: uploadedFileMetadata.mimeType,
                fileUri: uploadedFileMetadata.uri,
              },
            },
            { text: `\n\n---\nINSTRUCTIONS:\n${task.instructions}` },
          ],
        }
      ];

      const instructionsTextForLogging = contentsForRequest[0].parts[1].text;
      console.log(`\n--- Sending Prompt to Model (${modelName}) for task: ${task.name} ---`);
      console.log(`Instructions Sent to Model:\n${instructionsTextForLogging.substring(0, 500)}... (truncated for brevity)`);
      console.log(`--- End of Instructions Sent ---`);

      let taskSpecificTimerInterval;
      try {
        if (!(ai.models && typeof ai.models.generateContentStream === 'function')) {
          console.error("CRITICAL ERROR: 'ai.models.generateContentStream' is NOT a function. Skipping task.");
          continue;
        }

        const apiCallStartTime = new Date();
        console.log(`\nAPI Call Start Time: ${apiCallStartTime.toLocaleTimeString()}\n`);
        process.stdout.write("elapsed: 0m 0s");
        const updateTimer = () => {
          const now = new Date();
          const elapsedMs = now.getTime() - apiCallStartTime.getTime();
          const totalSeconds = Math.floor(elapsedMs / 1000);
          const minutes = Math.floor(totalSeconds / 60);
          const seconds = totalSeconds % 60;
          process.stdout.cursorTo(0);
          process.stdout.clearLine(0);
          process.stdout.write(`elapsed: ${minutes}m ${seconds}s`);
        };
        taskSpecificTimerInterval = setInterval(updateTimer, 1000);

        let lastUsageMetadata = null;
        
        // IMPORTANT: Properly store the response stream in a variable
        // and make sure we await all operations on it
        const responseStream = await ai.models.generateContentStream({
          model: modelName,
          contents: contentsForRequest,
          generationConfig: generationConfiguration,
          safetySettings: safetySettings,
        });

        // Clear the timer interval immediately after getting response
        if (taskSpecificTimerInterval) {
          clearInterval(taskSpecificTimerInterval);
          taskSpecificTimerInterval = null;
          process.stdout.write('\n');
        }

        const callEndTime = new Date();
        console.log(`\nAPI Call End Time (stream initiated): ${callEndTime.toLocaleTimeString()}\n`);
        const durationMs = callEndTime.getTime() - apiCallStartTime.getTime();
        const durationSeconds = durationMs / 1000;
        const displayTotalSeconds = Math.floor(durationSeconds);
        const displayMinutes = Math.floor(displayTotalSeconds / 60);
        const displayRemainingSeconds = displayTotalSeconds % 60;
        console.log(`Time to initiate stream: ${displayMinutes}m ${displayRemainingSeconds}s`);

        console.log(`\nTask '${task.name}' has returned, processing stream...`);
        console.log("\n--- Gemini Response Stream ---");
        let output = "";
        let chunkCount = 0;
        const streamProcessingStartTime = new Date();

        // Make sure we properly await the for-await loop to complete
        for await (const chunk of responseStream) {
          chunkCount++;
          if (chunk.usageMetadata) {
            lastUsageMetadata = chunk.usageMetadata;
          }
          if (chunk && chunk.candidates && chunk.candidates.length > 0 &&
              chunk.candidates[0].content && chunk.candidates[0].content.parts &&
              chunk.candidates[0].content.parts.length > 0 &&
              typeof chunk.candidates[0].content.parts[0].text === 'string') {
            const textContent = chunk.candidates[0].content.parts[0].text;
            output += textContent;
            process.stdout.write(textContent);
          } else if (chunk && chunk.error) {
            console.error(`\nERROR in stream chunk ${chunkCount}:`, JSON.stringify(chunk.error));
            break;
          } else {
            console.warn(`\nSkipping unrecognized or non-text chunk structure in stream (chunk ${chunkCount}):`, JSON.stringify(chunk));
          }
        }
        process.stdout.write('\n');

        if (lastUsageMetadata) {
          console.log(`\n--- Usage Statistics (from last relevant chunk for task: ${task.name}) ---`);
          console.log(`Prompt Token Count: ${lastUsageMetadata.promptTokenCount}`);
          console.log(`Candidates Token Count: ${lastUsageMetadata.candidatesTokenCount}`);
          console.log(`Total Token Count: ${lastUsageMetadata.totalTokenCount}`);
          if (lastUsageMetadata.thoughtsTokenCount !== undefined) {
            console.log(`Thoughts Token Count: ${lastUsageMetadata.thoughtsTokenCount}`);
          }
          console.log(`--- End Usage Statistics ---`);
        } else {
          console.log("\nNo usage metadata was found in the response stream for this task.");
        }

        const streamProcessingEndTime = new Date();
        const streamDurationMs = streamProcessingEndTime.getTime() - streamProcessingStartTime.getTime();
        const streamDurationSeconds = streamDurationMs / 1000;

        if (chunkCount === 0) {
          console.log(`WARNING: Stream for task '${task.name}' completed with 0 chunks containing parsable text.`);
        }
        console.log(`--- End of Stream for task '${task.name}' (processed ${chunkCount} chunks in ${streamDurationSeconds.toFixed(2)} seconds) ---`);

        // Add a small delay to ensure all network operations are complete
        await new Promise(resolve => setTimeout(resolve, 500));

      } catch (taskError) {
        if (taskSpecificTimerInterval) {
          clearInterval(taskSpecificTimerInterval);
          process.stdout.write('\n');
        }
        console.error(`\nERROR during task '${task.name}':`);
        console.error("Error message:", taskError.message);
        if (taskError.stack) console.error("Stack:", taskError.stack);
        if (taskError.cause) console.error("Cause:", taskError.cause);
        if (taskError.response) {
          console.error("API Response (if available from error object):", JSON.stringify(taskError.response, null, 2));
        }
        console.log(`--- Skipping to next task due to error in '${task.name}' ---`);
      }
    }

    // Mark successful completion
    cleanExitSuccessful = true;

  } catch (fatalError) {
    console.error("\n--- A FATAL ERROR OCCURRED BEFORE OR DURING TASK LOOP ---");
    console.error("Error message:", fatalError.message);
    if (fatalError.stack) console.error("Stack trace:", fatalError.stack);
  } finally {
    // Clean up no matter what happened
    
    // 1. Delete the uploaded file if it exists
    if (uploadedFileMetadata && uploadedFileMetadata.name) {
      console.log(`\n\n======================================================================`);
      console.log(`--- Attempting to delete uploaded file: ${uploadedFileMetadata.name} ---`);
      console.log(`======================================================================`);
      try {
        if (ai && ai.files && typeof ai.files.delete === 'function') {
          const deleteParams = { name: uploadedFileMetadata.name };
          console.log("Calling ai.files.delete() with params:", JSON.stringify(deleteParams));
          await ai.files.delete(deleteParams);
          console.log(`File ${uploadedFileMetadata.name} deleted successfully.`);
        } else {
          console.warn("WARN: 'ai.files.delete' is not a function. Cannot delete uploaded file.");
        }
      } catch (deleteError) {
        console.error(`ERROR: Failed to delete file '${uploadedFileMetadata.name}'.`);
        console.error("File deletion error details:", deleteError.message);
        if (deleteError.stack) console.error("Deletion Stack:", deleteError.stack);
      }
      console.log(`--- End of File Deletion Attempt ---`);
    }

    // 2. List remaining files (mainly for debug purposes)
    console.log(`\n\n======================================================================`);
    console.log(`--- Listing all project files (after potential deletion) ---`);
    console.log(`======================================================================`);
    try {
      if (ai && ai.files && typeof ai.files.list === 'function') {
        const listParams = {};
        console.log("Calling ai.files.list() with params:", JSON.stringify(listParams));
        const listResponsePager = await ai.files.list(listParams);

        let filesFound = false;
        for await (const file of listResponsePager) {
          filesFound = true;
          console.log(`  - Name: ${file.name}, DisplayName: ${file.displayName || 'N/A'}, URI: ${file.uri}, Size: ${file.sizeBytes || 'N/A'} bytes, MIME: ${file.mimeType}`);
        }
        if (!filesFound) {
          console.log("  No files found for this project.");
        }
      } else {
        console.warn("WARN: 'ai.files.list' is not a function. Cannot list project files.");
      }
    } catch (listError) {
      console.error(`ERROR: Failed to list project files.`);
      console.error("File listing error details:", listError.message);
      if (listError.stack) console.error("Listing Stack:", listError.stack);
    }
    console.log(`--- End of File Listing ---`);

    // 3. Close the Google GenAI client
    try {
      console.log(`\n======================================================================`);
      console.log(`--- Closing the Google GenAI client ---`);
      console.log(`======================================================================`);
      await closeGeminiClient(ai);
      ai = null; // Allow it to be garbage collected
    } catch (closeError) {
      console.error(`ERROR: Failed to close the Google GenAI client.`);
      console.error("Close error details:", closeError.message);
    }
    
    // 4. Clean up network connections
    console.log(`\n======================================================================`);
    console.log(`--- Cleaning up network connections ---`);
    console.log(`======================================================================`);
    const connectionsClosed = cleanupConnections();
    
    // 5. Add a delay to allow any asynchronous cleanup to complete
    console.log(`\n--- Waiting for final cleanup (3 seconds) ---`);
    await new Promise(resolve => setTimeout(resolve, 3000));
    
    // 6. Do one final connection cleanup
    const finalConnectionsClosed = cleanupConnections();
    
    // Report final status
    console.log(`\n======================================================================`);
    if (cleanExitSuccessful) {
      console.log(`--- Script completed successfully and cleaned up all resources ---`);
    } else {
      console.log(`--- Script completed with errors but cleaned up all resources ---`);
    }
    console.log(`--- Total connections closed: ${connectionsClosed + finalConnectionsClosed} ---`);
    console.log(`======================================================================`);
    
    // 7. Set a graceful exit timeout (last resort)
    console.log('\n--- Setting graceful exit timeout (10 seconds) ---');
    console.log('--- If the script is still running after this time, we will exit gracefully ---');
    console.log('--- This is necessary because some SDK resources may not be fully exposing their cleanup methods ---');
    
    // This approach is preferable to process.exit(0) at the end of main()
    // because it gives the script a chance to exit naturally if possible
    const exitTimeout = setTimeout(() => {
      console.log('\n--- Graceful exit timeout reached, forcing clean exit ---');
      console.log('--- Consider reporting this to the Google GenAI SDK team as a potential resource leak ---');
      process.exit(0);  // Clean exit
    }, 10000);  // 10 seconds
    
    // If the process does exit naturally before the timeout, we'll clear the timeout
    // to avoid a "Promise resolution after process exit" warning
    exitTimeout.unref();  // This allows Node.js to exit even if this timeout is still pending
  }
}

// Run the main function and handle any unhandled promise rejections
main().catch(error => {
  console.error("\n--- A FATAL UNHANDLED ERROR OCCURRED IN main() AND WASN'T CAUGHT BY INNER BLOCKS ---");
  console.error("Error message:", error.message);
  if (error.stack) console.error("Stack trace:", error.stack);
  if (error.cause) console.error("Cause:", error.cause);
  
  // Even in case of fatal error, try to clean up connections
  cleanupConnections();
  
  // Allow a moment for error logging to complete
  setTimeout(() => {
    console.error("\n--- Clean exit failed, had to force termination ---");
    process.exit(1);
  }, 1000);
});


============================================================
FILE: proofreader-mechanical.js
SIZE: 13262 bytes
LANGUAGE: JS
============================================================

// proofreader-mechanical.js
const BaseTool = require('./base-tool');
const path = require('path');
const fileCache = require('./file-cache');
const appState = require('./state.js');
const fs = require('fs/promises');

/**
 * ProofreaderMechanical Tool
 * Analyzes manuscript specifically for mechanical errors (spelling, grammar, punctuation, formatting)
 * without checking for any consistency issues. Designed to work efficiently with large manuscripts.
 */
class ProofreaderMechanical extends BaseTool {
  /**
   * Constructor
   * @param {Object} GeminiAPIService - Claude API service
   * @param {Object} config - Tool configuration
   */
  constructor(GeminiAPIService, config = {}) {
    super('proofreader_mechanical', config);
    this.GeminiAPIService = GeminiAPIService;
  }

  /**
   * Execute the tool
   * @param {Object} options - Tool options
   * @returns {Promise<Object>} - Execution result
   */
  async execute(options) {
    console.log('Executing Proofreader (Mechanical) with options:', options);
    
    // Extract options
    let manuscriptFile = options.manuscript_file;
    const language = options.language || 'English';
    const saveDir = options.save_dir || appState.CURRENT_PROJECT_PATH;
    
    if (!saveDir) {
      const errorMsg = 'Error: No save directory specified and no current project selected.\n' +
                      'Please select a project or specify a save directory.';
      this.emitOutput(errorMsg);
      throw new Error('No save directory available');
    }

    // Ensure file paths are absolute
    manuscriptFile = this.ensureAbsolutePath(manuscriptFile, saveDir);

    const outputFiles = [];
    
    try {
      const manuscriptContent = await this.readInputFile(manuscriptFile);
      const manuscriptWordCount = this.countWords(manuscriptContent);
      const manuscriptTokens = await this.GeminiAPIService.countTokens(manuscriptContent);
      
      const prompt = this.createMechanicalProofreadingPrompt(manuscriptContent, language);

      const promptTokens = await this.GeminiAPIService.countTokens(prompt);

      // Call the shared token budget calculator
      const tokenBudgets = this.GeminiAPIService.calculateTokenBudgets(promptTokens);

      this.emitOutput(`Reading manuscript file: ${manuscriptFile}\n`);
      this.emitOutput(`\nToken stats:\n`);
      this.emitOutput(`Manuscript is ${manuscriptWordCount} words and ${manuscriptTokens} tokens.\n`);
      this.emitOutput(`Input prompt tokens: [${tokenBudgets.promptTokens}]\n`);
      this.emitOutput(`\n`);
      this.emitOutput(`Max AI model context window: [${tokenBudgets.contextWindow}] tokens\n`);
      this.emitOutput(`Available tokens: [${tokenBudgets.availableTokens}] = context_window - prompt\n`);
      this.emitOutput(`Desired output tokens: [${tokenBudgets.desiredOutputTokens}]\n`);
      this.emitOutput(`AI model thinking budget: [${tokenBudgets.thinkingBudget}] tokens\n`);
      this.emitOutput(`Max output tokens: [${tokenBudgets.maxTokens}] tokens\n`);

      // Check for special conditions
      if (tokenBudgets.capThinkingBudget) {
        this.emitOutput(`Warning: thinking budget is larger than 32K, set to 32K.\n`);
      }

      // Check if the prompt is too large
      if (tokenBudgets.isPromptTooLarge) {
        this.emitOutput(`Error: prompt is too large to have a ${tokenBudgets.configuredThinkingBudget} thinking budget!\n`);
        this.emitOutput(`Run aborted!\n`);
        throw new Error(`Prompt is too large for ${tokenBudgets.configuredThinkingBudget} thinking budget - run aborted`);
      }
      
      // Call Claude API with streaming
      this.emitOutput(`Sending request to Claude API . . .\n`);

      // Add a message about waiting
      this.emitOutput(`****************************************************************************\n`);
      this.emitOutput(`*  Proofreading manuscript for ${language} mechanical errors...\n`);
      this.emitOutput(`*  \n`);
      this.emitOutput(`*  This process typically takes several minutes.                           \n`);
      this.emitOutput(`*  \n`);
      this.emitOutput(`****************************************************************************\n\n`);
      
      const startTime = Date.now();
      let fullResponse = "";
      let thinkingContent = "";
      
      // Create system prompt to avoid markdown and enforce plain text
      const systemPrompt = "CRITICAL INSTRUCTION: NO Markdown formatting of ANY kind. Never use headers, bullets, or any formatting symbols. Plain text only with standard punctuation.";

      try {
        await this.GeminiAPIService.streamWithThinkingAndMessageStart(
          prompt,
          {
            model: "claude-3-7-sonnet-20250219",
            system: systemPrompt,
            max_tokens: tokenBudgets.maxTokens,
            thinking: {
              type: "enabled",
              budget_tokens: tokenBudgets.thinkingBudget
            },
            betas: ["output-128k-2025-02-19"]
          },
          // callback for thinking content
          (thinkingDelta) => {
            thinkingContent += thinkingDelta;
          },
          // callback for response text
          (textDelta) => {
            fullResponse += textDelta;
          },
          // callback for message start with stats
          (messageStart) => {
            this.emitOutput(`${messageStart}\n`);
          },
          // callback for response headers
          (responseHeaders) => {
            this.emitOutput(`${responseHeaders}\n`);
          },
          // callback for status
          (callStatus) => {
            this.emitOutput(`${callStatus}\n`);
          },
        );
      } catch (error) {
        this.emitOutput(`\nAPI Error: ${error.message}\n`);
        throw error;
      }

      const elapsed = (Date.now() - startTime) / 1000;
      const minutes = Math.floor(elapsed / 60);
      const seconds = elapsed % 60;
      
      this.emitOutput(`\nCompleted in: ⏰ ${minutes}m ${seconds.toFixed(2)}s.\n`);
      
      // Count words in response
      const wordCount = this.countWords(fullResponse);
      this.emitOutput(`Report has approximately ${wordCount} words.\n`);
      
      // Count tokens in response
      const responseTokens = await this.GeminiAPIService.countTokens(fullResponse);
      this.emitOutput(`Response token count: ${responseTokens}\n`);

      // Remove any markdown formatting
      fullResponse = this.removeMarkdown(fullResponse);

      // Save the report
      const outputFile = await this.saveReport(
        language,
        fullResponse,
        thinkingContent,
        promptTokens,
        responseTokens,
        saveDir
      );
      
      // Add all output files to the result
      outputFiles.push(...outputFile);
      
      // Add files to the cache
      const toolName = 'proofreader_mechanical';
      outputFiles.forEach(file => {
        fileCache.addFile(toolName, file);
      });
      
      // Return the result
      return {
        success: true,
        outputFiles,
        stats: {
          wordCount,
          tokenCount: responseTokens,
          elapsedTime: `${minutes}m ${seconds.toFixed(2)}s`,
          language
        }
      };
    } catch (error) {
      console.error('Error in ProofreaderMechanical:', error);
      this.emitOutput(`\nError: ${error.message}\n`);
      throw error;
    }
  }
  
  /**
   * Create mechanical proofreading prompt
   * @param {string} manuscriptContent - Manuscript content
   * @param {string} language - Language of the manuscript
   * @returns {string} - Prompt for Claude API
   */
  createMechanicalProofreadingPrompt(manuscriptContent, language = 'English') {
    // Create a focused, plain language prompt that avoids complexity
    const instructions = `Review this manuscript for mechanical errors ONLY. Ignore all other types of issues.

Focus exclusively on identifying spelling errors, grammar problems, punctuation mistakes, and basic formatting issues. Do not concern yourself with any aspects of consistency across the manuscript. This means you should not track or check character details, timeline elements, setting descriptions, or plot logic. Your task is simply to identify technical writing errors at the sentence level.

For each error you find:
1. Show the verbatim sentence containing the error WITHOUT adding quotation marks
2. Identify the specific error
3. Provide a correction

Read through the manuscript naturally without creating any tracking systems. Simply note errors as you encounter them. Give equal attention to the entire manuscript from beginning to end.

At the end, briefly confirm that you focused only on mechanical errors.`;

    // Combine manuscript and instructions
    return `=== MANUSCRIPT ===\n${manuscriptContent}\n=== END MANUSCRIPT ===\n\n${instructions}`;
  }

  /**
   * Count words in text
   * @param {string} text - Text to count words in
   * @returns {number} - Word count
   */
  countWords(text) {
    return text.split(/\s+/).filter(word => word.length > 0).length;
  }
  
  /**
   * Ensure file path is absolute
   * @param {string} filePath - File path (may be relative or absolute)
   * @param {string} basePath - Base path to prepend for relative paths
   * @returns {string} - Absolute file path
   */
  ensureAbsolutePath(filePath, basePath) {
    if (!filePath) return filePath;
    
    // Check if the path is already absolute
    if (path.isAbsolute(filePath)) {
      return filePath;
    }
    
    // Make the path absolute by joining with the base path
    return path.join(basePath, filePath);
  }

  /**
   * Remove any markdown formatting from the text
   * @param {string} text - Text that might contain markdown
   * @returns {string} - Text with markdown formatting removed
   */
  removeMarkdown(text) {
    // Remove header formatting
    text = text.replace(/^#+\s+/gm, '');
    
    // Remove bullet points
    text = text.replace(/^[*-]\s+/gm, '');
    
    // Remove numbered lists (convert "1. " to just "1. ")
    text = text.replace(/^\d+\.\s+/gm, match => match);
    
    // Remove bold/italic formatting
    text = text.replace(/(\*\*|__)(.*?)\1/g, '$2');
    text = text.replace(/(\*|_)(.*?)\1/g, '$2');
    
    // Remove code blocks and inline code
    text = text.replace(/```[\s\S]*?```/g, match => {
      // Preserve the content inside code blocks
      return match.replace(/```\w*\n|```$/g, '');
    });
    text = text.replace(/`([^`]+)`/g, '$1');
    
    return text;
  }
  
  /**
   * Save report and thinking content to files
   * @param {string} language - Language of the manuscript
   * @param {string} content - Response content
   * @param {string} thinking - Thinking content
   * @param {number} promptTokens - Prompt token count
   * @param {number} responseTokens - Response token count
   * @param {string} saveDir - Directory to save to
   * @returns {Promise<string[]>} - Array of paths to saved files
   */
  async saveReport(
    language,
    content,
    thinking,
    promptTokens,
    responseTokens,
    saveDir
  ) {
    try {
      const formatter = new Intl.DateTimeFormat('en-US', {
        weekday: 'long',
        month: 'long',
        day: 'numeric',
        year: 'numeric',
        hour: 'numeric',
        minute: '2-digit',
        hour12: true
      });
      const dateTimeStr = formatter.format(new Date());

      // Create timestamp for filename
      const timestamp = new Date().toISOString().replace(/[-:.]/g, '').substring(0, 15);
      
      // Create descriptive filename
      const baseFilename = `proofreading_${language.toLowerCase()}_${timestamp}`;
      
      // Array to collect all saved file paths
      const savedFilePaths = [];
      
      // Create stats for thinking file
      const stats = `
Details:  ${dateTimeStr}
Language: ${language}
Max request timeout: ${this.config.request_timeout} seconds
Max AI model context window: ${this.config.context_window} tokens
AI model thinking budget: ${this.config.thinking_budget_tokens} tokens
Desired output tokens: ${this.config.desired_output_tokens} tokens

Input tokens: ${promptTokens}
Output tokens: ${responseTokens}
`;
      
      // Save full response
      const reportFilename = `${baseFilename}.txt`;
      const reportPath = path.join(saveDir, reportFilename);
      await this.writeOutputFile(content, saveDir, reportFilename);
      savedFilePaths.push(reportPath);
      
      // Save thinking content if available and not skipped
      if (thinking) {
        const thinkingFilename = `${baseFilename}_thinking.txt`;
        const thinkingPath = path.join(saveDir, thinkingFilename);
        const thinkingContent = `=== PROOFREADER THINKING ===

${thinking}

=== END PROOFREADER THINKING ===
${stats}`;
        
        await this.writeOutputFile(thinkingContent, saveDir, thinkingFilename);
        this.emitOutput(`AI thinking saved to: ${thinkingPath}\n`);
        savedFilePaths.push(thinkingPath);
      }

      this.emitOutput(`Report saved to: ${reportPath}\n`);
      return savedFilePaths;
    } catch (error) {
      console.error(`Error saving report:`, error);
      this.emitOutput(`Error saving report: ${error.message}\n`);
      throw error;
    }
  }
}

module.exports = ProofreaderMechanical;

============================================================
FILE: proofreader-plot-consistency.js
SIZE: 15971 bytes
LANGUAGE: JS
============================================================

// proofreader-plot-consistency.js
const BaseTool = require('./base-tool');
const path = require('path');
const fileCache = require('./file-cache');
const appState = require('./state.js');
const fs = require('fs/promises');
const textProcessor = require('./textProcessor');

/**
 * Proofreader Plot Consistency Tool
 * Tracks narrative elements, world rules, and story logic
 */
class ProofreaderPlotConsistency extends BaseTool {
  /**
   * Constructor
   * @param {Object} GeminiAPIService - Claude API service
   * @param {Object} config - Tool configuration
   */
  constructor(GeminiAPIService, config = {}) {
    super('proofreader_plot_consistency', config);
    this.GeminiAPIService = GeminiAPIService;
  }

  /**
   * Execute the tool
   * @param {Object} options - Tool options
   * @returns {Promise<Object>} - Execution result
   */
  async execute(options) {
    console.log('Executing Proofreader Plot Consistency with options:', options);
    
    // Clear the cache for this tool
    const toolName = 'proofreader_plot_consistency';
    fileCache.clear(toolName);
    
    // Extract options
    let manuscriptFile = options.manuscript_file;
    const language = options.language || 'English';
    const saveDir = options.save_dir || appState.CURRENT_PROJECT_PATH;
    
    if (!saveDir) {
      const errorMsg = 'Error: No save directory specified and no current project selected.\n' +
                      'Please select a project or specify a save directory.';
      this.emitOutput(errorMsg);
      throw new Error('No save directory available');
    }

    // Ensure file paths are absolute
    manuscriptFile = this.ensureAbsolutePath(manuscriptFile, saveDir);

    const outputFiles = [];
    
    try {
      const manuscriptContent = await this.readInputFile(manuscriptFile);
      const manuscriptWordCount = this.countWords(manuscriptContent);
      const manuscriptTokens = await this.GeminiAPIService.countTokens(manuscriptContent);
      const manuscriptWithoutChapterHeaders = textProcessor.processText(manuscriptContent)
      
      // Create prompt using the template with language
      const prompt = this.createPrompt(manuscriptWithoutChapterHeaders, language);
      const promptTokens = await this.GeminiAPIService.countTokens(prompt);

      // Call the shared token budget calculator
      const tokenBudgets = this.GeminiAPIService.calculateTokenBudgets(promptTokens);

      this.emitOutput(`Reading manuscript file: ${manuscriptFile}\n`);
      this.emitOutput(`\nToken stats:\n`);
      this.emitOutput(`Manuscript is ${manuscriptWordCount} words and ${manuscriptTokens} tokens.\n`);
      this.emitOutput(`Input prompt tokens: [${tokenBudgets.promptTokens}]\n`);
      this.emitOutput(`\n`);
      this.emitOutput(`Max AI model context window: [${tokenBudgets.contextWindow}] tokens\n`);
      this.emitOutput(`Available tokens: [${tokenBudgets.availableTokens}]  = ${tokenBudgets.contextWindow} - ${tokenBudgets.promptTokens} = context_window - prompt\n`);
      this.emitOutput(`Desired output tokens: [${tokenBudgets.desiredOutputTokens}]\n`);
      this.emitOutput(`AI model thinking budget: [${tokenBudgets.thinkingBudget}] tokens\n`);
      this.emitOutput(`Max output tokens: [${tokenBudgets.maxTokens}] tokens\n`);

      // Check for special conditions
      if (tokenBudgets.capThinkingBudget) {
        this.emitOutput(`Warning: thinking budget is larger than 32K, set to 32K.\n`);
      }

      // Check if the prompt is too large
      if (tokenBudgets.isPromptTooLarge) {
        this.emitOutput(`Error: prompt is too large to have a ${tokenBudgets.configuredThinkingBudget} thinking budget!\n`);
        this.emitOutput(`Run aborted!\n`);
        throw new Error(`Prompt is too large for ${tokenBudgets.configuredThinkingBudget} thinking budget - run aborted`);
      }
      
      // Call Claude API with streaming
      this.emitOutput(`\nSending request to Claude API . . .\n`);
      
      // Add a message about waiting
      this.emitOutput(`\n****************************************************************************\n`);
      this.emitOutput(`*  Proofreading manuscript for ${language} ...\n`);
      this.emitOutput(`*  \n`);
      this.emitOutput(`*  This process typically takes several minutes.\n`);
      this.emitOutput(`*                                                                          \n`);
      this.emitOutput(`*  It's recommended to keep this window the sole 'focus'                   \n`);
      this.emitOutput(`*  and to avoid browsing online or running other apps, as these API        \n`);
      this.emitOutput(`*  network connections are often flakey, like delicate echoes of whispers. \n`);
      this.emitOutput(`*                                                                          \n`);
      this.emitOutput(`*  So breathe, remove eye glasses, stretch, relax, and be like water 🥋 🧘🏽‍♀️\n`);
      this.emitOutput(`*  \n`);
      this.emitOutput(`****************************************************************************\n\n`);
      
      const startTime = Date.now();
      let fullResponse = "";
      let thinkingContent = "";
      
      // Create system prompt - more explicit guidance
      const systemPrompt = "You are a meticulous proofreader. Be thorough and careful. DO NOT use any Markdown formatting - no headers, bullets, numbering, asterisks, hyphens, or any formatting symbols. Plain text only. You must find and report ALL errors, even small ones.";

      // Use the calculated values in the API call
      try {
        await this.GeminiAPIService.streamWithThinkingAndMessageStart(
          prompt,
          {
            model: "claude-3-7-sonnet-20250219",
            system: systemPrompt,
            max_tokens: tokenBudgets.maxTokens,
            thinking: {
              type: "enabled",
              budget_tokens: tokenBudgets.thinkingBudget
            },
            betas: ["output-128k-2025-02-19"]
          },
          // callback for thinking content
          (thinkingDelta) => {
            thinkingContent += thinkingDelta;
          },
          // callback for response text
          (textDelta) => {
            fullResponse += textDelta;
          },
          // callback for message start with stats
          (messageStart) => {
            this.emitOutput(`${messageStart}\n`);
          },
          // callback for response headers
          (responseHeaders) => {
            this.emitOutput(`${responseHeaders}\n`);
          },
          // callback for status
          (callStatus) => {
            this.emitOutput(`${callStatus}\n`);
          },
        );
      } catch (error) {
        this.emitOutput(`\nAPI Error: ${error.message}\n`);
        throw error;
      }

      const elapsed = (Date.now() - startTime) / 1000;
      const minutes = Math.floor(elapsed / 60);
      const seconds = elapsed % 60;
      
      this.emitOutput(`\nCompleted in: ⏰ ${minutes}m ${seconds.toFixed(2)}s.\n`);
      
      // Count words in response
      const wordCount = this.countWords(fullResponse);
      this.emitOutput(`Report has approximately ${wordCount} words.\n`);
      
      // Count tokens in response
      const responseTokens = await this.GeminiAPIService.countTokens(fullResponse);
      this.emitOutput(`Response token count: ${responseTokens}\n`);

      // Remove any markdown formatting
      fullResponse = this.removeMarkdown(fullResponse);

      // Save the report
      const outputFile = await this.saveReport(
        fullResponse,
        thinkingContent,
        promptTokens,
        responseTokens,
        saveDir,
        language
      );
      
      // Add the output files to the result
      outputFiles.push(...outputFile);
      
      // Add files to the cache
      outputFiles.forEach(file => {
        fileCache.addFile(toolName, file);
      });
      
      // Return the result
      return {
        success: true,
        outputFiles
      };
    } catch (error) {
      console.error('Error in Proofreader Plot Consistency:', error);
      this.emitOutput(`\nError: ${error.message}\n`);
      throw error;
    }
  }
  
  /**
   * Create prompt
   * @param {string} manuscriptContent - Manuscript content
   * @param {string} language - Language for proofreading (default: English)
   * @returns {string} - Prompt for Claude API
   */
  createPrompt(manuscriptContent, language = 'English') {
    // Specialized prompt focused ONLY on plot consistency issues
    const template = `You are a professional ${language} plot consistency proofreader focused on analyzing this manuscript:

=== MANUSCRIPT ===
${manuscriptContent}
=== END MANUSCRIPT ===

CORE INSTRUCTION: Conduct a specialized review focusing EXCLUSIVELY on plot consistency issues. Thoroughly analyze story elements, important objects, character knowledge, fictional world rules, and narrative causality to identify contradictions, plot holes, or inconsistencies in how the story unfolds.

FOCUS ONLY ON:
- Fictional world rule contradictions (how magic, technology, or special abilities work)
- Plot causality issues (events happening without logical setup or connection)
- Knowledge inconsistencies (characters knowing things they shouldn't yet know or forgetting what they should know)
- Important object inconsistencies (items appearing, disappearing, or changing without explanation)
- Motivation inconsistencies (characters acting contrary to established goals without development)
- Narrative promises unfulfilled (setup without payoff, introduced elements that vanish)
- Factual contradictions within the story's established reality
- Information revealed to readers that conflicts with previous information

EXPLICITLY IGNORE:
- Spelling, grammar, punctuation, and formatting errors
- Character consistency issues (unless directly affecting plot)
- Timeline and chronology inconsistencies (unless directly affecting plot)
- Setting and location consistency issues (unless directly affecting plot)
- Stylistic choices and thematic elements
- Any other issues not directly related to plot and world-building consistency

APPROACH:
1. Track the story's internal logic and rules as you read through the manuscript
2. Monitor:
   - Important objects and their status/location
   - Information revealed to different characters and when
   - Rules established for how the world functions
   - Cause-and-effect relationships between events
   - Setup elements that promise later payoff
3. Identify contradictions, logical gaps, or inconsistencies in these elements
4. Present specific instances where plot elements appear inconsistent

PLOT ELEMENT TRACKING FORMAT:
For each significant plot element, create an entry with:
- Description of the element (object, knowledge, rule, etc.)
- When and how it's established in the narrative
- How it's used or referenced throughout the story
- Any changes or developments to the element

ISSUE REPORTING FORMAT:
For each plot inconsistency found:
- Number sequentially (e.g., "Plot Inconsistency #1")
- Show BOTH relevant text passages VERBATIM without adding quotation marks
- Explain the specific inconsistency
- Suggest a possible resolution if appropriate

EXAMPLE:
Plot Inconsistency #1:
First passage: The ancient amulet could only be destroyed in the fires where it was forged, deep within Mount Doom. No other force in the world could break it.
Second passage: With a mighty swing of his sword, Aragorn shattered the amulet into a thousand pieces, releasing its dark power into the wind.
Issue: The rules established for the amulet are contradictory. Initially, it's stated that the amulet can only be destroyed in a specific location (Mount Doom) and that no other force can break it. Later, a character destroys it with a conventional weapon without explanation.
Possible resolution: Either modify the initial rule about the amulet's invulnerability, explain how Aragorn's sword has special properties that allow it to break the rule, or revise the destruction scene to align with the established rules.

FINAL REPORT:
Provide a summary of key plot elements and established world rules, followed by all identified plot inconsistencies.

VERIFICATION:
At the end, confirm you checked ONLY for plot consistency issues and ignored all other types of issues as instructed.`;
    return template;
  }

  /**
   * Count words in text
   * @param {string} text - Text to count words in
   * @returns {number} - Word count
   */
  countWords(text) {
    return text.split(/\s+/).filter(word => word.length > 0).length;
  }
  
  /**
   * Ensure file path is absolute
   * @param {string} filePath - File path (may be relative or absolute)
   * @param {string} basePath - Base path to prepend for relative paths
   * @returns {string} - Absolute file path
   */
  ensureAbsolutePath(filePath, basePath) {
    if (!filePath) return filePath;
    
    // Check if the path is already absolute
    if (path.isAbsolute(filePath)) {
      return filePath;
    }
    
    // Make the path absolute by joining with the base path
    return path.join(basePath, filePath);
  }
  
  /**
   * Save report and thinking content to files
   * @param {string} content - Response content
   * @param {string} thinking - Thinking content
   * @param {number} promptTokens - Prompt token count
   * @param {number} responseTokens - Response token count
   * @param {string} saveDir - Directory to save to
   * @param {string} language - Language used for proofreading
   * @returns {Promise<string[]>} - Array of paths to saved files
   */
  async saveReport(
    content,
    thinking,
    promptTokens,
    responseTokens,
    saveDir,
    language = 'English'
  ) {
    try {
      const formatter = new Intl.DateTimeFormat('en-US', {
        weekday: 'long',
        month: 'long',
        day: 'numeric',
        year: 'numeric',
        hour: 'numeric',
        minute: '2-digit',
        hour12: true
      });
      const dateTimeStr = formatter.format(new Date());

      // Create timestamp for filename
      const timestamp = new Date().toISOString().replace(/[-:.]/g, '').substring(0, 15);
      
      // Create descriptive filename
      const baseFilename = `proofreader_plot_consistency_${language.toLowerCase()}_${timestamp}`;
      
      // Array to collect all saved file paths
      const savedFilePaths = [];
      
      // Create stats for thinking file
      const stats = `
Details:  ${dateTimeStr}
Language: ${language}
Max request timeout: ${this.config.request_timeout} seconds
Max AI model context window: ${this.config.context_window} tokens
AI model thinking budget: ${this.config.thinking_budget_tokens} tokens
Desired output tokens: ${this.config.desired_output_tokens} tokens

Input tokens: ${promptTokens}
Output tokens: ${responseTokens}
`;
      
      // Save full response
      const reportFilename = `${baseFilename}.txt`;
      const reportPath = path.join(saveDir, reportFilename);
      await this.writeOutputFile(content, saveDir, reportFilename);
      savedFilePaths.push(reportPath);
      this.emitOutput(`Report saved to: ${reportPath}\n`);

      // Save thinking content if available
      if (thinking) {
        const thinkingFilename = `${baseFilename}_thinking.txt`;
        const thinkingContent = `=== PROOFREADERPLOTCONSISTENCY THINKING ===

${thinking}

=== END PROOFREADERPLOTCONSISTENCY THINKING ===
${stats}`;
        
        const thinkingReportPath = path.join(saveDir, thinkingFilename);
        await this.writeOutputFile(thinkingContent, saveDir, thinkingFilename);
        savedFilePaths.push(thinkingReportPath);
        this.emitOutput(`AI thinking saved to: ${path.join(saveDir, thinkingFilename)}\n`);
      }
      
      return savedFilePaths;
    } catch (error) {
      console.error(`Error saving report:`, error);
      this.emitOutput(`Error saving report: ${error.message}\n`);
      throw error;
    }
  }
}

module.exports = ProofreaderPlotConsistency;


============================================================
FILE: punctuation-auditor.js
SIZE: 17986 bytes
LANGUAGE: JS
============================================================

// punctuation-auditor.js
const BaseTool = require('./base-tool');
const path = require('path');
const fileCache = require('./file-cache');
const appState = require('./state.js');
const fs = require('fs/promises');

/**
 * PunctuationAuditor Tool
 * Analyzes manuscript for punctuation effectiveness using the Claude API.
 * Identifies issues like run-on sentences, missing commas, and odd punctuation patterns
 * that might hinder clarity and flow, following Ursula K. Le Guin's writing principles.
 */
class PunctuationAuditor extends BaseTool {
  /**
   * Constructor
   * @param {Object} GeminiAPIService - Claude API service
   * @param {Object} config - Tool configuration
   */
  constructor(GeminiAPIService, config = {}) {
    super('punctuation_auditor', config);
    this.GeminiAPIService = GeminiAPIService;
  }

  /**
   * Execute the tool
   * @param {Object} options - Tool options
   * @returns {Promise<Object>} - Execution result
   */
  async execute(options) {
    console.log('Executing Punctuation Auditor with options:', options);
    
    // Extract options
    let manuscriptFile = options.manuscript_file;
    const analysisLevel = options.analysis_level;
    const elements = options.elements;
    const strictness = options.strictness;
    const saveDir = options.save_dir || appState.CURRENT_PROJECT_PATH;
    
    if (!saveDir) {
      const errorMsg = 'Error: No save directory specified and no current project selected.\n' +
                      'Please select a project or specify a save directory.';
      this.emitOutput(errorMsg);
      throw new Error('No save directory available');
    }

    // Ensure file paths are absolute
    manuscriptFile = this.ensureAbsolutePath(manuscriptFile, saveDir);
    
    // Log the full paths for debugging
    console.log('Using full paths:');
    console.log(`Manuscript: ${manuscriptFile}`);

    const outputFiles = [];
    
    try {
      // Read the input files
      this.emitOutput(`Reading files...\n`);

      // Read the manuscript file
      this.emitOutput(`Reading manuscript file: ${manuscriptFile}\n`);
      const manuscriptContent = await this.readInputFile(manuscriptFile);
      
      // Create the prompt
      const prompt = this.createPunctuationAnalysisPrompt(manuscriptContent, analysisLevel, elements, strictness);

      // Count tokens in the prompt
      this.emitOutput(`Counting tokens in prompt...\n`);
      const promptTokens = await this.GeminiAPIService.countTokens(prompt);

      // Call the shared token budget calculator
      const tokenBudgets = this.GeminiAPIService.calculateTokenBudgets(promptTokens);

      // Handle logging based on the returned values
      this.emitOutput(`\nToken stats:\n`);
      this.emitOutput(`Max AI model context window: [${tokenBudgets.contextWindow}] tokens\n`);
      this.emitOutput(`Input prompt tokens: [${tokenBudgets.promptTokens}] = manuscript tokens + prompt tokens\n`);
      this.emitOutput(`Available tokens: [${tokenBudgets.availableTokens}]  = ${tokenBudgets.contextWindow} - ${tokenBudgets.promptTokens} = context_window - prompt\n`);
      this.emitOutput(`Desired output tokens: [${tokenBudgets.desiredOutputTokens}]\n`);
      this.emitOutput(`AI model thinking budget: [${tokenBudgets.thinkingBudget}] tokens\n`);
      this.emitOutput(`Max output tokens: [${tokenBudgets.maxTokens}] tokens\n`);

      // Check for special conditions
      if (tokenBudgets.capThinkingBudget) {
        this.emitOutput(`Warning: thinking budget is larger than 32K, set to 32K.\n`);
      }

      // Check if the prompt is too large
      if (tokenBudgets.isPromptTooLarge) {
        this.emitOutput(`Error: prompt is too large to have a ${tokenBudgets.configuredThinkingBudget} thinking budget!\n`);
        this.emitOutput(`Run aborted!\n`);
        throw new Error(`Prompt is too large for ${tokenBudgets.configuredThinkingBudget} thinking budget - run aborted`);
      }
      
      // Call Claude API with streaming
      this.emitOutput(`>>> Sending request to Claude API (streaming)...\n`);

      // Add a message about waiting
      this.emitOutput(`****************************************************************************\n`);
      this.emitOutput(`*  Analyzing punctuation effectiveness in your manuscript...               \n`);
      this.emitOutput(`*  This process typically takes several minutes.                           \n`);
      this.emitOutput(`*                                                                          \n`);
      this.emitOutput(`*  It's recommended to keep this window the sole 'focus'                   \n`);
      this.emitOutput(`*  and to avoid browsing online or running other apps, as these API        \n`);
      this.emitOutput(`*  network connections are often flakey, like delicate echoes of whispers. \n`);
      this.emitOutput(`*                                                                          \n`);
      this.emitOutput(`*  So breathe, remove eye glasses, stretch, relax, and be like water 🥋 🧘🏽‍♀️\n`);
      this.emitOutput(`****************************************************************************\n\n`);
      
      const startTime = Date.now();
      let fullResponse = "";
      let thinkingContent = "";
      
      // Create system prompt to avoid markdown
      const systemPrompt = "CRITICAL INSTRUCTION: NO Markdown formatting of ANY kind. Never use headers, bullets, or any formatting symbols. Plain text only with standard punctuation.";

      // Use the calculated values in the API call - following pattern from rhythm-analyzer.js
      try {
        await this.GeminiAPIService.streamWithThinking(
          prompt,
          {
            system: systemPrompt,
            max_tokens: tokenBudgets.maxTokens,
            thinking: {
              type: "enabled",
              budget_tokens: tokenBudgets.thinkingBudget
            }
          },
          // Callback for thinking content
          (thinkingDelta) => {
            thinkingContent += thinkingDelta;
          },
          // Callback for response text
          (textDelta) => {
            fullResponse += textDelta;
          }
        );
      } catch (error) {
        this.emitOutput(`\nAPI Error: ${error.message}\n`);
        throw error;
      }

      const elapsed = (Date.now() - startTime) / 1000;
      const minutes = Math.floor(elapsed / 60);
      const seconds = elapsed % 60;
      
      this.emitOutput(`\nCompleted in ${minutes}m ${seconds.toFixed(2)}s.\n`);
      
      // Count words in response
      const wordCount = this.countWords(fullResponse);
      this.emitOutput(`Report has approximately ${wordCount} words.\n`);
      
      // Count tokens in response
      const responseTokens = await this.GeminiAPIService.countTokens(fullResponse);
      this.emitOutput(`Response token count: ${responseTokens}\n`);

      // Remove any markdown formatting
      fullResponse = this.removeMarkdown(fullResponse);

      // Save the report
      const outputFile = await this.saveReport(
        analysisLevel,
        elements,
        strictness,
        fullResponse,
        thinkingContent,
        promptTokens,
        responseTokens,
        saveDir
      );
      
      // Add all output files to the result
      outputFiles.push(...outputFile);
      
      // Add files to the cache
      const toolName = 'punctuation_auditor';
      outputFiles.forEach(file => {
        fileCache.addFile(toolName, file);
      });
      
      // Return the result
      return {
        success: true,
        outputFiles,
        stats: {
          wordCount,
          tokenCount: responseTokens,
          elapsedTime: `${minutes}m ${seconds.toFixed(2)}s`,
          analysisLevel,
          elements,
          strictness
        }
      };
    } catch (error) {
      console.error('Error in PunctuationAuditor:', error);
      this.emitOutput(`\nError: ${error.message}\n`);
      throw error;
    }
  }
  
  /**
   * Create punctuation analysis prompt
   * @param {string} manuscriptContent - Manuscript content
   * @param {string} analysisLevel - Analysis level (basic, standard, detailed)
   * @param {Array|string} elements - Punctuation elements to focus on
   * @param {string} strictness - Strictness level (low, medium, high)
   * @returns {string} - Prompt for Claude API
   */
  createPunctuationAnalysisPrompt(manuscriptContent, analysisLevel = "standard", elements = ["commas", "periods", "semicolons", "dashes", "parentheses", "colons", "run-ons"], strictness = "medium") {
    // Build instruction section based on analysis level
    const basicInstructions = `
1. PUNCTUATION OVERVIEW:
   - Analyze overall patterns of punctuation usage in the manuscript
   - Identify common punctuation habits
   - Note any immediate issues with basic punctuation (missing periods, etc.)

2. RUN-ON SENTENCE IDENTIFICATION:
   - Identify overly long sentences with inadequate punctuation
   - Flag sentences that may cause confusion due to length or structure
   - Suggest natural breaking points and punctuation improvements

3. COMMA USAGE ANALYSIS:
   - Highlight missing commas in compound sentences
   - Identify comma splices (two complete sentences joined only by a comma)
   - Point out necessary commas missing after introductory phrases
   - Note any patterns of comma overuse
`;

    const standardInstructions = basicInstructions + `
4. SPECIALIZED PUNCTUATION ANALYSIS:
   - Evaluate semicolon and colon usage for correctness and effectiveness
   - Assess dash usage (em dashes, en dashes, hyphens) for consistency and clarity
   - Review parenthetical expressions and their impact on readability
   - Examine quotation mark and dialogue punctuation conventions

5. READABILITY IMPACT ASSESSMENT:
   - Analyze how punctuation patterns affect the flow and rhythm of sentences
   - Identify passages where punctuation hinders natural reading cadence
   - Suggest punctuation changes to improve overall readability
   - Note patterns where punctuation style might be adjusted to match content
`;

    const detailedInstructions = standardInstructions + `
6. SENTENCE STRUCTURE AND PUNCTUATION:
   - Analyze how punctuation interacts with sentence structure
   - Identify complex sentences that might benefit from restructuring
   - Suggest alternative punctuation strategies for particularly challenging passages
   - Examine nested clauses and their punctuation

7. DIALOGUE AND QUOTATION ANALYSIS:
   - Review dialogue punctuation conventions and consistency
   - Assess quotation mark usage, including nested quotations
   - Examine speaker attribution and its punctuation
   - Suggest improvements for unclear dialogue punctuation

8. ADVANCED PUNCTUATION STRATEGIES:
   - Recommend stylistic punctuation techniques from master prose writers
   - Suggest intentional punctuation variations to create emphasis or effect
   - Analyze how punctuation might be used to establish or enhance voice
   - Provide examples of innovative punctuation approaches that maintain clarity
`;

    // Choose the appropriate instruction level
    let instructionSet;
    if (analysisLevel === "basic") {
      instructionSet = basicInstructions;
    } else if (analysisLevel === "detailed") {
      instructionSet = detailedInstructions;
    } else {  // standard
      instructionSet = standardInstructions;
    }

    // Construct the elements emphasis
    let elementsText;
    if (Array.isArray(elements)) {
      elementsText = elements.join(", ");
    } else {
      // Handle the case where elements might be a string
      elementsText = String(elements);
    }

    // Adjust instructions based on strictness level
    const strictnessInstructions = {
      "low": "Focus only on major punctuation issues that significantly impact readability or clarity.",
      "medium": "Identify moderate to major punctuation issues, balancing mechanical correctness with stylistic considerations.",
      "high": "Perform a detailed analysis of punctuation usage, noting even minor or stylistic issues."
    };
    
    const strictnessText = strictnessInstructions[strictness] || strictnessInstructions["medium"];

    // Construct the full prompt
    const instructions = `IMPORTANT: NO Markdown formatting

You are an expert literary editor specializing in punctuation and its impact on prose clarity and flow. Your task is to analyze the provided manuscript for punctuation effectiveness, focusing particularly on: ${elementsText}.

Follow Ursula K. Le Guin's principle from "Steering the Craft" that punctuation should guide how the text "sounds" to a reader. Analyze how punctuation either supports or hinders the clarity, rhythm, and natural flow of the prose.

Strictness level: ${strictness}. ${strictnessText}

Pay special attention to:
1. Overly long sentences that lack adequate punctuation (run-ons)
2. Missing commas that would clarify meaning or improve readability
3. Unusual or inconsistent punctuation patterns
4. Places where reading aloud would reveal awkward punctuation
5. Sentences where alternative punctuation would improve flow or clarity

For each issue you identify, provide:
- The original passage
- What makes the punctuation problematic
- A specific recommendation for improvement

Create a comprehensive punctuation analysis with these sections:
${instructionSet}

Format your analysis as a clear, organized report with sections and subsections. Use plain text formatting only (NO Markdown). Use numbered or bulleted lists where appropriate for clarity.

Be specific in your examples and suggestions, showing how punctuation can be improved without changing the author's voice or intention. Focus on practical changes that will make the writing more readable and effective.
`;

    // Combine all sections
    return `=== MANUSCRIPT ===\n${manuscriptContent}\n=== END MANUSCRIPT ===\n\n${instructions}`;
  }

  /**
   * Count words in text
   * @param {string} text - Text to count words in
   * @returns {number} - Word count
   */
  countWords(text) {
    return text.split(/\s+/).filter(word => word.length > 0).length;
  }
  
  /**
   * Ensure file path is absolute
   * @param {string} filePath - File path (may be relative or absolute)
   * @param {string} basePath - Base path to prepend for relative paths
   * @returns {string} - Absolute file path
   */
  ensureAbsolutePath(filePath, basePath) {
    if (!filePath) return filePath;
    
    // Check if the path is already absolute
    if (path.isAbsolute(filePath)) {
      return filePath;
    }
    
    // Make the path absolute by joining with the base path
    return path.join(basePath, filePath);
  }
  
  /**
   * Save report and thinking content to files
   * @param {string} analysisLevel - Analysis level (basic, standard, detailed)
   * @param {Array|string} elements - Punctuation elements analyzed
   * @param {string} strictness - Strictness level (low, medium, high)
   * @param {string} content - Response content
   * @param {string} thinking - Thinking content
   * @param {number} promptTokens - Prompt token count
   * @param {number} responseTokens - Response token count
   * @param {string} saveDir - Directory to save to
   * @returns {Promise<string[]>} - Array of paths to saved files
   */
  async saveReport(
    analysisLevel,
    elements,
    strictness,
    content,
    thinking,
    promptTokens,
    responseTokens,
    saveDir
  ) {
    try {
      const formatter = new Intl.DateTimeFormat('en-US', {
        weekday: 'long',
        month: 'long',
        day: 'numeric',
        year: 'numeric',
        hour: 'numeric',
        minute: '2-digit',
        hour12: true
      });
      const dateTimeStr = formatter.format(new Date());

      // Create timestamp for filename
      const timestamp = new Date().toISOString().replace(/[-:.]/g, '').substring(0, 15);
      
      // Create descriptive filename
      const level = analysisLevel !== 'standard' ? `_${analysisLevel}` : '';
      const baseFilename = `punctuation_audit${level}_${timestamp}`;
      
      // Array to collect all saved file paths
      const savedFilePaths = [];
      
      // Format elements for stats
      const elementsStr = Array.isArray(elements) ? elements.join(', ') : elements;
      
      // Create stats for thinking file
      const stats = `
Details:  ${dateTimeStr}
Analysis type: Punctuation effectiveness analysis
Analysis level: ${analysisLevel}
Punctuation elements: ${elementsStr}
Strictness level: ${strictness}
Max request timeout: ${this.config.request_timeout} seconds
Max AI model context window: ${this.config.context_window} tokens
AI model thinking budget: ${this.config.thinking_budget_tokens} tokens
Desired output tokens: ${this.config.desired_output_tokens} tokens

Input tokens: ${promptTokens}
Output tokens: ${responseTokens}
`;
      
      // Save full response
      const reportFilename = `${baseFilename}.txt`;
      const reportPath = path.join(saveDir, reportFilename);
      await this.writeOutputFile(content, saveDir, reportFilename);
      savedFilePaths.push(reportPath);
      
      // Save thinking content if available and not skipped
      if (thinking) {
        const thinkingFilename = `${baseFilename}_thinking.txt`;
        const thinkingPath = path.join(saveDir, thinkingFilename);
        const thinkingContent = `=== PUNCTUATION EFFECTIVENESS ANALYSIS ===

=== AI'S THINKING PROCESS ===

${thinking}

=== END AI'S THINKING PROCESS ===
${stats}`;
        
        await this.writeOutputFile(thinkingContent, saveDir, thinkingFilename);
        this.emitOutput(`AI thinking saved to: ${thinkingPath}\n`);
        savedFilePaths.push(thinkingPath);
      }

      this.emitOutput(`Report saved to: ${reportPath}\n`);
      return savedFilePaths;
    } catch (error) {
      console.error(`Error saving report:`, error);
      this.emitOutput(`Error saving report: ${error.message}\n`);
      throw error;
    }
  }
}

module.exports = PunctuationAuditor;


============================================================
FILE: registry.js
SIZE: 1075 bytes
LANGUAGE: JS
============================================================

// registry.js

/**
 * Registry for all tool implementations
 */
class ToolRegistry {
  constructor() {
    this.tools = new Map();
    console.log('ToolRegistry initialized');
  }
  
  /**
   * Register a tool
   * @param {string} toolId - Tool ID
   * @param {object} toolInstance - Tool instance
   */
  registerTool(toolId, toolInstance) {
    console.log(`Registering tool: ${toolId}`);
    this.tools.set(toolId, toolInstance);
  }
  
  /**
   * Get a tool by ID
   * @param {string} toolId - Tool ID
   * @returns {object|null} - Tool instance or null if not found
   */
  getTool(toolId) {
    const tool = this.tools.get(toolId);
    if (!tool) {
      console.log(`Tool not found: ${toolId}. Available tools: ${Array.from(this.tools.keys())}`);
    }
    return tool;
  }
  
  /**
   * Get all tool IDs
   * @returns {string[]} - Array of tool IDs
   */
  getAllToolIds() {
    const ids = Array.from(this.tools.keys());
    // console.log('All registered tool IDs:', ids);
    return ids;
  }
}

// Export a singleton instance
module.exports = new ToolRegistry();


============================================================
FILE: renderer.js
SIZE: 30347 bytes
LANGUAGE: JS
============================================================

// Get elements
const themeToggleBtn = document.getElementById('theme-toggle');
const sunIcon = document.getElementById('sun-icon');
const moonIcon = document.getElementById('moon-icon');
const quitButton = document.getElementById('quit-button');
const apiSettingsBtn = document.getElementById('api-settings-btn');
const body = document.body;

// Track theme state (initially dark)
let isDarkMode = true;

// Function to get a human-readable timestamp
function getReadableTimestamp() {
  const date = new Date();
  
  // Get day of week (abbreviated)
  const daysOfWeek = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
  const dayOfWeek = daysOfWeek[date.getDay()];
  
  // Get month (abbreviated)
  const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
  const month = months[date.getMonth()];
  
  // Get day and year
  const day = date.getDate();
  const year = date.getFullYear();
  
  // Get hours in 12-hour format
  let hours = date.getHours();
  const ampm = hours >= 12 ? 'pm' : 'am';
  hours = hours % 12;
  hours = hours ? hours : 12; // Convert 0 to 12
  
  // Get minutes
  const minutes = String(date.getMinutes()).padStart(2, '0');
  
  // Construct the readable timestamp
  return `${dayOfWeek} ${month} ${day}, ${year} ${hours}:${minutes}${ampm}`;
}

// Function to update the timestamp display
function updateTimestamp() {
  const timestampElement = document.getElementById('timestamp');
  if (timestampElement) {
    timestampElement.textContent = getReadableTimestamp();
  }
}

// Update icon visibility based on the current theme
function updateThemeIcons() {
  if (isDarkMode) {
    sunIcon.style.display = 'block';
    moonIcon.style.display = 'none';
  } else {
    sunIcon.style.display = 'none';
    moonIcon.style.display = 'block';
  }
}

// Initialize icons on page load
updateThemeIcons();

// Toggle between dark and light mode
themeToggleBtn.addEventListener('click', () => {
  isDarkMode = !isDarkMode;
  
  if (isDarkMode) {
    body.classList.remove('light-mode');
    body.classList.add('dark-mode');
  } else {
    body.classList.remove('dark-mode');
    body.classList.add('light-mode');
  }
  
  // Update icons when theme changes
  updateThemeIcons();
});

// Quit application when quit button is clicked
quitButton.addEventListener('click', () => {
  window.electronAPI.quitApp();
});

// Project selection functionality
const selectProjectBtn = document.getElementById('select-project-btn');
const currentProjectName = document.getElementById('current-project-name');
const currentProjectPath = document.getElementById('current-project-path');

// Tool selection functionality
const aiToolSelect = document.getElementById('ai-tool-select');
const aiToolDescription = document.getElementById('ai-tool-description');
const aiSetupRunBtn = document.getElementById('ai-setup-run-btn');

const nonAiToolSelect = document.getElementById('non-ai-tool-select');
const nonAiToolDescription = document.getElementById('non-ai-tool-description');
const nonAiSetupRunBtn = document.getElementById('non-ai-setup-run-btn');

// List of non-AI tool IDs
const nonAiToolIds = ["docx_comments", "epub_converter"];

// Load current project info when the app starts
async function loadProjectInfo() {
  try {
    const projectInfo = await window.electronAPI.getProjectInfo();
    updateProjectDisplay(projectInfo);
  } catch (error) {
    console.error('Error loading project info:', error);
  }
}

// Update the project display in the UI
function updateProjectDisplay(projectInfo) {
  if (projectInfo && projectInfo.current_project) {
    currentProjectName.textContent = projectInfo.current_project;
    currentProjectName.classList.remove('no-project');
    
    if (projectInfo.current_project_path) {
      currentProjectPath.textContent = `Project Path: ${projectInfo.current_project_path}`;
      currentProjectPath.style.display = 'block';
    } else {
      currentProjectPath.style.display = 'none';
    }
  } else {
    currentProjectName.textContent = 'No project selected';
    currentProjectName.classList.add('no-project');
    currentProjectPath.style.display = 'none';
  }
}

// Handle the select project button click
selectProjectBtn.addEventListener('click', () => {
  window.electronAPI.selectProject();
});

// Listen for project updates from the main process
window.electronAPI.onProjectUpdated((event) => {
  if (event.project) {
    updateProjectDisplay({
      current_project: event.project.projectName,
      current_project_path: event.project.projectPath
    });
    
    // Reload tools list after project change
    loadAiTools();
    loadNonAiTools();
  }
});

// Function to determine if a tool is an AI tool
function isAiTool(tool) {
  return !nonAiToolIds.includes(tool.name.toLowerCase());
}

async function loadAiTools() {
  console.log('*** loadAiTools: Fetching AI tools from main process...');
  const tools = await window.electronAPI.getTools();
  console.log(`Received ${tools.length} tools from main process:`, tools);
  
  // Filter to only include AI tools
  const aiTools = tools.filter(tool => isAiTool(tool));
  
  // Clear any existing options
  aiToolSelect.innerHTML = '';
  
  if (!aiTools || aiTools.length === 0) {
    const option = document.createElement('option');
    option.disabled = true;
    option.textContent = 'No AI tools available';
    aiToolSelect.appendChild(option);
    return;
  }
  
  // Define tool categories
  const topTools = ["tokens_words_counter", "narrative_integrity", "developmental_editing", "line_editing", "copy_editing", "proofreader_mechanical", "proofreader_plot_consistency", "manuscript_to_outline_characters_world"];
  const roughDraftTools = ["brainstorm", "outline_writer", "world_writer", "chapter_writer"];
  
  // Track which tools have been added to avoid duplicates
  const addedTools = new Set();
  
  // Add the top tools to select
  aiTools.forEach(tool => {
    if (topTools.includes(tool.name)) {
      const option = document.createElement('option');
      option.value = tool.name;
      option.textContent = tool.title;
      option.dataset.description = tool.description;
      aiToolSelect.appendChild(option);
      addedTools.add(tool.name);
    }
  });
  
  // Add the "Editor Tools" header
  const editorHeader = document.createElement('option');
  editorHeader.disabled = true;
  editorHeader.value = '';
  editorHeader.textContent = '- Other Editing Tools:';
  editorHeader.style.color = '#999';
  editorHeader.style.fontWeight = 'bold';
  editorHeader.style.backgroundColor = '#252525';
  editorHeader.style.padding = '2px';
  aiToolSelect.appendChild(editorHeader);
  
  // Filter out the rough draft tools
  const relevantTools = aiTools.filter(tool => 
    !roughDraftTools.includes(tool.name) && !addedTools.has(tool.name)
  );

  // Then process only the tools we care about
  relevantTools.forEach(tool => {
  // aiTools.forEach(tool => {
    if (roughDraftTools.includes(tool.name)) {
      return; // skip rough-draft tools
    }

    if (!addedTools.has(tool.name)) {
      const option = document.createElement('option');
      option.value = tool.name;
      option.textContent = tool.title;
      option.dataset.description = tool.description;
      aiToolSelect.appendChild(option);
    }
  });
  
  // Now, append to the end the "Rough Draft Writing Tools" header
  const roughDraftHeader = document.createElement('option');
  roughDraftHeader.disabled = true;
  roughDraftHeader.value = '';
  roughDraftHeader.textContent = '- AI Rough Draft Writing Tools:';
  roughDraftHeader.style.color = '#999';
  roughDraftHeader.style.fontWeight = 'bold';
  roughDraftHeader.style.backgroundColor = '#252525';
  roughDraftHeader.style.padding = '2px';
  aiToolSelect.appendChild(roughDraftHeader);
  
  // Then add the rough draft tools
  aiTools.forEach(tool => {
    if (roughDraftTools.includes(tool.name)) {
      const option = document.createElement('option');
      option.value = tool.name;
      option.textContent = tool.title;
      option.dataset.description = tool.description;
      aiToolSelect.appendChild(option);
      addedTools.add(tool.name);
    }
  });
  
  // Count the actual options (excluding headers)
  const actualOptions = Array.from(aiToolSelect.options).filter(opt => !opt.disabled).length;
  
  // Select the first tool by default
  if (actualOptions > 0) {
    // Find first non-disabled option
    const firstOption = Array.from(aiToolSelect.options).find(opt => !opt.disabled);
    if (firstOption) {
      aiToolSelect.value = firstOption.value;
      aiToolDescription.textContent = firstOption.dataset.description;
    }
  }
}

async function loadNonAiTools() {
  console.log('Fetching non-AI tools from main process...');
  console.log('Current nonAiToolIds:', nonAiToolIds);
  
  const tools = await window.electronAPI.getTools();
  console.log('All tools received from main process:', tools);
  console.log('All tool names:', tools.map(tool => tool.name));
  
  // Filter to only include non-AI tools
  const nonAiTools = tools.filter(tool => nonAiToolIds.includes(tool.name));
  console.log('Filtered non-AI tools:', nonAiTools);
  console.log('Number of non-AI tools after filtering:', nonAiTools.length);
  
  // Clear any existing options
  nonAiToolSelect.innerHTML = '';
  console.log('Cleared existing options from nonAiToolSelect');
  
  if (!nonAiTools || nonAiTools.length === 0) {
    console.log('No non-AI tools found, adding disabled message');
    const option = document.createElement('option');
    option.disabled = true;
    option.textContent = 'No non-AI tools available';
    nonAiToolSelect.appendChild(option);
    return;
  }
  
  // Add all non-AI tools
  nonAiTools.forEach((tool, index) => {
    console.log(`Adding non-AI tool ${index + 1}:`, tool);
    console.log(`Tool title: "${tool.title}", Tool description: "${tool.description}"`);
    const option = document.createElement('option');
    option.value = tool.name;
    option.textContent = tool.title;
    option.dataset.description = tool.description || 'No description available.';
    nonAiToolSelect.appendChild(option);
    console.log(`Added non-AI tool: ${tool.name} with title: ${tool.title}`);
  });
  
  // Count the actual options
  const actualOptions = nonAiTools.length;
  console.log(`Added ${actualOptions} selectable non-AI tool options to dropdown`);
  
  // Verify the options were actually added to the DOM
  console.log('Final nonAiToolSelect content:', nonAiToolSelect.innerHTML);
  console.log('Final nonAiToolSelect.options:', Array.from(nonAiToolSelect.options).map(opt => ({
    value: opt.value,
    text: opt.textContent,
    disabled: opt.disabled
  })));
  
  // Select the first tool by default
  if (actualOptions > 0) {
    nonAiToolSelect.value = nonAiTools[0].name;
    nonAiToolDescription.textContent = nonAiTools[0].description || 'No description available.';
    console.log(`Selected default non-AI tool: ${nonAiTools[0].name}`);
  }
}

// Update the AI tool description when a different tool is selected
aiToolSelect.addEventListener('change', () => {
  const selectedOption = aiToolSelect.options[aiToolSelect.selectedIndex];
  if (selectedOption) {
    aiToolDescription.textContent = selectedOption.dataset.description || 'No description available.';
  }
});

// Update the non-AI tool description when a different tool is selected
nonAiToolSelect.addEventListener('change', () => {
  const selectedOption = nonAiToolSelect.options[nonAiToolSelect.selectedIndex];
  if (selectedOption) {
    nonAiToolDescription.textContent = selectedOption.dataset.description || 'No description available.';
  }
});

// Handle the AI Setup & Run button
aiSetupRunBtn.addEventListener('click', () => {
  const selectedTool = aiToolSelect.value;
  if (!selectedTool) {
    alert('Please select a tool first.');
    return;
  }
  
  // Launch the tool setup dialog with the current selection
  window.electronAPI.showToolSetupDialog(selectedTool);
});

// Handle the non-AI Setup & Run button
nonAiSetupRunBtn.addEventListener('click', () => {
  const selectedTool = nonAiToolSelect.value;
  if (!selectedTool) {
    alert('Please select a tool first.');
    return;
  }
  
  // Launch the tool setup dialog with the current selection
  window.electronAPI.showToolSetupDialog(selectedTool);
});

// Editor button handler
const openEditorBtn = document.getElementById('open-editor-btn');
if (openEditorBtn) {
  openEditorBtn.addEventListener('click', async () => {
    try {
      const success = await window.electronAPI.launchEditor();
      if (!success) {
        console.error('Failed to launch editor');
        // You could show an error notification here if you have one
      }
    } catch (error) {
      console.error('Error launching editor:', error);
    }
  });
}

// Import DOCX button handler
const importDocxBtn = document.getElementById('import-docx-btn');
if (importDocxBtn) {
  importDocxBtn.addEventListener('click', async () => {
    try {
      // Check if a project is selected
      const projectInfo = await window.electronAPI.getProjectInfo();
      if (!projectInfo || !projectInfo.current_project) {
        alert('Please select a project first.');
        return;
      }
      
      // Configure file selection options for DOCX files
      const fileOptions = {
        title: 'Select DOCX File to Convert',
        buttonLabel: 'Select DOCX',
        filters: [
          { name: 'DOCX Files', extensions: ['docx'] },
          { name: 'All Files', extensions: ['*'] }
        ],
        defaultPath: projectInfo.current_project_path
      };
      
      // Open file selection dialog
      const docxPath = await window.electronAPI.selectFile(fileOptions);
      
      // If user cancelled or no file selected
      if (!docxPath) {
        return;
      }
      
      // Use default filename based on the selected file
      const docxFileName = docxPath.split('/').pop().split('\\').pop();
      const defaultOutputName = docxFileName.replace(/\.docx$/i, '.txt');
      
      // Create a custom dialog for filename input
      const filenameDialog = document.createElement('div');
      filenameDialog.style.position = 'fixed';
      filenameDialog.style.top = '0';
      filenameDialog.style.left = '0';
      filenameDialog.style.width = '100%';
      filenameDialog.style.height = '100%';
      filenameDialog.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
      filenameDialog.style.display = 'flex';
      filenameDialog.style.justifyContent = 'center';
      filenameDialog.style.alignItems = 'center';
      filenameDialog.style.zIndex = '1000';
      
      // Dialog content
      const dialogContent = document.createElement('div');
      dialogContent.style.backgroundColor = document.body.classList.contains('light-mode') ? '#ffffff' : '#1e1e1e';
      dialogContent.style.color = document.body.classList.contains('light-mode') ? '#222222' : '#ffffff';
      dialogContent.style.padding = '20px';
      dialogContent.style.borderRadius = '8px';
      dialogContent.style.width = '400px';
      dialogContent.style.boxShadow = '0 4px 12px rgba(0, 0, 0, 0.2)';
      
      const dialogTitle = document.createElement('h3');
      dialogTitle.textContent = 'Output Filename';
      dialogTitle.style.marginBottom = '15px';
      
      const dialogMessage = document.createElement('p');
      dialogMessage.textContent = 'Enter name for the output text file:';
      dialogMessage.style.marginBottom = '15px';
      
      const filenameInput = document.createElement('input');
      filenameInput.type = 'text';
      filenameInput.value = defaultOutputName;
      filenameInput.style.width = '100%';
      filenameInput.style.padding = '8px';
      filenameInput.style.backgroundColor = document.body.classList.contains('light-mode') ? '#ffffff' : '#2a2a2a';
      filenameInput.style.color = document.body.classList.contains('light-mode') ? '#222222' : '#ffffff';
      filenameInput.style.border = document.body.classList.contains('light-mode') ? '1px solid #cccccc' : '1px solid #333333';
      filenameInput.style.borderRadius = '4px';
      filenameInput.style.fontSize = '16px';
      filenameInput.style.marginBottom = '20px';
      
      const buttonContainer = document.createElement('div');
      buttonContainer.style.display = 'flex';
      buttonContainer.style.justifyContent = 'flex-end';
      buttonContainer.style.gap = '10px';
      
      const cancelButton = document.createElement('button');
      cancelButton.textContent = 'Cancel';
      cancelButton.style.padding = '8px 16px';
      cancelButton.style.backgroundColor = 'transparent';
      cancelButton.style.color = '#4a89dc';
      cancelButton.style.border = '1px solid #4a89dc';
      cancelButton.style.borderRadius = '4px';
      cancelButton.style.cursor = 'pointer';
      
      const okButton = document.createElement('button');
      okButton.textContent = 'Convert';
      okButton.style.padding = '8px 16px';
      okButton.style.backgroundColor = '#7e57c2';
      okButton.style.color = 'white';
      okButton.style.border = 'none';
      okButton.style.borderRadius = '4px';
      okButton.style.cursor = 'pointer';
      
      // Build dialog
      buttonContainer.appendChild(cancelButton);
      buttonContainer.appendChild(okButton);
      
      dialogContent.appendChild(dialogTitle);
      dialogContent.appendChild(dialogMessage);
      dialogContent.appendChild(filenameInput);
      dialogContent.appendChild(buttonContainer);
      
      filenameDialog.appendChild(dialogContent);
      
      // Add dialog to document
      document.body.appendChild(filenameDialog);
      
      // Focus on input
      filenameInput.focus();
      filenameInput.select();
      
      // Handle dialog actions
      return new Promise((resolve) => {
        cancelButton.addEventListener('click', () => {
          document.body.removeChild(filenameDialog);
          resolve(null);
        });
        
        okButton.addEventListener('click', async () => {
          let outputFilename = filenameInput.value.trim();
          
          // Ensure filename is valid
          if (!outputFilename) {
            outputFilename = defaultOutputName;
          }
          
          // Ensure it has a .txt extension
          if (!outputFilename.toLowerCase().endsWith('.txt')) {
            outputFilename += '.txt';
          }
          
          document.body.removeChild(filenameDialog);
          
          // Show a loading indicator
          const loadingDiv = document.createElement('div');
          loadingDiv.textContent = 'Converting DOCX to TXT...';
          loadingDiv.style.position = 'fixed';
          loadingDiv.style.top = '50%';
          loadingDiv.style.left = '50%';
          loadingDiv.style.transform = 'translate(-50%, -50%)';
          loadingDiv.style.padding = '20px';
          loadingDiv.style.backgroundColor = document.body.classList.contains('light-mode') ? '#f0f0f0' : '#333';
          loadingDiv.style.color = document.body.classList.contains('light-mode') ? '#222' : '#fff';
          loadingDiv.style.borderRadius = '5px';
          loadingDiv.style.zIndex = '1000';
          document.body.appendChild(loadingDiv);
          
          try {
            // Call the main process to convert the file
            const result = await window.electronAPI.convertDocxToTxt(docxPath, outputFilename);
            
            // Remove loading indicator
            if (document.body.contains(loadingDiv)) {
              document.body.removeChild(loadingDiv);
            }

            // Only show alert if a dialog wasn't already shown in the main process
            if (result.success && !result.dialogShown) {
              alert(`Conversion complete! Output saved as ${result.outputFilename}\nFound ${result.chapterCount} chapters.`);
            } else if (!result.success) {
              alert(`Failed to convert file: ${result.message || 'Unknown error'}`);
            }

          } catch (error) {
            // Remove loading indicator on error
            if (document.body.contains(loadingDiv)) {
              document.body.removeChild(loadingDiv);
            }
            console.error('Conversion error:', error);
            alert(`Error converting file: ${error.message || 'Unknown error'}`);
          }
          
          resolve(true);
        });
        
        // Also handle Enter key in the input
        filenameInput.addEventListener('keydown', (event) => {
          if (event.key === 'Enter') {
            okButton.click();
          }
        });
      });
    } catch (error) {
      console.error('Error in DOCX import process:', error);
      alert(`Error: ${error.message || 'Unknown error occurred'}`);
    }
  });
}

// Export TXT button handler (add after the importDocxBtn event handler)
const exportTxtBtn = document.getElementById('export-txt-btn');
if (exportTxtBtn) {
  exportTxtBtn.addEventListener('click', async () => {
    try {
      // Check if a project is selected
      const projectInfo = await window.electronAPI.getProjectInfo();
      if (!projectInfo || !projectInfo.current_project) {
        alert('Please select a project first.');
        return;
      }
      
      // Configure file selection options for TXT files
      const fileOptions = {
        title: 'Select TXT File to Convert',
        buttonLabel: 'Select TXT',
        filters: [
          { name: 'Text Files', extensions: ['txt'] },
          { name: 'All Files', extensions: ['*'] }
        ],
        defaultPath: projectInfo.current_project_path
      };
      
      // Open file selection dialog
      const txtPath = await window.electronAPI.selectFile(fileOptions);
      
      // If user cancelled or no file selected
      if (!txtPath) {
        return;
      }
      
      // Use default filename based on the selected file
      const txtFileName = txtPath.split('/').pop().split('\\').pop();
      const defaultOutputName = txtFileName.replace(/\.txt$/i, '.docx');
      
      // Create a custom dialog for filename input
      const filenameDialog = document.createElement('div');
      filenameDialog.style.position = 'fixed';
      filenameDialog.style.top = '0';
      filenameDialog.style.left = '0';
      filenameDialog.style.width = '100%';
      filenameDialog.style.height = '100%';
      filenameDialog.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
      filenameDialog.style.display = 'flex';
      filenameDialog.style.justifyContent = 'center';
      filenameDialog.style.alignItems = 'center';
      filenameDialog.style.zIndex = '1000';
      
      // Dialog content
      const dialogContent = document.createElement('div');
      dialogContent.style.backgroundColor = document.body.classList.contains('light-mode') ? '#ffffff' : '#1e1e1e';
      dialogContent.style.color = document.body.classList.contains('light-mode') ? '#222222' : '#ffffff';
      dialogContent.style.padding = '20px';
      dialogContent.style.borderRadius = '8px';
      dialogContent.style.width = '400px';
      dialogContent.style.boxShadow = '0 4px 12px rgba(0, 0, 0, 0.2)';
      
      const dialogTitle = document.createElement('h3');
      dialogTitle.textContent = 'Output Filename';
      dialogTitle.style.marginBottom = '15px';
      
      const dialogMessage = document.createElement('p');
      dialogMessage.textContent = 'Enter name for the output DOCX file:';
      dialogMessage.style.marginBottom = '15px';
      
      const filenameInput = document.createElement('input');
      filenameInput.type = 'text';
      filenameInput.value = defaultOutputName;
      filenameInput.style.width = '100%';
      filenameInput.style.padding = '8px';
      filenameInput.style.backgroundColor = document.body.classList.contains('light-mode') ? '#ffffff' : '#2a2a2a';
      filenameInput.style.color = document.body.classList.contains('light-mode') ? '#222222' : '#ffffff';
      filenameInput.style.border = document.body.classList.contains('light-mode') ? '1px solid #cccccc' : '1px solid #333333';
      filenameInput.style.borderRadius = '4px';
      filenameInput.style.fontSize = '16px';
      filenameInput.style.marginBottom = '20px';
      
      const buttonContainer = document.createElement('div');
      buttonContainer.style.display = 'flex';
      buttonContainer.style.justifyContent = 'flex-end';
      buttonContainer.style.gap = '10px';
      
      const cancelButton = document.createElement('button');
      cancelButton.textContent = 'Cancel';
      cancelButton.style.padding = '8px 16px';
      cancelButton.style.backgroundColor = 'transparent';
      cancelButton.style.color = '#4a89dc';
      cancelButton.style.border = '1px solid #4a89dc';
      cancelButton.style.borderRadius = '4px';
      cancelButton.style.cursor = 'pointer';
      
      const okButton = document.createElement('button');
      okButton.textContent = 'Convert';
      okButton.style.padding = '8px 16px';
      okButton.style.backgroundColor = '#7e57c2';
      okButton.style.color = 'white';
      okButton.style.border = 'none';
      okButton.style.borderRadius = '4px';
      okButton.style.cursor = 'pointer';
      
      // Build dialog
      buttonContainer.appendChild(cancelButton);
      buttonContainer.appendChild(okButton);
      
      dialogContent.appendChild(dialogTitle);
      dialogContent.appendChild(dialogMessage);
      dialogContent.appendChild(filenameInput);
      dialogContent.appendChild(buttonContainer);
      
      filenameDialog.appendChild(dialogContent);
      
      // Add dialog to document
      document.body.appendChild(filenameDialog);
      
      // Focus on input
      filenameInput.focus();
      filenameInput.select();
      
      // Handle dialog actions
      return new Promise((resolve) => {
        cancelButton.addEventListener('click', () => {
          document.body.removeChild(filenameDialog);
          resolve(null);
        });
        
        okButton.addEventListener('click', async () => {
          let outputFilename = filenameInput.value.trim();
          
          // Ensure filename is valid
          if (!outputFilename) {
            outputFilename = defaultOutputName;
          }
          
          // Ensure it has a .docx extension
          if (!outputFilename.toLowerCase().endsWith('.docx')) {
            outputFilename += '.docx';
          }
          
          document.body.removeChild(filenameDialog);
          
          // Show a loading indicator
          const loadingDiv = document.createElement('div');
          loadingDiv.textContent = 'Converting TXT to DOCX...';
          loadingDiv.style.position = 'fixed';
          loadingDiv.style.top = '50%';
          loadingDiv.style.left = '50%';
          loadingDiv.style.transform = 'translate(-50%, -50%)';
          loadingDiv.style.padding = '20px';
          loadingDiv.style.backgroundColor = document.body.classList.contains('light-mode') ? '#f0f0f0' : '#333';
          loadingDiv.style.color = document.body.classList.contains('light-mode') ? '#222' : '#fff';
          loadingDiv.style.borderRadius = '5px';
          loadingDiv.style.zIndex = '1000';
          document.body.appendChild(loadingDiv);
          
          try {
            // Call the main process to convert the file
            const result = await window.electronAPI.convertTxtToDocx(txtPath, outputFilename);
            
            // Remove loading indicator
            if (document.body.contains(loadingDiv)) {
              document.body.removeChild(loadingDiv);
            }

            if (result.success) {
              alert(`Conversion complete! Output saved as ${result.outputFilename}\nFormatted ${result.paragraphCount} paragraphs with ${result.chapterCount} chapters.`);
            } else {
              alert(`Failed to convert file: ${result.message || 'Unknown error'}`);
            }

          } catch (error) {
            // Remove loading indicator on error
            if (document.body.contains(loadingDiv)) {
              document.body.removeChild(loadingDiv);
            }
            console.error('Conversion error:', error);
            alert(`Error converting file: ${error.message || 'Unknown error'}`);
          }
          
          resolve(true);
        });
        
        // Also handle Enter key in the input
        filenameInput.addEventListener('keydown', (event) => {
          if (event.key === 'Enter') {
            okButton.click();
          }
        });
      });
    } catch (error) {
      console.error('Error in TXT export process:', error);
      alert(`Error: ${error.message || 'Unknown error occurred'}`);
    }
  });
}

// Open API Settings dialog
if (apiSettingsBtn) {
  apiSettingsBtn.addEventListener('click', () => {
    window.electronAPI.showApiSettingsDialog();
  });
}

// Listen for API settings updates
window.electronAPI.onApiSettingsUpdated((settings) => {
  console.log('API settings updated:', settings);
  // Could refresh any UI that depends on these settings
});

// Add this to your DOMContentLoaded event listener in renderer.js:
document.addEventListener('DOMContentLoaded', () => {
  // Create timestamp element
  const timestampElement = document.createElement('div');
  timestampElement.id = 'timestamp';
  timestampElement.className = 'timestamp';
  timestampElement.textContent = getReadableTimestamp();
  
  // Find the header-center div and add the timestamp alongside the h1
  const headerCenter = document.querySelector('.header-center');
  if (headerCenter) {
    // Add timestamp after the h1
    headerCenter.appendChild(timestampElement);
  }

  // Update the timestamp once per minute
  setInterval(updateTimestamp, 60000);  

  // Rest of your existing initialization code
  loadProjectInfo();
  loadAiTools();
  loadNonAiTools();
});

// Add this to listen for when a tool run finishes and the window gains focus again
// This updates the timestamp when returning to the main window
window.addEventListener('focus', updateTimestamp);

// Also listen for tool dialog closing events from the main process
// Add this where you have other electronAPI event listeners:
if (window.electronAPI && window.electronAPI.onToolDialogClosed) {
  window.electronAPI.onToolDialogClosed(() => {
    updateTimestamp();
  });
}

============================================================
FILE: renderer/app.js
SIZE: 3589 bytes
LANGUAGE: JS
============================================================

// renderer/app.js
import React, { useState, useEffect } from 'react';
import { 
  AppBar, Toolbar, Typography, Button, Card, 
  CardContent, Select, MenuItem, TextField
} from '@material-ui/core';

function App() {
  const [tools, setTools] = useState([]);
  const [selectedTool, setSelectedTool] = useState('');
  const [projectInfo, setProjectInfo] = useState({});
  
  useEffect(() => {
    // Load tools and project info on component mount
    async function loadData() {
      const toolsList = await window.electronAPI.getTools();
      setTools(toolsList);
      
      const projectData = await window.electronAPI.getProjectInfo();
      setProjectInfo(projectData);
      
      if (toolsList.length > 0) {
        setSelectedTool(toolsList[0].name);
      }
    }
    
    loadData();
  }, []);
  
  const handleSelectProject = async () => {
    const projects = await window.electronAPI.selectProjectDialog();
    // Show modal dialog with projects list...
  };
  
  const handleRunTool = async () => {
    // Open tool setup dialog...
    // Then run the tool with selected options
  };
  
  return (
    <div className="app">
      <AppBar position="static">
        <Toolbar>
          <Typography variant="h6">Writer's Toolkit</Typography>
          <div style={{ flexGrow: 1 }} />
          <Button color="inherit">API Settings</Button>
          <Button color="inherit">Quit</Button>
        </Toolbar>
      </AppBar>
      
      <div className="content">
        <Card className="project-card">
          <CardContent>
            <div className="project-header">
              <div>
                <Typography variant="h6">Current Project</Typography>
                {projectInfo.current_project ? (
                  <>
                    <Typography>{projectInfo.current_project}</Typography>
                    <Typography variant="caption" color="textSecondary">
                      Project Path: {projectInfo.current_project_path}
                    </Typography>
                  </>
                ) : (
                  <Typography color="error">
                    No project selected
                  </Typography>
                )}
              </div>
              <Button 
                variant="contained" 
                color="primary"
                onClick={handleSelectProject}
              >
                Select Project
              </Button>
            </div>
          </CardContent>
        </Card>
        
        <Card className="tools-card">
          <CardContent>
            <Typography variant="h6">Select a tool to run:</Typography>
            
            <Select
              fullWidth
              value={selectedTool}
              onChange={(e) => setSelectedTool(e.target.value)}
            >
              {tools.map(tool => (
                <MenuItem key={tool.name} value={tool.name}>
                  {tool.title}
                </MenuItem>
              ))}
            </Select>
            
            {/* Tool description */}
            <Typography variant="caption" color="textSecondary" style={{ marginTop: 16 }}>
              {tools.find(t => t.name === selectedTool)?.description || ''}
            </Typography>
            
            <div className="action-buttons">
              <Button 
                variant="contained" 
                color="primary"
                onClick={handleRunTool}
              >
                Setup & Run
              </Button>
            </div>
          </CardContent>
        </Card>
      </div>
    </div>
  );
}

export default App;


============================================================
FILE: renderer/editor/renderer.js
SIZE: 12107 bytes
LANGUAGE: JS
============================================================

// DOM Elements
const editor = document.getElementById('editor');
const positionDisplay = document.getElementById('position');
const statsDisplay = document.getElementById('statistics');
const currentFileDisplay = document.getElementById('currentFile');
const newButton = document.getElementById('btnNew');
const openButton = document.getElementById('btnOpen');
const saveButton = document.getElementById('btnSave');
const saveAsButton = document.getElementById('btnSaveAs');
const fontSizeSelect = document.getElementById('fontSize');
const wordWrapSelect = document.getElementById('wordWrap');
const themeToggleBtn = document.getElementById('theme-toggle');
const sunIcon = document.getElementById('sun-icon');
const moonIcon = document.getElementById('moon-icon');
const quitButton = document.getElementById('quit-button');
const findInput = document.getElementById('find-input');
const findNextBtn = document.getElementById('find-next-btn');
const clearSearchBtn = document.getElementById('clear-search-btn');
const body = document.body;

// Track the current file
let currentFilePath = null;
let documentChanged = false;

// Track theme state (initially dark)
let isDarkMode = true;

// Keep track of the current find state
let currentFindIndex = -1;
let findMatches = [];

// Initialize editor
function initEditor() {
  // Set up tab key behavior
  editor.addEventListener('keydown', function(e) {
    if (e.key === 'Tab') {
      e.preventDefault();
      
      // Insert a tab at cursor position
      const start = this.selectionStart;
      const end = this.selectionEnd;
      
      this.value = this.value.substring(0, start) + 
                    "  " + 
                    this.value.substring(end);
      
      // Put cursor after the inserted tab
      this.selectionStart = this.selectionEnd = start + 2;
      
      documentChanged = true;
    }
  });
  
  // Update the cursor position and stats display
  editor.addEventListener('keyup', updatePositionAndStats);
  editor.addEventListener('click', updatePositionAndStats);
  editor.addEventListener('input', () => {
    documentChanged = true;
    updatePositionAndStats();
  });
  
  // Initial update
  updatePositionAndStats();
  
  // Set up event listeners for file operations
  setupEventListeners();
}

// Update the position and statistics displays
function updatePositionAndStats() {
  const text = editor.value;
  
  // Get cursor position
  const cursorPos = editor.selectionStart;
  
  // Calculate line and column
  const lines = text.substr(0, cursorPos).split('\n');
  const lineNumber = lines.length;
  const columnNumber = lines[lines.length - 1].length + 1;
  
  // Update displays with formatted numbers
  positionDisplay.textContent = `Line: ${lineNumber}, Column: ${columnNumber}`;
  
  // Show search results count if there are matches, otherwise just show character/word count
  if (findMatches.length > 0 && currentFindIndex >= 0) {
    statsDisplay.textContent = `Found: ${currentFindIndex + 1}/${findMatches.length} - Words: ${countWords(text).toLocaleString()} & Characters: ${text.length.toLocaleString()}`;
  } else {
    statsDisplay.textContent = `Words: ${countWords(text).toLocaleString()} & Characters: ${text.length.toLocaleString()}`;
  }
}

// Count words in text
function countWords(text) {
  return text.trim().split(/\s+/).filter(Boolean).length;
}

// Set up event listeners
function setupEventListeners() {
  // Theme toggle
  themeToggleBtn.addEventListener('click', () => {
    isDarkMode = !isDarkMode;
    
    if (isDarkMode) {
      body.classList.remove('light-mode');
      body.classList.add('dark-mode');
    } else {
      body.classList.remove('dark-mode');
      body.classList.add('light-mode');
    }
    
    // Update icons when theme changes
    updateThemeIcons();
  });
  
  // Button handlers
  newButton.addEventListener('click', newFile);
  openButton.addEventListener('click', openFile);
  saveButton.addEventListener('click', saveFile);
  saveAsButton.addEventListener('click', saveFileAs);
  
  // Quit button handler
  quitButton.addEventListener('click', quitApp);
  
  // Font size changes
  fontSizeSelect.addEventListener('change', function() {
    editor.style.fontSize = `${this.value}px`;
  });
  
  // Word wrap toggle
  wordWrapSelect.addEventListener('change', function() {
    const isWrapped = this.value === 'on';
    editor.style.whiteSpace = isWrapped ? 'pre-wrap' : 'pre';
  });
  
  // IPC events from main process
  if (window.api) {
    window.api.onFileNew && window.api.onFileNew(newFile);
    window.api.onFileSaveRequest && window.api.onFileSaveRequest(saveFile);
    window.api.onFileSaveAsRequest && window.api.onFileSaveAsRequest(saveFileAs);
    window.api.onFileOpened && window.api.onFileOpened(handleFileOpened);
  }
  
  // Find functionality
  setupFindEventListeners();
  
  // Window close handling
  window.addEventListener('beforeunload', (e) => {
    if (documentChanged) {
      // Standard method to ask user about unsaved changes
      e.returnValue = false;
      
      // Custom dialog would be handled in main process in a real app
      if (confirm('You have unsaved changes. Do you want to save them before closing?')) {
        saveFile();
      }
    }
  });
}

// Update icon visibility based on the current theme
function updateThemeIcons() {
  if (isDarkMode) {
    sunIcon.style.display = 'block';
    moonIcon.style.display = 'none';
  } else {
    sunIcon.style.display = 'none';
    moonIcon.style.display = 'block';
  }
}

function quitApp() {
  // Check for unsaved changes
  if (documentChanged) {
    const confirmQuit = confirm('You have unsaved changes. Close anyway?');
    if (!confirmQuit) {
      return; // User canceled, so don't quit
    }
    documentChanged = false; // Reset flag
  }

  // Check if we're in standalone mode based on environment variable
  // When launched from the main app, this will be undefined or false
  const isStandalone = window.api && window.api.isStandaloneMode === true;
  
  console.log(`Quitting editor in ${isStandalone ? 'STANDALONE' : 'INTEGRATED'} mode`);
  
  if (isStandalone) {
    // In standalone mode, use API to quit the application
    if (window.api && typeof window.api.quitApp === 'function') {
      console.log('Sending app-quit signal');
      window.api.quitApp();
      
      // Set a fallback timeout in case quitting takes too long
      setTimeout(() => {
        console.log('Regular quit failed, forcing exit');
        if (window.api && typeof window.api.forceQuit === 'function') {
          window.api.forceQuit();
        }
      }, 500);
    }
  } else {
    // In integrated mode, just close the window
    console.log('Closing window only (integrated mode)');
    window.close();
  }
}

// File operations
async function newFile() {
  if (documentChanged) {
    if (!confirm('You have unsaved changes. Create a new file anyway?')) {
      return;
    }
  }
  
  editor.value = '';
  currentFilePath = null;
  currentFileDisplay.textContent = 'No file opened';
  documentChanged = false;
  updatePositionAndStats();
}

async function openFile() {
  if (documentChanged) {
    if (!confirm('You have unsaved changes. Open a different file anyway?')) {
      return;
    }
  }
  
  if (window.api && window.api.openFileDialog) {
    await window.api.openFileDialog();
    // The response is handled by the onFileOpened event
  }
}

async function saveFile() {
  if (!currentFilePath) {
    return saveFileAs();
  }
  
  const content = editor.value;
  
  if (window.api && window.api.saveFile) {
    const result = await window.api.saveFile({
      filePath: currentFilePath,
      content,
      saveAs: false
    });
    
    if (result && result.success) {
      documentChanged = false;
      // Show saved notification briefly
      showNotification('File saved successfully');
    }
  }
}

async function saveFileAs() {
  const content = editor.value;
  
  if (window.api && window.api.saveFile) {
    const result = await window.api.saveFile({
      filePath: currentFilePath,
      content,
      saveAs: true
    });
    
    if (result && result.success) {
      currentFilePath = result.filePath;
      currentFileDisplay.textContent = currentFilePath;
      documentChanged = false;
      // Show saved notification briefly
      showNotification('File saved successfully');
    }
  }
}

// Show a brief notification
function showNotification(message, duration = 2000) {
  // Create notification element if it doesn't exist
  let notification = document.getElementById('notification');
  
  if (!notification) {
    notification = document.createElement('div');
    notification.id = 'notification';
    notification.className = 'notification';
    document.body.appendChild(notification);
  }
  
  // Set message and show
  notification.textContent = message;
  notification.style.opacity = '1';
  
  // Hide after duration
  setTimeout(() => {
    notification.style.opacity = '0';
  }, duration);
}

// Handle opened file data from main process
function handleFileOpened(data) {
  if (data && data.filePath && data.content !== undefined) {
    currentFilePath = data.filePath;
    editor.value = data.content;
    currentFileDisplay.textContent = currentFilePath;
    documentChanged = false;
    updatePositionAndStats();
  }
}

// Find functionality
function setupFindEventListeners() {
  // Find button click
  findNextBtn.addEventListener('click', performFind);
  
  // Clear search button click
  clearSearchBtn.addEventListener('click', clearSearch);
  
  // Enter key in find input
  findInput.addEventListener('keydown', function(e) {
    // Prevent editor from receiving these keystrokes
    e.stopPropagation();
    
    if (e.key === 'Enter') {
      e.preventDefault();
      performFind();
    }
  });
  
  // Prevent other keyboard events from reaching the editor
  findInput.addEventListener('keyup', function(e) {
    e.stopPropagation();
  });
  
  findInput.addEventListener('keypress', function(e) {
    e.stopPropagation();
  });
}

// Clear search functionality
function clearSearch() {
  // Clear the search input
  findInput.value = '';
  
  // Reset search variables
  currentFindIndex = -1;
  findMatches = [];
  
  // Reset any highlighting in the editor
  // (This assumes you might have applied highlighting to search matches)
  
  // Reset the statistics display to remove the "Found: x/xx" text
  updatePositionAndStats();
  
  // Give focus back to the editor
  editor.focus();
}

// Perform the find operation
function performFind() {
  const findText = findInput.value.trim();
  
  // Don't search for empty strings
  if (!findText) {
    currentFindIndex = -1;
    findMatches = [];
    // Reset statistics display
    updatePositionAndStats();
    return;
  }
  
  const content = editor.value;
  findMatches = [];
  
  // Find all occurrences of the search text
  let position = content.indexOf(findText, 0);
  
  while (position !== -1) {
    findMatches.push({
      start: position,
      end: position + findText.length
    });
    
    // Find next occurrence
    position = content.indexOf(findText, position + 1);
  }
  
  // If no matches, reset
  if (findMatches.length === 0) {
    currentFindIndex = -1;
    alert('No matches found');
    return;
  }
  
  // Move to the next match or first if we're at the end
  if (currentFindIndex < 0 || currentFindIndex >= findMatches.length - 1) {
    currentFindIndex = 0;
  } else {
    currentFindIndex++;
  }
  
  // Highlight the current match
  highlightCurrentMatch();
}

// Highlight the current match
function highlightCurrentMatch() {
  if (currentFindIndex < 0 || findMatches.length === 0) return;
  
  const match = findMatches[currentFindIndex];
  
  // Select the text in the editor
  editor.focus();
  editor.setSelectionRange(match.start, match.end);
  
  // Scroll to make the match visible
  editor.blur();
  editor.focus();
  
  // Update status to show match position
  updatePositionAndStats();
}

// Initialize the editor when the document is ready
document.addEventListener('DOMContentLoaded', initEditor);


============================================================
FILE: rhythm-analyzer.js
SIZE: 17877 bytes
LANGUAGE: JS
============================================================

// rhythm-analyzer.js
const BaseTool = require('./base-tool');
const path = require('path');
const fileCache = require('./file-cache');
const appState = require('./state.js');
const fs = require('fs/promises');

/**
 * Rhythm Analyzer Tool
 * Analyzes manuscript for rhythm and flow of prose using the Claude API.
 * Measures sentence length variations, detects monotonous patterns,
 * and highlights passages where the sound doesn't match the intended mood,
 * following Ursula K. Le Guin's writing advice on prose rhythm.
 */
class RhythmAnalyzer extends BaseTool {
  /**
   * Constructor
   * @param {Object} GeminiAPIService - Claude API service
   * @param {Object} config - Tool configuration
   */
  constructor(GeminiAPIService, config = {}) {
    super('rhythm_analyzer', config);
    this.GeminiAPIService = GeminiAPIService;
  }

  /**
   * Execute the tool
   * @param {Object} options - Tool options
   * @returns {Promise<Object>} - Execution result
   */
  async execute(options) {
    console.log('Executing Rhythm Analyzer with options:', options);
    
    // Extract options
    let manuscriptFile = options.manuscript_file;
    const analysisLevel = options.analysis_level;
    const sceneTypes = options.scene_types;
    const rhythmSensitivity = options.rhythm_sensitivity;
    const saveDir = options.save_dir || appState.CURRENT_PROJECT_PATH;
    
    if (!saveDir) {
      const errorMsg = 'Error: No save directory specified and no current project selected.\n' +
                      'Please select a project or specify a save directory.';
      this.emitOutput(errorMsg);
      throw new Error('No save directory available');
    }

    // Ensure file paths are absolute
    manuscriptFile = this.ensureAbsolutePath(manuscriptFile, saveDir);
    
    // Log the full paths for debugging
    console.log('Using full paths:');
    console.log(`Manuscript: ${manuscriptFile}`);

    const outputFiles = [];
    
    try {
      // Read the input files
      this.emitOutput(`Reading files...\n`);

      // Read the manuscript file
      this.emitOutput(`Reading manuscript file: ${manuscriptFile}\n`);
      const manuscriptContent = await this.readInputFile(manuscriptFile);
      
      // Create the prompt
      const prompt = this.createRhythmAnalysisPrompt(manuscriptContent, analysisLevel, sceneTypes, rhythmSensitivity);

      // Count tokens in the prompt
      this.emitOutput(`Counting tokens in prompt...\n`);
      const promptTokens = await this.GeminiAPIService.countTokens(prompt);

      // Call the shared token budget calculator
      const tokenBudgets = this.GeminiAPIService.calculateTokenBudgets(promptTokens);

      // Handle logging based on the returned values
      this.emitOutput(`\nToken stats:\n`);
      this.emitOutput(`Max AI model context window: [${tokenBudgets.contextWindow}] tokens\n`);
      this.emitOutput(`Input prompt tokens: [${tokenBudgets.promptTokens}] ...\n`);
      this.emitOutput(`                     = manuscript + prompt instructions\n`);
      this.emitOutput(`Available tokens: [${tokenBudgets.availableTokens}]  = ${tokenBudgets.contextWindow} - ${tokenBudgets.promptTokens} = context_window - prompt\n`);
      this.emitOutput(`Desired output tokens: [${tokenBudgets.desiredOutputTokens}]\n`);
      this.emitOutput(`AI model thinking budget: [${tokenBudgets.thinkingBudget}] tokens\n`);
      this.emitOutput(`Max output tokens: [${tokenBudgets.maxTokens}] tokens\n`);

      // Check for special conditions
      if (tokenBudgets.capThinkingBudget) {
        this.emitOutput(`Warning: thinking budget is larger than 32K, set to 32K.\n`);
      }

      // Check if the prompt is too large
      if (tokenBudgets.isPromptTooLarge) {
        this.emitOutput(`Error: prompt is too large to have a ${tokenBudgets.configuredThinkingBudget} thinking budget!\n`);
        this.emitOutput(`Run aborted!\n`);
        throw new Error(`Prompt is too large for ${tokenBudgets.configuredThinkingBudget} thinking budget - run aborted`);
      }
      
      // Call Claude API with streaming
      this.emitOutput(`>>> Sending request to Claude API (streaming)...\n`);

      // Add a message about waiting
      this.emitOutput(`****************************************************************************\n`);
      this.emitOutput(`*  Analyzing prose rhythm and flow in your manuscript...                    \n`);
      this.emitOutput(`*  This process typically takes several minutes.                           \n`);
      this.emitOutput(`*                                                                          \n`);
      this.emitOutput(`*  It's recommended to keep this window the sole 'focus'                   \n`);
      this.emitOutput(`*  and to avoid browsing online or running other apps, as these API        \n`);
      this.emitOutput(`*  network connections are often flakey, like delicate echoes of whispers. \n`);
      this.emitOutput(`*                                                                          \n`);
      this.emitOutput(`*  So breathe, remove eye glasses, stretch, relax, and be like water 🥋 🧘🏽‍♀️\n`);
      this.emitOutput(`****************************************************************************\n\n`);
      
      const startTime = Date.now();
      let fullResponse = "";
      let thinkingContent = "";
      
      // Create system prompt to avoid markdown
      const systemPrompt = "CRITICAL INSTRUCTION: NO Markdown formatting of ANY kind. Never use headers, bullets, or any formatting symbols. Plain text only with standard punctuation.";

      // Use the calculated values in the API call - FIXED to match dangling-modifier-checker.js exactly
      try {
        await this.GeminiAPIService.streamWithThinking(
          prompt,
          {
            system: systemPrompt,
            max_tokens: tokenBudgets.maxTokens,
            thinking: {
              type: "enabled",
              budget_tokens: tokenBudgets.thinkingBudget
            }
          },
          // Callback for thinking content
          (thinkingDelta) => {
            thinkingContent += thinkingDelta;
          },
          // Callback for response text
          (textDelta) => {
            fullResponse += textDelta;
          }
        );
      } catch (error) {
        this.emitOutput(`\nAPI Error: ${error.message}\n`);
        throw error;
      }

      const elapsed = (Date.now() - startTime) / 1000;
      const minutes = Math.floor(elapsed / 60);
      const seconds = elapsed % 60;
      
      this.emitOutput(`\nCompleted in ${minutes}m ${seconds.toFixed(2)}s.\n`);
      
      // Count words in response
      const wordCount = this.countWords(fullResponse);
      this.emitOutput(`Report has approximately ${wordCount} words.\n`);
      
      // Count tokens in response
      const responseTokens = await this.GeminiAPIService.countTokens(fullResponse);
      this.emitOutput(`Response token count: ${responseTokens}\n`);

      // Remove any markdown formatting
      fullResponse = this.removeMarkdown(fullResponse);

      // Save the report
      const outputFile = await this.saveReport(
        analysisLevel,
        sceneTypes,
        rhythmSensitivity,
        fullResponse,
        thinkingContent,
        promptTokens,
        responseTokens,
        saveDir
      );
      
      // Add all output files to the result
      outputFiles.push(...outputFile);
      
      // Add files to the cache
      const toolName = 'rhythm_analyzer';
      outputFiles.forEach(file => {
        fileCache.addFile(toolName, file);
      });
      
      // Return the result
      return {
        success: true,
        outputFiles,
        stats: {
          wordCount,
          tokenCount: responseTokens,
          elapsedTime: `${minutes}m ${seconds.toFixed(2)}s`,
          analysisLevel,
          sceneTypes,
          rhythmSensitivity
        }
      };
    } catch (error) {
      console.error('Error in RhythmAnalyzer:', error);
      this.emitOutput(`\nError: ${error.message}\n`);
      throw error;
    }
  }
  
  /**
   * Create rhythm analysis prompt
   * @param {string} manuscriptContent - Manuscript content
   * @param {string} analysisLevel - Analysis level (basic, standard, detailed)
   * @param {Array|string} sceneTypes - Types of scenes to analyze
   * @param {string} rhythmSensitivity - Sensitivity level (low, medium, high)
   * @returns {string} - Prompt for Claude API
   */
  createRhythmAnalysisPrompt(manuscriptContent, analysisLevel = "standard", sceneTypes = ["action", "dialogue", "description", "exposition"], rhythmSensitivity = "medium") {
    // Build instruction section based on analysis level
    const basicInstructions = `
1. SENTENCE RHYTHM OVERVIEW:
   - Analyze overall patterns of sentence length and structure in the manuscript
   - Identify the general rhythm signature of the prose
   - Highlight any distinctive cadences in the writing

2. RHYTHM OPTIMIZATION OPPORTUNITIES:
   - Identify passages with monotonous sentence patterns
   - Point out sections where rhythm doesn't match content (e.g., short choppy sentences for peaceful scenes)
   - Suggest specific improvements with examples

3. RECOMMENDATIONS:
   - Provide practical suggestions for varying sentence structure and rhythm
   - Suggest specific changes to improve flow in problematic passages
   - Recommend rhythm adjustments to match content mood and pacing
`;

    const standardInstructions = basicInstructions + `
4. PASSAGE-TYPE RHYTHM ANALYSIS:
   - Analyze rhythm patterns in different passage types (action, dialogue, description, exposition)
   - Assess the effectiveness of rhythm in each type
   - Suggest rhythm improvements specific to each passage type

5. SOUND PATTERN ASSESSMENT:
   - Identify notable sound patterns (alliteration, assonance, consonance, etc.)
   - Evaluate their effect on the prose rhythm
   - Note any jarring or distracting sound combinations
   - Suggest ways to enhance or moderate sound effects
`;

    const detailedInstructions = standardInstructions + `
6. PARAGRAPH-LEVEL RHYTHM ANALYSIS:
   - Assess paragraph lengths and their variation throughout the manuscript
   - Analyze how paragraph breaks contribute to or detract from rhythm
   - Suggest paragraph restructuring where it might improve flow

7. MOOD-RHYTHM CORRELATION:
   - Analyze how well rhythm patterns match emotional tone in key scenes
   - Identify mismatches between rhythm and intended mood
   - Suggest specific adjustments to align rhythm with emotional content

8. ADVANCED RHYTHM STRATEGIES:
   - Provide examples of rhythm techniques from master prose stylists
   - Suggest experimental rhythm approaches for key passages
   - Offer sentence reconstruction options that maintain meaning while enhancing rhythm
`;

    // Choose the appropriate instruction level
    let instructionSet;
    if (analysisLevel === "basic") {
      instructionSet = basicInstructions;
    } else if (analysisLevel === "detailed") {
      instructionSet = detailedInstructions;
    } else {  // standard
      instructionSet = standardInstructions;
    }

    // Construct the scene types emphasis
    let sceneTypesText;
    if (Array.isArray(sceneTypes)) {
      sceneTypesText = sceneTypes.join(", ");
    } else {
      // Handle the case where sceneTypes might be a string
      sceneTypesText = String(sceneTypes);
    }

    // Adjust instructions based on rhythm sensitivity
    const sensitivityInstructions = {
      "low": "Focus only on major rhythm issues that significantly impact readability or comprehension.",
      "medium": "Identify moderate to major rhythm issues, balancing attention to craft with respect for the author's style.",
      "high": "Perform a detailed analysis of subtle rhythm patterns and nuances, noting even minor opportunities for improvement."
    };
    
    const sensitivityText = sensitivityInstructions[rhythmSensitivity] || sensitivityInstructions["medium"];

    // Construct the full prompt
    const instructions = `IMPORTANT: NO Markdown formatting

You are an expert literary editor specializing in prose rhythm and the musicality of writing. Your task is to analyze the provided manuscript for rhythm and flow, focusing particularly on scene types: ${sceneTypesText}.

Follow Ursula K. Le Guin's principle from "Steering the Craft" that "rhythm is what keeps the song going, the horse galloping, the story moving." Analyze how sentence length, structure, and sound patterns create a rhythmic flow that either enhances or detracts from the narrative.

Rhythm sensitivity level: ${rhythmSensitivity}. ${sensitivityText}

Pay special attention to:
1. Sentence length variation and its effect on pacing and mood
2. Monotonous patterns that might create reader fatigue
3. Mismatches between rhythm and content (e.g., long flowing sentences for urgent action)
4. Sound patterns that enhance or detract from the reading experience
5. Paragraph structure and how it contributes to overall rhythm

For each issue you identify, provide:
- The original passage
- What makes the rhythm less effective
- A specific recommendation for improvement

Create a comprehensive rhythm analysis with these sections:
${instructionSet}

Format your analysis as a clear, organized report with sections and subsections. Use plain text formatting only (NO Markdown). Use numbered or bulleted lists where appropriate for clarity.

Be specific in your examples and suggestions, showing how prose rhythm can be improved without changing the author's voice or intention. Focus on practical changes that will make the writing more engaging, effective, and musical.
`;

    // Combine all sections
    return `=== MANUSCRIPT ===\n${manuscriptContent}\n=== END MANUSCRIPT ===\n\n${instructions}`;
  }

  /**
   * Count words in text
   * @param {string} text - Text to count words in
   * @returns {number} - Word count
   */
  countWords(text) {
    return text.split(/\s+/).filter(word => word.length > 0).length;
  }
  
  /**
   * Ensure file path is absolute
   * @param {string} filePath - File path (may be relative or absolute)
   * @param {string} basePath - Base path to prepend for relative paths
   * @returns {string} - Absolute file path
   */
  ensureAbsolutePath(filePath, basePath) {
    if (!filePath) return filePath;
    
    // Check if the path is already absolute
    if (path.isAbsolute(filePath)) {
      return filePath;
    }
    
    // Make the path absolute by joining with the base path
    return path.join(basePath, filePath);
  }
  
  /**
   * Save report and thinking content to files
   * @param {string} analysisLevel - Analysis level (basic, standard, detailed)
   * @param {Array|string} sceneTypes - Types of scenes analyzed
   * @param {string} rhythmSensitivity - Sensitivity level (low, medium, high)
   * @param {string} content - Response content
   * @param {string} thinking - Thinking content
   * @param {number} promptTokens - Prompt token count
   * @param {number} responseTokens - Response token count
   * @param {string} saveDir - Directory to save to
   * @returns {Promise<string[]>} - Array of paths to saved files
   */
  async saveReport(
    analysisLevel,
    sceneTypes,
    rhythmSensitivity,
    content,
    thinking,
    promptTokens,
    responseTokens,
    saveDir
  ) {
    try {
      const formatter = new Intl.DateTimeFormat('en-US', {
        weekday: 'long',
        month: 'long',
        day: 'numeric',
        year: 'numeric',
        hour: 'numeric',
        minute: '2-digit',
        hour12: true
      });
      const dateTimeStr = formatter.format(new Date());

      // Create timestamp for filename
      const timestamp = new Date().toISOString().replace(/[-:.]/g, '').substring(0, 15);
      
      // Create descriptive filename
      const level = analysisLevel !== 'standard' ? `_${analysisLevel}` : '';
      const baseFilename = `rhythm_analysis${level}_${timestamp}`;
      
      // Array to collect all saved file paths
      const savedFilePaths = [];
      
      // Format sceneTypes for stats
      const sceneTypesStr = Array.isArray(sceneTypes) ? sceneTypes.join(', ') : sceneTypes;
      
      // Create stats for thinking file
      const stats = `
Details:  ${dateTimeStr}
Analysis type: Prose rhythm analysis
Analysis level: ${analysisLevel}
Scene types: ${sceneTypesStr}
Rhythm sensitivity: ${rhythmSensitivity}
Max request timeout: ${this.config.request_timeout} seconds
Max AI model context window: ${this.config.context_window} tokens
AI model thinking budget: ${this.config.thinking_budget_tokens} tokens
Desired output tokens: ${this.config.desired_output_tokens} tokens

Input tokens: ${promptTokens}
Output tokens: ${responseTokens}
`;
      
      // Save full response
      const reportFilename = `${baseFilename}.txt`;
      const reportPath = path.join(saveDir, reportFilename);
      await this.writeOutputFile(content, saveDir, reportFilename);
      savedFilePaths.push(reportPath);
      
      // Save thinking content if available and not skipped
      if (thinking) {
        const thinkingFilename = `${baseFilename}_thinking.txt`;
        const thinkingPath = path.join(saveDir, thinkingFilename);
        const thinkingContent = `=== PROSE RHYTHM ANALYSIS ===

=== AI'S THINKING PROCESS ===

${thinking}

=== END AI'S THINKING PROCESS ===
${stats}`;
        
        await this.writeOutputFile(thinkingContent, saveDir, thinkingFilename);
        this.emitOutput(`AI thinking saved to: ${thinkingPath}\n`);
        savedFilePaths.push(thinkingPath);
      }

      this.emitOutput(`Report saved to: ${reportPath}\n`);
      return savedFilePaths;
    } catch (error) {
      console.error(`Error saving report:`, error);
      this.emitOutput(`Error saving report: ${error.message}\n`);
      throw error;
    }
  }
}

module.exports = RhythmAnalyzer;


============================================================
FILE: sdk-with-headers.js
SIZE: 5304 bytes
LANGUAGE: JS
============================================================

// Load environment variables from ~/.env
require('dotenv').config({ path: require('os').homedir() + '/.env' });
const anthropic = require('@anthropic-ai/sdk');
const fs = require('fs/promises');
const path = require('path');
const os = require('os');

// Usage: node sdk-with-headers.js <path-to-manuscript.txt>
const manuscriptPath = process.argv[2];
if (!manuscriptPath) {
  console.error('Error: Please provide the path to your manuscript .txt file.');
  console.error('Usage: node sdk-with-headers.js path/to/book.txt');
  process.exit(1);
}

// Ensure API key is set
const apiKey = process.env.ANTHROPIC_API_KEY;
if (!apiKey) {
  console.error('Error: `ANTHROPIC_API_KEY` environment variable not found.');
  process.exit(1);
}

// Instantiate Anthropic client with custom timeout and no retries
const client = new anthropic.Anthropic({
  apiKey: apiKey,
  timeout: 300 * 1000,   // 300 seconds in milliseconds
  maxRetries: 0,
});

// Read the manuscript text from disk
async function loadManuscript(filePath) {
  try {
    console.log(`Reading manuscript from: ${path.resolve(filePath)}`);
    return await fs.readFile(path.resolve(filePath), 'utf-8');
  } catch (err) {
    console.error(`Failed to read manuscript at ${filePath}:`, err.message);
    process.exit(1);
  }
}

/**
 * Use the SDK to analyze the manuscript and access response headers
 */
async function analyzeWith(num, bookTextBlock, userQuery) {
  console.log('Sending request to Claude API using SDK...');
  console.log(`Query: "${userQuery}"`);
  
  try {
    // Use beta.messages.create with withResponse() to get both data and headers
    console.log('Using beta.messages.create API with withResponse()...');
    
    const systemMessages = [
      bookTextBlock
    ];
    
    // Make the non-streaming request using the SDK, but get the raw response too
    const { data: response, response: rawResponse } = await client.beta.messages.create({
      model: 'claude-3-7-sonnet-20250219',
      max_tokens: 50000,
      system: systemMessages,
      messages: [{ role: 'user', content: userQuery }],
      thinking: { type: 'enabled', budget_tokens: 32000 },
      betas: ['output-128k-2025-02-19']
    }).withResponse();
    
    // Display all headers from the raw response
    console.log('\n=== ALL RESPONSE HEADERS ===');
    
    // Headers is a Map-like object, get all entries and sort them
    const headerEntries = Array.from(rawResponse.headers.entries()).sort();
    
    // Print each header and its value
    for (const [name, value] of headerEntries) {
      console.log(`${name}: ${value}`);
    }
    console.log('=== END RESPONSE HEADERS ===\n');
    
    // Display usage information if available
    if (response.usage) {
      console.log('\n=== USAGE METRICS ===');
      console.log('input_tokens:', response.usage.input_tokens || 0);
      console.log('output_tokens:', response.usage.output_tokens || 0);
      
      // Display cache metrics if available
      if (response.usage.cache_creation_input_tokens !== undefined ||
          response.usage.cache_read_input_tokens !== undefined) {
        console.log('cache_creation_input_tokens:', response.usage.cache_creation_input_tokens || 0);
        console.log('cache_read_input_tokens:', response.usage.cache_read_input_tokens || 0);
      }
      console.log('=== END USAGE METRICS ===\n');
    }
    
    // Display the response content
    console.log(`\n--- ${num}. CLAUDE RESPONSE ---\n`);
    
    // Extract and display the text content
    if (response.content) {
      for (const block of response.content) {
        if (block.type === 'text') {
          console.log(block.text);
        } else if (block.type === 'thinking') {
          // Format and display thinking content if present
          const thinkingPreview = block.thinking ? 
            block.thinking.substring(0, 100) + (block.thinking.length > 100 ? '...' : '') : 
            '[No thinking content]';
          console.log(`[Thinking: ${thinkingPreview}]`);
        } else {
          console.log(`[Non-text content of type: ${block.type}]`);
        }
      }
    }
    
    console.log('\n\n--- END OF RESPONSE ---');
    return response;
  } catch (error) {
    console.error('Error during API call:', error);
    console.error('Error details:', error.message);
  }
}

// Main IIFE
;(async () => {
  try {
    console.log('Starting manuscript analysis...');
    const manuscriptContent = await loadManuscript(manuscriptPath);
    console.log(`Manuscript size: ${manuscriptContent.length} characters`);
    
    const BOOK_TEXT = { 
      type: 'text', 
      text: `=== MANUSCRIPT: A Darker Roast ===\n${manuscriptContent}\n=== END MANUSCRIPT: A Darker Roast ===`,
      cache_control: { type: 'ephemeral' } 
    };
    
    // Use the SDK for the manuscript analysis and get headers
    await analyzeWith(
      "1",
      BOOK_TEXT,
      'What is the last word in my manuscript.'
    );
    console.log('Analysis 1 complete.');
    
    await analyzeWith(
      "2",
      BOOK_TEXT,
      'You are an AI assistant specializing in thematic analysis of fiction. ' +
      'List the names of all of the characters in my manuscript.'
    );
    console.log('Analysis 2 complete.');
    
  } catch (error) {
    console.error('Unexpected error:', error);
  }
})();

============================================================
FILE: state.js
SIZE: 4321 bytes
LANGUAGE: JS
============================================================

// state.js
const path = require('path');
const os = require('os');

// Basic logging setup that works even if logToFile isn't defined in this context
function safeLog(message) {
  // Log to console first (works in development)
  console.log(message);
  
  // Try to log to file if the function exists in global scope (from main.js)
  if (typeof global.logToFile === 'function') {
    global.logToFile(`[state.js] ${message}`);
  } else {
    // Fallback file logging if needed
    try {
      const fs = require('fs');
      const path = require('path');
      const os = require('os');
      const logPath = path.join(os.homedir(), 'writers-toolkit-debug.log');
      const timestamp = new Date().toISOString();
      const logLine = `${timestamp}: [state.js] ${message}\n`;
      fs.appendFileSync(logPath, logLine);
    } catch (e) {
      // Can't do anything if this fails
    }
  }
}

// Log module loading started
safeLog('Module loading started');

// Create a placeholder for Store that will be filled in later
let Store = null;

// Create the AppState class
class AppState {
  constructor() {
    // Application paths
    this.APP_ROOT = path.resolve(path.join(__dirname, '..'));
    
    // File system paths
    this.PROJECTS_DIR = path.join(os.homedir(), 'writing');
    this.DEFAULT_SAVE_DIR = this.PROJECTS_DIR;
    
    // Project tracking
    this.CURRENT_PROJECT = null;
    this.CURRENT_PROJECT_PATH = null;
    
    // Tool selection and execution state
    this.SELECTED_TOOL = null;
    this.IS_RUNNING = false;
    this.OPTION_VALUES = {};
    this.FULL_COMMAND = null;
    
    // Store will be initialized in initialize()
    this.store = null;
    this.initialized = false;
    
    // Default Claude API settings
    this.settings_claude_api_configuration = {
      max_retries: 1,
      request_timeout: 300,
      context_window: 200000,
      thinking_budget_tokens: 32000,
      betas_max_tokens: 128000,
      desired_output_tokens: 12000
    };
  }
  
  // Async initialization method
  async initialize() {
    if (this.initialized) return;
    
    try {
      if (!Store) {
        // // Dynamically import electron-store
        // const storeModule = await import('electron-store');
        // Store = storeModule.default;
        // CommonJS
        Store = require('electron-store');
      }
      
      // Initialize persistent storage
      this.store = new Store({
        name: 'writers-toolkit-config'
      });
      console.log(`*** Electron Store location: ${this.store.path}`);
      
      // Load saved settings
      this.loadSettings();
      
      this.initialized = true;
      console.log('AppState initialized successfully');
    } catch (error) {
      console.error('Error initializing AppState:', error);
      throw error;
    }
  }
  
  loadSettings() {
    if (!this.store) {
      console.warn('Store not initialized, cannot load settings');
      return;
    }
    
    // Load settings from electron-store
    const settings = this.store.get('settings', {});
    
    // Apply saved settings if available
    if (settings.current_project) {
      this.CURRENT_PROJECT = settings.current_project;
    }
    
    if (settings.current_project_path) {
      const savedPath = settings.current_project_path;
      if (this.isPathValid(savedPath)) {
        this.CURRENT_PROJECT_PATH = savedPath;
        this.DEFAULT_SAVE_DIR = savedPath;
      }
    }
    
    // Load Claude API settings
    this.settings_claude_api_configuration = 
      this.store.get('claude_api_configuration', {
        max_retries: 1,
        request_timeout: 300,
        context_window: 200000,
        thinking_budget_tokens: 32000,
        betas_max_tokens: 128000,
        desired_output_tokens: 12000
      });
  }
  
  isPathValid(filePath) {
    // Verify path exists and is within PROJECTS_DIR
    try {
      const realPath = path.resolve(filePath);
      const realProjectsDir = path.resolve(this.PROJECTS_DIR);
      return realPath.startsWith(realProjectsDir);
    } catch (error) {
      console.error('Path validation error:', error);
      return false;
    }
  }
  
  // ... other methods to manage state
}

// Create a singleton instance
const appStateInstance = new AppState();

// Export the instance with an initialize method
module.exports = appStateInstance;

============================================================
FILE: streaming_example.js
SIZE: 4900 bytes
LANGUAGE: JS
============================================================

// Load environment variables from ~/.env
require('dotenv').config({ path: require('os').homedir() + '/.env' });
const anthropic = require('@anthropic-ai/sdk');
const fs = require('fs/promises');
const path = require('path');
const os = require('os');

// Usage: node streaming_example.js <path-to-manuscript.txt>
const manuscriptPath = process.argv[2];
if (!manuscriptPath) {
  console.error('Error: Please provide the path to your manuscript .txt file.');
  console.error('Usage: node streaming_example.js path/to/book.txt');
  process.exit(1);
}

// Ensure API key is set
const apiKey = process.env.ANTHROPIC_API_KEY;
if (!apiKey) {
  console.error('Error: `ANTHROPIC_API_KEY` environment variable not found.');
  process.exit(1);
}

// Instantiate Anthropic client with custom timeout and no retries
const client = new anthropic.Anthropic({
  apiKey: apiKey,
  timeout: 300 * 1000,   // 300 seconds in milliseconds
  maxRetries: 0,
});

// Read the manuscript text from disk
async function loadManuscript(filePath) {
  try {
    console.log(`Reading manuscript from: ${path.resolve(filePath)}`);
    return await fs.readFile(path.resolve(filePath), 'utf-8');
  } catch (err) {
    console.error(`Failed to read manuscript at ${filePath}:`, err.message);
    process.exit(1);
  }
}

/**
 * Send a streaming analysis request with dynamic prompts and track cache metrics.
 * @param {{type:string,text:string,cache_control:object}} bookTextBlock
 * @param {string} dynamicSystemText
 * @param {string} userQuery
 */
async function analyzeWith(num, bookTextBlock, userQuery) {
  console.log('Sending request to Claude API...');
  console.log(`Query: "${userQuery}"`);
  
  try {
    // Use beta.messages.stream specifically as required
    console.log('Using beta.messages.stream API...');
    
    const systemMessages = [
      bookTextBlock
    ];
    
    // We'll use the raw stream instead of the standard helpers
    // This gives us more direct control to debug
    const stream = await client.beta.messages.stream({
      model: 'claude-3-7-sonnet-20250219',
      max_tokens: 50000,
      system: systemMessages,
      messages: [{ role: 'user', content: userQuery }],
      thinking: { type: 'enabled', budget_tokens: 32000 },
      betas: ['output-128k-2025-02-19']
    });

    // const rateLimit = stream.response?.headers?.get('anthropic-ratelimit-requests-limit');
    // console.log('Rate Limit via suggested method:', rateLimit);
    
    // Add error handler
    stream.on('error', (error) => {
      console.error('Stream error:', error);
    });
    
    // Start processing the stream
    console.log(`\n--- ${num}. CLAUDE RESPONSE ---\n`);
    
    let alreadyPrintedCache = false;
    
    for await (const chunk of stream) {
      // console.log(JSON.stringify(chunk, null, 2));
      
      // Check if this is a message_start event with usage info
      if (chunk.type === 'message_start' && !alreadyPrintedCache) {
        try {
          const usage = chunk.message?.usage;
          if (usage) {
            console.log('\n=== CACHE METRICS ===');
            console.log('cache_creation_input_tokens:', usage.cache_creation_input_tokens || 0);
            console.log('cache_read_input_tokens:    ', usage.cache_read_input_tokens || 0);
            console.log('input_tokens (uncached):    ', usage.input_tokens || 0);
            console.log('=== END CACHE METRICS ===\n');
            alreadyPrintedCache = true;
          }
        } catch (e) {
          console.error('Error extracting cache metrics:', e);
        }
      }
      
      // Also extract any completion text
      if (chunk.completion) {
        process.stdout.write(chunk.completion);
      }
    }
    
    console.log('\n\n--- END OF RESPONSE ---');
  } catch (error) {
    console.error('Error during API call:', error);
    console.error('Error details:', error.message);
    if (error.response) {
      console.error('Response error:', error.response);
    }
  }
}

// Main IIFE
;(async () => {
  try {
    console.log('Starting manuscript analysis...');
    const manuscriptContent = await loadManuscript(manuscriptPath);
    console.log(`Manuscript size: ${manuscriptContent.length} characters`);
    
    const BOOK_TEXT = { 
      type: 'text', 
      text: `=== MANUSCRIPT: A Darker Roast ===\n${manuscriptContent}\n=== END MANUSCRIPT: A Darker Roast ===`,
      cache_control: { type: 'ephemeral' } 
    };
    
    await analyzeWith(
      "1",
      BOOK_TEXT,
      'What is the last word in my manuscript.'
    );
    console.log('Analysis complete.');
    
    await analyzeWith(
      "2",
      BOOK_TEXT,
      'You are an AI assistant specializing in thematic analysis of fiction. ' +
      'List the names of all of the characters in my manuscript.'
    );
    console.log('Analysis complete.');
    
  } catch (error) {
    console.error('Unexpected error:', error);
  }
})();

============================================================
FILE: tense-consistency-checker.js
SIZE: 17140 bytes
LANGUAGE: JS
============================================================

// tense-consistency-checker.js
const BaseTool = require('./base-tool');
const path = require('path');
const fileCache = require('./file-cache');
const appState = require('./state.js');
const fs = require('fs/promises');

/**
 * Tense Consistency Checker Tool
 * Analyzes a single manuscript file for verb tense consistency issues using the Claude API.
 * Identifies shifts between past/present tense that might confuse readers.
 * Unlike character tools, this only analyzes the manuscript itself, not outline/world files.
 */
class TenseConsistencyChecker extends BaseTool {
  /**
   * Constructor
   * @param {Object} GeminiAPIService - Claude API service
   * @param {Object} config - Tool configuration
   */
  constructor(GeminiAPIService, config = {}) {
    super('tense_consistency_checker', config);
    this.GeminiAPIService = GeminiAPIService;
  }
  
  /**
   * Execute the tool
   * @param {Object} options - Tool options
   * @returns {Promise<Object>} - Execution result
   */
  async execute(options) {
    console.log('Executing Tense Consistency Checker with options:', options);
    
    // Extract options
    let manuscriptFile = options.manuscript_file;
    const analysisLevel = options.analysis_level || 'standard';
    const chapterMarkers = options.chapter_markers || 'Chapter';
    const saveDir = options.save_dir || appState.CURRENT_PROJECT_PATH;
    
    if (!saveDir) {
      const errorMsg = 'Error: No save directory specified and no current project selected.\n' +
                      'Please select a project or specify a save directory.';
      this.emitOutput(errorMsg);
      throw new Error('No save directory available');
    }

    // Ensure file paths are absolute
    manuscriptFile = this.ensureAbsolutePath(manuscriptFile, saveDir);
    
    // Log the full paths for debugging
    console.log('Using full paths:');
    console.log(`Manuscript: ${manuscriptFile}`);

    const outputFiles = [];
    
    try {
      // Read the input files
      this.emitOutput(`Reading files...\n`);

      // Read the manuscript file
      this.emitOutput(`Reading manuscript file: ${manuscriptFile}\n`);
      const manuscriptContent = await this.readInputFile(manuscriptFile);
      const manuscriptWordCount = this.countWords(manuscriptContent);
      const manuscriptTokens = await this.GeminiAPIService.countTokens(manuscriptContent);
      
      const prompt = this.createTenseAnalysisPrompt(manuscriptContent, analysisLevel, chapterMarkers);

      const promptTokens = await this.GeminiAPIService.countTokens(prompt);

      // Call the shared token budget calculator
      const tokenBudgets = this.GeminiAPIService.calculateTokenBudgets(promptTokens);

      // Handle logging based on the returned values
      this.emitOutput(`\nToken stats:\n`);
      this.emitOutput(`Manuscript is ${manuscriptWordCount} words and ${manuscriptTokens} tokens.\n`);
      this.emitOutput(`Input prompt tokens: [${tokenBudgets.promptTokens}]\n`);
      this.emitOutput(`\n`);
      this.emitOutput(`Max AI model context window: [${tokenBudgets.contextWindow}] tokens\n`);
      this.emitOutput(`Available tokens: [${tokenBudgets.availableTokens}]  = ${tokenBudgets.contextWindow} - ${tokenBudgets.promptTokens} = context_window - prompt\n`);
      this.emitOutput(`Desired output tokens: [${tokenBudgets.desiredOutputTokens}]\n`);
      this.emitOutput(`AI model thinking budget: [${tokenBudgets.thinkingBudget}] tokens\n`);
      this.emitOutput(`Max output tokens: [${tokenBudgets.maxTokens}] tokens\n`);

      // Check for special conditions
      if (tokenBudgets.capThinkingBudget) {
        this.emitOutput(`Warning: thinking budget is larger than 32K, set to 32K.\n`);
      }

      // Check if the prompt is too large
      if (tokenBudgets.isPromptTooLarge) {
        this.emitOutput(`Error: prompt is too large to have a ${tokenBudgets.configuredThinkingBudget} thinking budget!\n`);
        this.emitOutput(`Run aborted!\n`);
        throw new Error(`Prompt is too large for ${tokenBudgets.configuredThinkingBudget} thinking budget - run aborted`);
      }
      
      // Call Claude API with streaming
      this.emitOutput(`Sending request to Claude API (streaming)...\n`);

      // Add a message about waiting
      this.emitOutput(`****************************************************************************\n`);
      this.emitOutput(`*  Analyzing tense consistency in your manuscript...                        \n`);
      this.emitOutput(`*  \n`);
      this.emitOutput(`*  This process typically takes several minutes.                           \n`);
      this.emitOutput(`*                                                                          \n`);
      this.emitOutput(`*  It's recommended to keep this window the sole 'focus'                   \n`);
      this.emitOutput(`*  and to avoid browsing online or running other apps, as these API        \n`);
      this.emitOutput(`*  network connections are often flakey, like delicate echoes of whispers. \n`);
      this.emitOutput(`*                                                                          \n`);
      this.emitOutput(`*  So breathe, remove eye glasses, stretch, relax, and be like water 🥋 🧘🏽‍♀️\n`);
      this.emitOutput(`*  \n`);
      this.emitOutput(`****************************************************************************\n\n`);
      
      const startTime = Date.now();
      let fullResponse = "";
      let thinkingContent = "";
      
      // Create system prompt to avoid markdown
      const systemPrompt = "CRITICAL INSTRUCTION: NO Markdown formatting of ANY kind. Never use headers, bullets, or any formatting symbols. Plain text only with standard punctuation.";

      // Use the calculated values in the API call
      try {
        // await this.GeminiAPIService.streamWithThinking(
        //   prompt,
        //   {
        //     model: "claude-3-7-sonnet-20250219",
        //     system: systemPrompt,
        //     max_tokens: tokenBudgets.maxTokens,
        //     thinking: {
        //       type: "enabled",
        //       budget_tokens: tokenBudgets.thinkingBudget
        //     },
        //     betas: ["output-128k-2025-02-19"]
        //   },
        //   // Callback for thinking content
        //   (thinkingDelta) => {
        //     thinkingContent += thinkingDelta;
        //   },
        //   // Callback for response text
        //   (textDelta) => {
        //     fullResponse += textDelta;
        //   }
        // );
        await this.GeminiAPIService.streamWithThinkingAndMessageStart(
          prompt,
          {
            model: "claude-3-7-sonnet-20250219",
            system: systemPrompt,
            max_tokens: tokenBudgets.maxTokens,
            thinking: {
              type: "enabled",
              budget_tokens: tokenBudgets.thinkingBudget
            },
            betas: ["output-128k-2025-02-19"]
          },
          // callback for thinking content
          (thinkingDelta) => {
            thinkingContent += thinkingDelta;
          },
          // callback for response text
          (textDelta) => {
            fullResponse += textDelta;
          },
          // callback for message start with stats
          (messageStart) => {
            this.emitOutput(`${messageStart}\n`);
          },
          // callback for response headers
          (responseHeaders) => {
            this.emitOutput(`${responseHeaders}\n`);
          },
          // callback for status
          (callStatus) => {
            this.emitOutput(`${callStatus}\n`);
          },
        );
      } catch (error) {
        this.emitOutput(`\nAPI Error: ${error.message}\n`);
        throw error;
      }

      const elapsed = (Date.now() - startTime) / 1000;
      const minutes = Math.floor(elapsed / 60);
      const seconds = elapsed % 60;
      
      this.emitOutput(`\nCompleted in: ⏰ ${minutes}m ${seconds.toFixed(2)}s.\n`);
      
      // Count words in response
      const wordCount = this.countWords(fullResponse);
      this.emitOutput(`Report has approximately ${wordCount} words.\n`);
      
      // Count tokens in response
      const responseTokens = await this.GeminiAPIService.countTokens(fullResponse);
      this.emitOutput(`Response token count: ${responseTokens}\n`);

      // Remove any markdown formatting
      fullResponse = this.removeMarkdown(fullResponse);

      // Save the report
      const outputFile = await this.saveReport(
        analysisLevel,
        fullResponse,
        thinkingContent,
        promptTokens,
        responseTokens,
        saveDir
      );
      
      // Add all output files to the result
      outputFiles.push(...outputFile);
      
      // Add files to the cache
      const toolName = 'tense_consistency_checker';
      outputFiles.forEach(file => {
        fileCache.addFile(toolName, file);
      });
      
      // Return the result
      return {
        success: true,
        outputFiles,
        stats: {
          wordCount,
          tokenCount: responseTokens,
          elapsedTime: `${minutes}m ${seconds.toFixed(2)}s`,
          analysisLevel
        }
      };
    } catch (error) {
      console.error('Error in Tense Consistency Checker:', error);
      this.emitOutput(`\nError: ${error.message}\n`);
      throw error;
    }
  }
  
  /**
   * Create tense analysis prompt
   * @param {string} manuscriptContent - Manuscript content
   * @param {string} analysisLevel - Analysis level (basic, standard, detailed)
   * @param {string} chapterMarkers - Text that marks the start of chapters
   * @returns {string} - Prompt for Claude API
   */
  createTenseAnalysisPrompt(manuscriptContent, analysisLevel = "standard", chapterMarkers = "Chapter") {
    // Build instruction section based on analysis level
    const basicInstructions = `
1. NARRATIVE TENSE OVERVIEW:
   - Identify the main tense used in the manuscript (past or present)
   - List any notable sections that use a different tense
   - Provide examples of the dominant tense usage

2. TENSE CONSISTENCY ISSUES:
   - Identify passages where tense shifts unexpectedly 
   - Highlight sentences that mix past and present tense inappropriately
   - Provide specific examples with page/paragraph references where possible

3. RECOMMENDATIONS:
   - Suggest how to fix inconsistent tense usage
   - Explain which tense might work better for specific problematic passages
`;

    const standardInstructions = basicInstructions + `
4. INTENTIONAL VS. UNINTENTIONAL SHIFTS:
   - Differentiate between potentially deliberate tense shifts (for flashbacks, etc.) and likely errors
   - Analyze if tense shifts are marked properly with transitions or context clues
   - Evaluate if any intentional shifts are effective or potentially confusing

5. TENSE PATTERNS:
   - Note any patterns in tense usage (e.g., present tense for action, past for reflection)
   - Identify if dialogue attribution follows consistent tense conventions
`;

    const detailedInstructions = standardInstructions + `
6. CHARACTER PERSPECTIVE ANALYSIS:
   - For each POV character, analyze if their sections maintain consistent tense
   - Note if different viewpoint characters use different tenses
   - Identify any tense shift patterns related to character perspective changes

7. STRUCTURAL TENSE ANALYSIS:
   - Analyze tense usage patterns across chapters/scenes
   - Identify if chapter/section breaks coincide with tense shifts
   - Consider if tense shifts serve structural or pacing purposes

8. ADVANCED TENSE USAGE:
   - Analyze more complex tense forms (past perfect, future perfect, etc.)
   - Evaluate consistency in handling of flashbacks, flash-forwards, and memories
   - Consider if complex tense constructions are used effectively
`;

    // Choose the appropriate instruction level
    let instructionSet;
    if (analysisLevel === "basic") {
      instructionSet = basicInstructions;
    } else if (analysisLevel === "detailed") {
      instructionSet = detailedInstructions;
    } else {  // standard
      instructionSet = standardInstructions;
    }

    // Construct the full prompt
    const instructions = `IMPORTANT: NO Markdown formatting

You are an expert literary editor specializing in narrative tense analysis. Your task is to analyze the provided manuscript for verb tense consistency and identify any problematic tense shifts.

Focus specifically on what Ursula K. Le Guin calls "two-timing" - when authors shift between past and present tense without clear purpose, potentially confusing readers. Identify places where tense shifts inappropriately, and distinguish between intentional, effective tense changes and problematic inconsistencies.

Pay special attention to chapter/section breaks marked with "${chapterMarkers}" as potential locations for intentional tense shifts.

Create a comprehensive tense analysis with these sections:
${instructionSet}

Format your analysis as a clear, organized report with sections and subsections. Use plain text formatting only (NO Markdown). Use numbered or bulleted lists where appropriate for clarity.

Be specific in your examples, quoting brief passages that demonstrate tense issues and suggesting corrections. When appropriate, provide line numbers or context to help the author locate issues in their manuscript.
`;

    // Combine all sections
    return `=== MANUSCRIPT ===\n${manuscriptContent}\n=== END MANUSCRIPT ===\n\n${instructions}`;
  }

  /**
   * Count words in text
   * @param {string} text - Text to count words in
   * @returns {number} - Word count
   */
  countWords(text) {
    return text.split(/\s+/).filter(word => word.length > 0).length;
  }
  
  /**
   * Ensure file path is absolute
   * @param {string} filePath - File path (may be relative or absolute)
   * @param {string} basePath - Base path to prepend for relative paths
   * @returns {string} - Absolute file path
   */
  ensureAbsolutePath(filePath, basePath) {
    if (!filePath) return filePath;
    
    // Check if the path is already absolute
    if (path.isAbsolute(filePath)) {
      return filePath;
    }
    
    // Make the path absolute by joining with the base path
    return path.join(basePath, filePath);
  }
  
  /**
   * Save report and thinking content to files
   * @param {string} analysisLevel - Analysis level (basic, standard, detailed)
   * @param {string} content - Response content
   * @param {string} thinking - Thinking content
   * @param {number} promptTokens - Prompt token count
   * @param {number} responseTokens - Response token count
   * @param {string} saveDir - Directory to save to
   * @returns {Promise<string[]>} - Array of paths to saved files
   */
  async saveReport(analysisLevel, content, thinking, promptTokens, responseTokens, saveDir) {
    try {
      const formatter = new Intl.DateTimeFormat('en-US', {
        weekday: 'long',
        month: 'long',
        day: 'numeric',
        year: 'numeric',
        hour: 'numeric',
        minute: '2-digit',
        hour12: true
      });
      const dateTimeStr = formatter.format(new Date());

      // Create timestamp for filename
      const timestamp = new Date().toISOString().replace(/[-:.]/g, '').substring(0, 15);
      
      // Create descriptive filename
      const level = analysisLevel !== 'standard' ? `_${analysisLevel}` : '';
      const baseFilename = `tense_analysis${level}_${timestamp}`;
      
      // Array to collect all saved file paths
      const savedFilePaths = [];
      
      // Create stats for thinking file
      const stats = `
Details:  ${dateTimeStr}
Analysis type: Tense consistency analysis
Analysis level: ${analysisLevel}
Max request timeout: ${this.config.request_timeout} seconds
Max AI model context window: ${this.config.context_window} tokens
AI model thinking budget: ${this.config.thinking_budget_tokens} tokens
Desired output tokens: ${this.config.desired_output_tokens} tokens

Input tokens: ${promptTokens}
Output tokens: ${responseTokens}
`;
      
      // Save full response
      const reportFilename = `${baseFilename}.txt`;
      const reportPath = path.join(saveDir, reportFilename);
      await this.writeOutputFile(content, saveDir, reportFilename);
      savedFilePaths.push(reportPath);
      
      // Save thinking content if available and not skipped
      if (thinking) {
        const thinkingFilename = `${baseFilename}_thinking.txt`;
        const thinkingPath = path.join(saveDir, thinkingFilename);
        const thinkingContent = `=== TENSE CONSISTENCY ANALYSIS ===

=== AI'S THINKING PROCESS ===

${thinking}

=== END AI'S THINKING PROCESS ===
${stats}`;
        
        await this.writeOutputFile(thinkingContent, saveDir, thinkingFilename);
        this.emitOutput(`AI thinking saved to: ${thinkingPath}\n`);
        savedFilePaths.push(thinkingPath);
      }

      this.emitOutput(`Report saved to: ${reportPath}\n`);
      return savedFilePaths;
    } catch (error) {
      console.error(`Error saving report:`, error);
      this.emitOutput(`Error saving report: ${error.message}\n`);
      throw error;
    }
  }
}

module.exports = TenseConsistencyChecker;

============================================================
FILE: test_open_app.js
SIZE: 2097 bytes
LANGUAGE: JS
============================================================

const { exec } = require('child_process');
const os = require('os');

function openExternalApp(appName, filePath = null) {
  const platform = os.platform();
  let command;
  
  if (platform === 'darwin') {  // macOS
    command = filePath 
      ? `open -a "${appName}" "${filePath}"`
      : `open -a "${appName}"`;
  } 
  else if (platform === 'win32') {  // Windows
    command = filePath 
      ? `start "" "${appName}" "${filePath}"`
      : `start "" "${appName}"`;
  }
  else {  // Linux and others
    command = filePath 
      ? `xdg-open "${filePath}"`
      : null;
  }
  
  if (command) {
    return new Promise((resolve, reject) => {
      exec(command, (error, stdout, stderr) => {
        if (error) {
          console.error(`Error launching application: ${error.message}`);
          reject(error);
          return;
        }
        console.log('Command executed successfully:', command);
        resolve(true);
      });
    });
  } else {
    return Promise.reject(new Error(`Unsupported platform: ${platform}`));
  }
}

// Test the function by launching a simple app
async function runTest() {
  try {
    // Determine which app to test based on platform
    const platform = os.platform();
    let testApp;
    
    if (platform === 'darwin') { // macOS
      // testApp = "TextEdit";
      testApp = "Sublime Text";
    } else if (platform === 'win32') { // Windows
      testApp = "notepad";
    } else {
      // For Linux, we can just try to open a file
      console.log("On Linux, testing with file opening only");
    }
    
    console.log(`Testing app launch on ${platform} with app: ${testApp}`);
    
    // Launch without a file
    await openExternalApp(testApp);
    console.log("App launched successfully without file");
    
    // Optional: Uncomment to test with a file
    // const testFilePath = "/path/to/your/test.txt"; // Change this to a real file path
    // await openExternalApp(testApp, testFilePath);
    // console.log("App launched successfully with file");
    
  } catch (error) {
    console.error("Test failed:", error);
  }
}

runTest();


============================================================
FILE: test.js
SIZE: 1535 bytes
LANGUAGE: JS
============================================================

// Import the text processor module
const textProcessor = require('./textProcessor');
const fs = require('fs');

// Example text to process - matches the terminal output example
const sampleText = `
Chapter 1: the one

This is the first paragraph of chapter one.

This is the second paragraph.


This is after two blank lines.



This is after three blank lines.


Chapter 2. the deuce

This is the first paragraph of chapter two.

This is the second paragraph.

CHAPTER 3: another title

This shows case-insensitive matching.
`;

// console.log("Original Text:");
// console.log("=============");
// console.log(sampleText);

// console.log("\nProcessed Text:");
// console.log("==============");
// console.log(textProcessor.processText(sampleText));

// Function to process a real manuscript file
function processFile(inputPath, outputPath) {
  try {
    // Read the input file
    const text = fs.readFileSync(inputPath, 'utf8');
    
    // Process the text
    const processed = textProcessor.processText(text);
    
    // Write the processed text to the output file
    fs.writeFileSync(outputPath, processed);
    
    console.log(`\nSuccessfully processed file from ${inputPath} to ${outputPath}`);
  } catch (error) {
    console.error('Error processing file:', error);
  }
}

// Uncomment the following line to process an actual manuscript file
processFile('manuscript_hattie.txt', 'manuscript-raw.txt');
console.log("\nProcessed Text:");
console.log("==============");
console.log(textProcessor.processText(sampleText));



============================================================
FILE: textProcessor.js
SIZE: 1832 bytes
LANGUAGE: JS
============================================================

/**
 * This script provides text processing functions for manuscript formatting:
 * 1. Remove chapter title lines (pattern "Chapter X: [any title]" or "Chapter X. [any title]")
 * 2. Normalize multiple blank lines to single blank lines
 */

/**
 * Removes lines that match chapter title patterns (case-insensitive)
 * Works with both "Chapter X: title" and "Chapter X. title" formats
 * @param {string} text - The input text to process
 * @return {string} - Text with chapter title lines removed
 */
function removeChapterTitleLines(text) {
  // Match lines that contain only "chapter" (case-insensitive) followed by a number,
  // then either a colon or period, and any title text
  return text.replace(/^chapter \d+[:.] .*$/gim, '');
}

/**
 * Normalize all multiple blank lines to single blank lines
 * @param {string} text - The input text to process
 * @return {string} - Text with consistent single blank lines
 */
function normalizeBlankLines(text) {
  // Replace all instances of multiple blank lines with a single blank line
  return text.replace(/\n{2,}/g, '\n\n');
}

/**
 * Process text by applying all operations in sequence
 * @param {string} text - The input text to process
 * @return {string} - Fully processed text
 */
function processText(text) {
  // First remove chapter title lines
  let processed = removeChapterTitleLines(text);
  
  // Then normalize all blank lines
  processed = normalizeBlankLines(processed);
  
  // Remove any leading blank lines that might remain after chapter title removal
  processed = processed.replace(/^\s+/, '');
  
  // Remove any trailing blank lines
  processed = processed.replace(/\s+$/, '');
  
  return processed;
}

// Export all the functions so they can be imported in other files
module.exports = {
  removeChapterTitleLines,
  normalizeBlankLines,
  processText
};


============================================================
FILE: thinking_gemini25pro.js
SIZE: 4283 bytes
LANGUAGE: JS
============================================================

// To run this code you need to install the following dependencies:
// npm install @google/genai

const { GoogleGenAI, HarmCategory, HarmBlockThreshold } = require('@google/genai');

async function main() {
  if (!process.env.GEMINI_API_KEY) {
    console.error("ERROR: GEMINI_API_KEY environment variable is not set.");
    return;
  }  

  const modelName = 'gemini-2.5-pro-preview-05-06';
  // const modelName = 'gemini-2.5-pro-exp-03-25';

  const originalUserQuery = "list planets";

  // --- MODIFIED PROMPT TO STRONGLY DISCOURAGE MARKDOWN ---
  const structuredPrompt = `
You are a helpful assistant. Your responses must be in PLAIN TEXT ONLY.
ABSOLUTELY DO NOT use any Markdown formatting (such as **, *, #, lists with -, etc.) in any part of your response.

Follow these instructions carefully:
1. First, explain your thinking process for how you will answer the query: "${originalUserQuery}".
   This thinking process MUST be in plain text. Do not use any Markdown.
   Enclose this plain text thinking process within <thinking>...</thinking> tags.

2. After the </thinking> tag, provide the direct answer to the query: "${originalUserQuery}".
   This answer MUST also be in plain text. Strictly avoid any Markdown formatting.
`;
  // --- END OF MODIFIED PROMPT ---

  const generationConfig = {
    responseMimeType: 'text/plain', // This helps but isn't a foolproof guarantee against internal Markdown generation
  };

  const safetySettings = [
    { category: HarmCategory.HARM_CATEGORY_HARASSMENT, threshold: HarmBlockThreshold.BLOCK_NONE },
    { category: HarmCategory.HARM_CATEGORY_HATE_SPEECH, threshold: HarmBlockThreshold.BLOCK_NONE },
    { category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT, threshold: HarmBlockThreshold.BLOCK_NONE },
    { category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT, threshold: HarmBlockThreshold.BLOCK_NONE },
  ];

  const contents = [
    {
      role: 'user',
      parts: [{ text: structuredPrompt }],
    },
  ];

  try {
    const ai = new GoogleGenAI({ apiKey: process.env.GEMINI_API_KEY });

    console.log(`Using model: ${modelName}`);
    console.log("Sending request to Gemini...\n");

    const resultStream = await ai.models.generateContentStream({
      model: modelName,
      generationConfig: generationConfig,
      contents: contents,
      safetySettings: safetySettings,
    });

    let fullResponseText = "";
    for await (const chunk of resultStream) {
      if (chunk.text) {
        fullResponseText += chunk.text;
      } else if (chunk.candidates && chunk.candidates.length > 0 && chunk.candidates[0].content && chunk.candidates[0].content.parts && chunk.candidates[0].content.parts.length > 0 && chunk.candidates[0].content.parts[0].text) {
        fullResponseText += chunk.candidates[0].content.parts[0].text;
      }
    }

    console.log("\n--- Processing Complete ---");

    let thinkingText = "";
    let contentText = "";

    const thinkingStartTag = "<thinking>";
    const thinkingEndTag = "</thinking>";

    const thinkingStartIndex = fullResponseText.indexOf(thinkingStartTag);
    const thinkingEndIndex = fullResponseText.indexOf(thinkingEndTag);

    if (thinkingStartIndex !== -1 && thinkingEndIndex !== -1 && thinkingEndIndex > thinkingStartIndex) {
      thinkingText = fullResponseText.substring(thinkingStartIndex + thinkingStartTag.length, thinkingEndIndex).trim();
      contentText = fullResponseText.substring(thinkingEndIndex + thinkingEndTag.length).trim();
    } else {
      console.warn("Warning: <thinking> tags not found in the response. Treating entire response as content.");
      contentText = fullResponseText.trim();
    }

    console.log("\n--- Captured Thinking/Reasoning (Plain Text) ---");
    if (thinkingText) {
      console.log(thinkingText);
    } else {
      console.log("(No explicit thinking/reasoning captured)");
    }

    console.log("\n--- Captured Content Stream (Final Answer - Plain Text) ---");
    console.log(contentText);

  } catch (error) {
    console.error("Error during Gemini API call:", error);
    if (error.response && error.response.data) {
        console.error("API Error Details:", JSON.stringify(error.response.data, null, 2));
    } else {
        console.error("Full Error Object:", error);
    }
  }
}

main();


============================================================
FILE: token-limit-test.js
SIZE: 7880 bytes
LANGUAGE: JS
============================================================

// Load environment variables from ~/.env
require('dotenv').config({ path: require('os').homedir() + '/.env' });
const anthropic = require('@anthropic-ai/sdk');
const fs = require('fs/promises');
const path = require('path');
const os = require('os');

// Ensure API key is set
const apiKey = process.env.ANTHROPIC_API_KEY;
if (!apiKey) {
  console.error('Error: `ANTHROPIC_API_KEY` environment variable not found.');
  process.exit(1);
}

// Instantiate Anthropic client with custom timeout and no retries
const client = new anthropic.Anthropic({
  apiKey: apiKey,
  timeout: 300 * 1000, // 300 seconds in milliseconds
  maxRetries: 0,
});

/**
 * First check current token limits to understand our quota
 */
async function checkCurrentLimits() {
  try {
    console.log('Checking current API limits...');
    
    // Make a minimal request to check headers
    // Note: max_tokens must be greater than thinking.budget_tokens
    const { data, response } = await client.beta.messages.create({
      model: 'claude-3-7-sonnet-20250219',
      max_tokens: 2000,  // Must be greater than thinking.budget_tokens
      messages: [{ role: 'user', content: 'Hi' }],
      thinking: { type: 'enabled', budget_tokens: 1024 },  // Minimum allowed value
      betas: ['output-128k-2025-02-19']
    }).withResponse();
    
    // Display all headers from the raw response
    console.log('\n=== CURRENT RATE LIMITS ===');
    
    // Headers is a Map-like object, get all entries and sort them
    const headerEntries = Array.from(response.headers.entries())
      .filter(([name]) => name.includes('anthropic-ratelimit'))
      .sort();
    
    // Print each header and its value
    for (const [name, value] of headerEntries) {
      console.log(`${name}: ${value}`);
    }
    
    // Extract token limits specifically
    const inputTokenLimit = parseInt(response.headers.get('anthropic-ratelimit-input-tokens-limit'));
    const inputTokenRemaining = parseInt(response.headers.get('anthropic-ratelimit-input-tokens-remaining'));
    const outputTokenLimit = parseInt(response.headers.get('anthropic-ratelimit-output-tokens-limit'));
    const outputTokenRemaining = parseInt(response.headers.get('anthropic-ratelimit-output-tokens-remaining'));
    
    return {
      inputTokenLimit,
      inputTokenRemaining,
      outputTokenLimit,
      outputTokenRemaining
    };
  } catch (error) {
    console.error('Error checking limits:', error.message);
    throw error;
  }
}

/**
 * Generate a large text to trigger the input token limit
 * @param {number} targetTokens - Approximate number of tokens to generate
 */
function generateLargeInput(targetTokens) {
  // A rough approximation is that 1 token ≈ 4 characters in English
  const charsPerToken = 4;
  const targetChars = targetTokens * charsPerToken;
  console.log(`\n>>> targetTokens=${targetTokens}`);
  console.log(`>>> targetChars=${targetChars}\n`);
  
  // Create a repeating text to reach our target size
  let text = '';
  const paragraph = 'This is a test paragraph designed to consume tokens. Each sentence adds to the token count. ' +
                    'We need to exceed the input token limit to trigger the rate limit error. ' +
                    'By repeating this paragraph many times, we will eventually reach our target token count. ' +
                    'The Claude API will then return a rate limit error with the retry-after header. ';
  
  while (text.length < targetChars) {
    text += paragraph;
  }
  
  console.log(`Generated input text of approximately ${Math.floor(text.length / charsPerToken)} tokens (${text.length} characters)`);
  return text;
}

/**
 * Use the SDK to send an oversized request that will trigger a rate limit
 */
async function analyzeWithOversizedInput() {
  try {
    // First, check our current limits
    const limits = await checkCurrentLimits();
    
    // Generate input that is larger than our remaining input token allowance (add 20% to ensure we exceed it)
    const targetTokens = Math.ceil(limits.inputTokenRemaining * 1.2);
    
    console.log(`\n=== RATE LIMIT TEST ===`);
    console.log(`Attempting to exceed input token limit (${limits.inputTokenRemaining}) with request of ~${targetTokens} tokens`);
    
    // Generate the large input
    // const largeInput = generateLargeInput(targetTokens);
    // cls: hardcode book size:
    const largeInput = generateLargeInput(120000);
    
    console.log('Sending request to Claude API using SDK...');
    console.log('Using beta.messages.create API with withResponse()...');
    
    // No system messages needed for this test
    const systemMessages = [];
    
    // Make the oversized request using the SDK with all your original parameters
    // Note: max_tokens (50000) is greater than thinking.budget_tokens (32000) as required
    const { data: response, response: rawResponse } = await client.beta.messages.create({
      model: 'claude-3-7-sonnet-20250219',
      max_tokens: 50000,  // greater than thinking.budget_tokens (32000)
      system: systemMessages,
      messages: [{ role: 'user', content: largeInput }],
      thinking: { type: 'enabled', budget_tokens: 32000 },
      betas: ['output-128k-2025-02-19']
    }).withResponse();
    
    // If we get here, we didn't exceed the limit
    console.log('Request succeeded without hitting limits. You may need to increase the input size further.');
    
    // Display all headers from the raw response
    console.log('\n=== ALL RESPONSE HEADERS ===');
    
    // Headers is a Map-like object, get all entries and sort them
    const headerEntries = Array.from(rawResponse.headers.entries()).sort();
    
    // Print each header and its value
    for (const [name, value] of headerEntries) {
      console.log(`${name}: ${value}`);
    }
    console.log('=== END RESPONSE HEADERS ===\n');

    // Log the entire content array to see all blocks
    console.log("All response blocks:");
    console.log(JSON.stringify(response.content, null, 2));

    // Display usage information
    if (response.usage) {
      console.log('\n=== USAGE METRICS ===');
      console.log('input_tokens:', response.usage.input_tokens || 0);
      console.log('output_tokens:', response.usage.output_tokens || 0);
      console.log('=== END USAGE METRICS ===\n');
    }
    
    return { success: true, response, rawResponse };
  } catch (error) {
    // Check if this is a rate limit error
    if (error.status === 429) {
      console.log(`\n🚨 RATE LIMIT EXCEEDED! 🚨`);
      console.log(`Status: ${error.status}`);
      
      // Try to extract and display headers from the error response
      try {
        if (error.response && error.response.headers) {
          const retryAfter = error.response.headers.get('retry-after');
          console.log(`retry-after: ${retryAfter} seconds`);
          
          console.log('\n=== ALL ERROR RESPONSE HEADERS ===');
          const headerEntries = Array.from(error.response.headers.entries()).sort();
          for (const [name, value] of headerEntries) {
            console.log(`${name}: ${value}`);
          }
          console.log('=== END ERROR RESPONSE HEADERS ===\n');
        } else {
          console.log('No headers available in the error response');
        }
      } catch (headerError) {
        console.error('Error accessing headers:', headerError);
      }
      
      return { success: false, error };
    } else {
      // Some other error occurred
      console.error('Error during API call:', error);
      console.error('Error details:', error.message);
      return { success: false, error };
    }
  }
}

// Main IIFE
;(async () => {
  try {
    console.log('Starting rate limit test...');
    
    // Run the test
    await analyzeWithOversizedInput();
    
    console.log('Test complete.');
  } catch (error) {
    console.error('Unexpected error:', error);
  }
})();

============================================================
FILE: tokens-words-counter.js
SIZE: 15826 bytes
LANGUAGE: JS
============================================================

// tokens-words-counter.js
const BaseTool = require('./base-tool');
const path = require('path');
const fileCache = require('./file-cache');
const appState = require('./state.js');
const fs = require('fs').promises;

/**
 * TokensWordsCounter Tool
 * Enhanced to analyze manuscripts, count tokens/words, and identify chapters
 * with visualizations for each chapter's token usage
 */
class TokensWordsCounter extends BaseTool {
  constructor(GeminiAPIService, config = {}) {
    super('tokens_words_counter', config);
    this.GeminiAPIService = GeminiAPIService;
  }
  
  /**
   * Count words in text
   * @param {string} text - Text to count words in
   * @returns {number} - Word count
   */
  countWords(text) {
    return text.split(/\s+/).filter(word => word.length > 0).length;
  }
  
  /**
   * Execute the tool
   * @param {Object} options - Tool options
   * @returns {Promise<Object>} - Execution result
   */
  async execute(options) {
    if (!this.GeminiAPIService) {
      throw new Error('Claude service not initialized for TokensWordsCounter');
    }

    try {
      // Clear the cache for this tool
      const toolName = 'tokens_words_counter';
      fileCache.clear(toolName);

      // Extract options
      let inputFile = options.input_file;

      // Get Claude API configuration from this.config
      const thinkingBudget = this.config.thinking_budget_tokens;
      const contextWindow = this.config.context_window;
      
      this.emitOutput(`API Configuration: Context Window=${contextWindow}, Thinking Budget=${thinkingBudget}\n`);

      const outputFiles = [];

      // Get the project directory path
      const saveDir = options.save_dir || appState.CURRENT_PROJECT_PATH;
      if (!saveDir) {
        const errorMsg = 'Error: No save directory specified and no current project selected.\n' +
                        'Please select a project or specify a save directory.';
        this.emitOutput(errorMsg);
        throw new Error('No save directory available');
      }
    
      // Fix relative paths by resolving them against the project directory
      if (inputFile && !path.isAbsolute(inputFile) && !inputFile.startsWith('~/')) {
        inputFile = path.join(saveDir, inputFile);
      }

      // Read the input file
      this.emitOutput(`Reading file: ${inputFile}\n`);
      const text = await this.readInputFile(inputFile);
      
      // Basic token and word counting
      this.emitOutput('Counting words...\n');
      const wordCount = this.countWords(text);
      this.emitOutput(`Word count: ${wordCount.toLocaleString()}\n`);
      
      const totalTokens = await this.GeminiAPIService.countTokens(text);
      this.emitOutput(`Token count: ${totalTokens.toLocaleString()}\n`);

      const wordsPerToken = totalTokens > 0 ? wordCount / totalTokens : 0;
      
      if (totalTokens >= contextWindow) {
        this.emitOutput(`\nDocument is too large to anaylze chapters: ${totalTokens} tokens is greater than ${contextWindow} tokens\n`);
        const availableOutputTokens = 0;
        return {
          success: false,
          outputFiles,
          stats: {
            wordCount,
            tokenCount: totalTokens,
            wordsPerToken: wordsPerToken.toFixed(2),
            chapterCount: null,
            thinkingBudget,
            availableOutputTokens
          }
        };
      }
      
      // Use the shared token budgets calculator from the Claude service
      const tokenBudgets = this.GeminiAPIService.calculateTokenBudgets(totalTokens);
      
      // Calculate available tokens for output (after thinking budget)
      const availableOutputTokens = tokenBudgets.availableTokens - thinkingBudget;
      
      this.emitOutput(`Using configured thinking budget: ${thinkingBudget} tokens\n`);
      this.emitOutput(`Available tokens for output: ${availableOutputTokens.toLocaleString()}\n`);
      
      // Enhanced functionality: Identify chapters in the manuscript
      this.emitOutput('\nAnalyzing manuscript for chapters...\n');
      const chapters = this.identifyChapters(text);
      this.emitOutput(`Identified ${chapters.length} chapters\n`);
      
      // Count tokens for each chapter
      this.emitOutput('Analyzing chapter statistics...\n');
      const chaptersWithCounts = await this.countChapterStats(chapters);
      
      // Generate the full report
      let reportContent = this.generateReport(
        inputFile, 
        wordCount, 
        totalTokens, 
        wordsPerToken, 
        tokenBudgets, 
        chaptersWithCounts,
        thinkingBudget,
        contextWindow
      );
      
      // Output the summary report to the console
      this.emitOutput('\n' + reportContent + '\n');
      
      // Save the report to a file
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      const inputBase = path.basename(inputFile);
      const inputName = path.parse(inputBase).name;
      const outputFileName = `tokens_words_counter_${inputName}_${timestamp}.txt`;
      this.emitOutput(`Saving report to: ${path.join(saveDir, outputFileName)}\n`);
      
      const outputFile = await this.writeOutputFile(
        reportContent, 
        saveDir, 
        outputFileName
      );
      
      // Add to local tracking array
      outputFiles.push(outputFile);
      
      // Add to the shared file cache
      fileCache.addFile(toolName, outputFile);
      
      this.emitOutput('Analysis complete!\n');
      
      // Return the result
      return {
        success: true,
        outputFiles,
        stats: {
          wordCount,
          tokenCount: totalTokens,
          wordsPerToken: wordsPerToken.toFixed(2),
          chapterCount: chapters.length,
          thinkingBudget,
          availableOutputTokens
        }
      };
    } catch (error) {
      console.error('Error in TokensWordsCounter:', error);
      this.emitOutput(`\nError: ${error.message}\n`);
      if (!this.GeminiAPIService) {
        console.error('GeminiAPIService is null');
      }
      throw error;
    }

  }

  /**
   * Identifies chapters in the manuscript text
   * @param {string} text - Full manuscript text
   * @returns {Array} Array of chapter objects
   */
  identifyChapters(text) {
    const chapters = [];
    
    // Common chapter patterns
    const patterns = [
      // "Chapter X" or "Chapter X: Title" or "Chapter X - Title"
      /Chapter\s+(\d+|[IVXLCDM]+|[A-Za-z]+)(?:\s*[:|\-|\s]\s*(.+?))?(?=\r?\n)/gi,
      
      // Just the number with a newline (e.g. "1\n" or "I.\n")
      /^(?:\s*)(\d+|[IVXLCDM]+)\.?(?:\s*)(.*?)(?=\r?\n)/gm,
    ];
    
    // Try each pattern to find chapter breaks
    let chapterMatches = [];
    for (const pattern of patterns) {
      let match;
      const regexCopy = new RegExp(pattern); // Create a fresh copy of the regex
      while ((match = regexCopy.exec(text)) !== null) {
        chapterMatches.push({
          chapterNumber: match[1].trim(),
          title: match[2] ? match[2].trim() : '',
          index: match.index
        });
      }
      if (chapterMatches.length > 0) break;
    }
    
    // Sort matches by position in text
    chapterMatches.sort((a, b) => a.index - b.index);
    
    // Extract chapter content
    for (let i = 0; i < chapterMatches.length; i++) {
      const current = chapterMatches[i];
      const next = chapterMatches[i + 1];
      
      const startIndex = current.index;
      const endIndex = next ? next.index : text.length;
      const content = text.substring(startIndex, endIndex);
      
      chapters.push({
        number: i + 1,
        originalNumber: current.chapterNumber,
        title: current.title || '',
        content: content.trim()
      });
    }
    
    // If no chapters were found, treat the entire manuscript as a single chapter
    if (chapters.length === 0) {
      chapters.push({
        number: 1,
        originalNumber: '1',
        title: '',
        content: text.trim()
      });
    }
    
    return chapters;
  }

  /**
   * Counts words and tokens for each chapter
   * @param {Array} chapters - Array of chapter objects
   * @returns {Promise<Array>} Chapters with word and token counts
   */
  async countChapterStats(chapters) {
    const updatedChapters = [];
    
    // Helper function to pause execution
    const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));
    
    // Use a very short delay of 5ms between API calls
    const delayMs = 5;
    
    // Get configuration values we need for visualization
    const thinkingBudget = this.config.thinking_budget_tokens;
    const contextWindow = this.config.context_window;
    
    // Inform user about processing
    if (chapters.length > 1) {
      this.emitOutput(`Processing ${chapters.length} chapters with minimal delay between requests.\n\n`);
    }
    
    for (let i = 0; i < chapters.length; i++) {
      const chapter = chapters[i];
      
      // Count words
      const wordCount = this.countWords(chapter.content);
      
      try {
        // Use Claude API to count tokens
        const tokenCount = await this.GeminiAPIService.countTokens(chapter.content);
        
        // Calculate remaining tokens for this chapter
        const remainingTokens = contextWindow - tokenCount - thinkingBudget;
        
        // Calculate tool capacity score (0-100%)
        const toolCapacity = Math.min(100, Math.round((remainingTokens / 100000) * 100));
        
        // Calculate context utilization percentage
        const contextPercent = ((tokenCount / contextWindow) * 100).toFixed(1);
        
        // Add the chapter with counts to our results
        updatedChapters.push({
          ...chapter,
          wordCount,
          tokenCount
        });
        
        // Output the chapter analysis immediately
        // this.emitOutput(`\nChapter ${chapter.number}${chapter.title ? `: ${chapter.title}` : ''} - ${wordCount.toLocaleString()} words, ${tokenCount.toLocaleString()} tokens, available for Tool: ${remainingTokens.toLocaleString()} tokens\n`);
        // this.emitOutput(`${this.generateContextVisualization(tokenCount, thinkingBudget, contextWindow)}\n\n`);
        
        // Add minimal delay between API calls (except for the last chapter)
        if (i < chapters.length - 1) {
          await sleep(delayMs);
        }
      } catch (error) {
        this.emitOutput(`Error analyzing Chapter ${chapter.number}: ${error.message}\n`);
        throw error;
      }
    }
    
    return updatedChapters;
  }
  
  /**
   * Creates a visual representation of context window utilization with emojis
   * @param {number} usedTokens - Tokens used by chapter
   * @param {number} thinkingBudget - Tokens reserved for thinking (from config)
   * @param {number} contextWindow - Total context window size (from config)
   * @returns {string} Visualization with emojis
   */
  generateContextVisualization(usedTokens, thinkingBudget, contextWindow) {
    try {
      const totalWidth = 50; // Width of visualization in characters
      // Calculate proportions
      const usedWidth = Math.round((usedTokens / contextWindow) * totalWidth);
      const thinkingWidth = Math.round((thinkingBudget / contextWindow) * totalWidth);
      const remainingWidth = totalWidth - usedWidth - thinkingWidth;
      // Create the visualization with emojis
      let usedBar = '📝'.repeat(Math.ceil(usedWidth/2)); // for chapters
      if (usedBar.length <= 0) {
        usedBar = '📝';
      }
      const thinkingBar = '🧠'.repeat(Math.ceil(thinkingWidth/2)); // for thinking
      const remainingBar = '🤖'.repeat(Math.ceil(remainingWidth/2)); // for available
      // Assemble the visualization
      return `visualize Context Window usage:\n${usedBar}${thinkingBar}${remainingBar} ${Math.round((usedTokens + thinkingBudget) / contextWindow * 100)}% used\n📝 chapters | 🧠 thinking (${thinkingBudget.toLocaleString()}) | 🤖 available for Tool usage`;
    } catch (error) {
      console.error('Error in TokensWordsCounter:', error);
      this.emitOutput(`\nError: ${error}\n`);
      throw error;
    }

  }

  /**
   * Generate the final analysis report
   * @param {string} filePath - Path to the input file
   * @param {number} wordCount - Total word count
   * @param {number} totalTokens - Total token count
   * @param {number} wordsPerToken - Words per token ratio
   * @param {Object} tokenBudgets - Token budget calculations
   * @param {Array} chapters - Analyzed chapters
   * @param {number} thinkingBudget - Thinking budget from configuration
   * @param {number} contextWindow - Context window size from configuration
   * @returns {string} Formatted report
   */
  generateReport(filePath, wordCount, totalTokens, wordsPerToken, tokenBudgets, chapters, thinkingBudget, contextWindow) {
    const availableOutputTokens = tokenBudgets.availableTokens - thinkingBudget;
    
    let report = `MANUSCRIPT ANALYSIS REPORT  ${new Date().toLocaleString()}

File: ${filePath}


-------
SUMMARY

Total Chapters: ${chapters.length}
Total Human Words: ${wordCount.toLocaleString()}
Total AI Tokens: ${totalTokens.toLocaleString()}
Words per token ratio: ${wordsPerToken.toFixed(2)}

-------------------
TOOL CONFIGURATION:

Context window: ${contextWindow.toLocaleString()} tokens
Thinking budget (preserved): ${thinkingBudget.toLocaleString()} tokens (for deep manuscript analysis)
Manuscript size: ${totalTokens.toLocaleString()} tokens
Remaining For Tool: ${availableOutputTokens.toLocaleString()} tokens

${this.generateContextVisualization(totalTokens, thinkingBudget, contextWindow)}


------------------
CHAPTER BREAKDOWN:

`;

    // Add detailed analysis for each chapter with visualization
    chapters.forEach(ch => {
      // Calculate remaining tokens for this chapter
      const remainingTokens = contextWindow - ch.tokenCount - thinkingBudget;
      
      // Calculate tool capacity score (0-100%)
      const toolCapacity = Math.min(100, Math.round((remainingTokens / 100000) * 100));
      
      // Calculate context utilization percentage
      const contextPercent = ((ch.tokenCount / contextWindow) * 100).toFixed(1);
      
      report += `\nChapter ${ch.number}${ch.title ? `: ${ch.title}` : ''} - ${ch.wordCount.toLocaleString()} words, ${ch.tokenCount.toLocaleString()} tokens, available for Tool: ${remainingTokens.toLocaleString()} tokens\n`;
      report += `${this.generateContextVisualization(ch.tokenCount, thinkingBudget, contextWindow)}\n\n`;
    });

    report += `\n
--------------------
TOOL RECOMMENDATIONS

1. For best results, preserve the ${thinkingBudget.toLocaleString()} token thinking budget for Claude to thoroughly analyze your writing
2. Each chapter can be processed individually for detailed analysis
3. The "TOOL CAPACITY" percentage provides a quick reference for how much detailed feedback Claude can provide:
   - 90-100%: Excellent capacity for very detailed feedback
   - 70-89%: Good capacity for comprehensive suggestions
   - 50-69%: Moderate capacity for targeted analysis of key passages
   - Below 50%: Limited capacity, focus on most critical sections only

4. When submitting chapters for processing:
   - Include specific instructions about style, clarity, word choice, and sentence structure
   - Consider breaking larger chapters into smaller segments if you need more detailed feedback
   - Request sample rewrites of problematic passages to maximize the value of remaining tokens

5. IMPORTANT: The large token numbers (150K+) represent the theoretical maximum space for Claude's response, 
   but actual effective feedback is typically 10-20K tokens. Higher remaining tokens simply ensure Claude 
   has plenty of room to provide thorough analysis without hitting token limits.
`;

    return report;
  }
}

module.exports = TokensWordsCounter;


============================================================
FILE: tool-general-template.js
SIZE: 10547 bytes
LANGUAGE: JS
============================================================

// tool-general.js
const BaseTool = require('./base-tool');
const path = require('path');
const fileCache = require('./file-cache');
const appState = require('./state.js');
const fs = require('fs/promises');

/**
 * Generic Tool Template
 * Use this as a starting point for converting Python tools to JavaScript
 * 
 * CUSTOMIZATION POINTS:
 * 1. Change the class name and constructor name parameter
 * 2. Implement the createPrompt method with appropriate prompt templates
 * 3. Update the saveReport method if needed for specific output formatting
 * 4. Add any tool-specific helper methods as needed
 */
class GenericTool extends BaseTool {
  /**
   * Constructor
   * @param {Object} GeminiAPIService - Claude API service
   * @param {Object} config - Tool configuration
   */
  constructor(GeminiAPIService, config = {}) {
    // TODO: Change 'generic_tool' to your tool's ID
    super('generic_tool', config);
    this.GeminiAPIService = GeminiAPIService;
    // console.log('Generic Tool initialized with config:', config);
  }
  
  /**
   * Execute the tool
   * @param {Object} options - Tool options
   * @returns {Promise<Object>} - Execution result
   */
  async execute(options) {
    console.log('Executing GenericTool with options:', options);
    
    // Clear the cache for this tool
    // TODO: Change 'generic_tool' to your tool's ID
    const toolName = 'generic_tool';
    fileCache.clear(toolName);
    
    // Extract common options - customize as needed
    const inputFile = options.input_file;
    const saveDir = options.save_dir || appState.CURRENT_PROJECT_PATH;
    const outputFiles = [];
    
    // Validate save directory
    if (!saveDir) {
      const errorMsg = 'Error: No save directory specified and no current project selected.\n' +
                      'Please select a project or specify a save directory.';
      this.emitOutput(errorMsg);
      throw new Error('No save directory available');
    }
    
    // Ensure file paths are absolute
    const absoluteInputFile = this.ensureAbsolutePath(inputFile, saveDir);
    
    try {
      // Read input file
      this.emitOutput(`Reading input file: ${absoluteInputFile}\n`);
      const inputContent = await this.readInputFile(absoluteInputFile);
      
      // TODO: Add additional input file reading if your tool needs multiple inputs
      
      // Create prompt using input content
      const prompt = this.createPrompt(inputContent);

      // Count tokens in the prompt
      this.emitOutput(`Counting tokens in prompt...\n`);
      const promptTokens = await this.GeminiAPIService.countTokens(prompt);

      // Call the shared token budget calculator
      const tokenBudgets = this.GeminiAPIService.calculateTokenBudgets(promptTokens);

      // Handle logging based on the returned values
      this.emitOutput(`\nToken stats:\n`);
      this.emitOutput(`Max AI model context window: [${tokenBudgets.contextWindow}] tokens\n`);
      this.emitOutput(`Input prompt tokens: [${tokenBudgets.promptTokens}] ...\n`);
      this.emitOutput(`                     = outline.txt + world.txt + manuscript.txt\n`);
      this.emitOutput(`                       + prompt instructions\n`);
      this.emitOutput(`Available tokens: [${tokenBudgets.availableTokens}]  = ${tokenBudgets.contextWindow} - ${tokenBudgets.promptTokens} = context_window - prompt\n`);
      this.emitOutput(`Desired output tokens: [${tokenBudgets.desiredOutputTokens}]\n`);
      this.emitOutput(`AI model thinking budget: [${tokenBudgets.thinkingBudget}] tokens\n`);
      this.emitOutput(`Max output tokens: [${tokenBudgets.maxTokens}] tokens\n`);

      // Check for special conditions
      if (tokenBudgets.capThinkingBudget) {
        this.emitOutput(`Warning: thinking budget is larger than 32K, set to 32K.\n`);
      }

      // Check if the prompt is too large
      if (tokenBudgets.isPromptTooLarge) {
        this.emitOutput(`Error: prompt is too large to have a ${tokenBudgets.configuredThinkingBudget} thinking budget!\n`);
        this.emitOutput(`Run aborted!\n`);
        throw new Error(`Prompt is too large for ${tokenBudgets.configuredThinkingBudget} thinking budget - run aborted`);
      }
      
      // Call Claude API with streaming
      this.emitOutput(`Sending request to Claude API (streaming)...\n`);
      
      const startTime = Date.now();
      let fullResponse = "";
      let thinkingContent = "";
      
      // Create system prompt to avoid markdown
      const systemPrompt = "NO Markdown! Never respond with Markdown formatting, plain text only.";

      // Use the calculated values in the API call
      try {
        await this.GeminiAPIService.streamWithThinking(
          prompt,
          {
            model: "claude-3-7-sonnet-20250219",
            system: systemPrompt,
            max_tokens: tokenBudgets.maxTokens,
            thinking: {
              type: "enabled",
              budget_tokens: tokenBudgets.thinkingBudget
            },
            betas: ["output-128k-2025-02-19"]
          },
          // Callback for thinking content
          (thinkingDelta) => {
            thinkingContent += thinkingDelta;
          },
          // Callback for response text
          (textDelta) => {
            fullResponse += textDelta;
          }
        );
      } catch (error) {
        this.emitOutput(`\nAPI Error: ${error.message}\n`);
        throw error;
      }
      
      // Calculate time elapsed
      const elapsed = (Date.now() - startTime) / 1000;
      const minutes = Math.floor(elapsed / 60);
      const seconds = elapsed % 60;
      
      this.emitOutput(`\nCompleted in ${minutes}m ${seconds.toFixed(2)}s.\n`);
      
      // Count words in response
      const wordCount = this.countWords(fullResponse);
      this.emitOutput(`Report has approximately ${wordCount} words.\n`);
      
      // Count tokens in response
      const responseTokens = await this.GeminiAPIService.countTokens(fullResponse);
      this.emitOutput(`Response token count: ${responseTokens}\n`);
      
      // Save the response to a file
      const customDescription = options.custom_description || '';
      
      const outputFile = await this.saveReport(
        fullResponse,
        thinkingContent,
        promptTokens,
        responseTokens,
        saveDir,
        customDescription
      );
      
      outputFiles.push(outputFile);
      
      // Add to the file cache
      fileCache.addFile(toolName, outputFile);
      
      // Return the result
      return {
        success: true,
        outputFiles,
        stats: {
          wordCount,
          tokenCount: responseTokens,
          elapsedTime: `${minutes}m ${seconds.toFixed(2)}s`
        }
      };
      
    } catch (error) {
      console.error('Error in GenericTool:', error);
      this.emitOutput(`\nError: ${error.message}\n`);
      throw error;
    }
  }
  
  /**
   * Create prompt based on input content
   * @param {string} inputContent - The content of the input file
   * @returns {string} - Prompt for Claude API
   * 
   * TODO: Implement this method with your specific prompt templates
   */
  createPrompt(inputContent) {
    // CUSTOMIZATION POINT: Replace with your tool-specific prompt
    return `=== INPUT ===
${inputContent}
=== END INPUT ===

NO Markdown formatting!

[Your tool-specific instructions here]

1. Read the input content
2. [Specific task for Claude]
3. [Additional instructions]
`;
  }
  
  /**
   * Count words in text
   * @param {string} text - Text to count words in
   * @returns {number} - Word count
   */
  countWords(text) {
    return text.split(/\s+/).filter(word => word.length > 0).length;
  }
  
  /**
   * Ensure file path is absolute
   * @param {string} filePath - File path (may be relative or absolute)
   * @param {string} basePath - Base path to prepend for relative paths
   * @returns {string} - Absolute file path
   */
  ensureAbsolutePath(filePath, basePath) {
    if (!filePath) return filePath;
    
    // Check if the path is already absolute
    if (path.isAbsolute(filePath)) {
      return filePath;
    }
    
    // Make the path absolute by joining with the base path
    return path.join(basePath, filePath);
  }
  
  /**
   * Save report and thinking content to files
   * @param {string} content - Response content
   * @param {string} thinking - Thinking content
   * @param {number} promptTokens - Prompt token count
   * @param {number} responseTokens - Response token count
   * @param {string} saveDir - Directory to save to
   * @param {string} description - Optional description
   * @returns {Promise<string>} - Path to saved report
   */
  async saveReport(content, thinking, promptTokens, responseTokens, saveDir, description) {
    try {
      // TODO: Change 'output' to something more descriptive for your tool
      const toolType = 'output';
      
      // Create timestamp for filename
      const timestamp = new Date().toISOString().replace(/[-:.]/g, '').substring(0, 15);
      
      // Create descriptive filename
      const desc = description ? `_${description}` : '';
      const baseFilename = `${toolType}${desc}_${timestamp}`;
      
      // Create stats for thinking file
      const stats = `
Details:
Max request timeout: ${this.config.request_timeout || 300} seconds
Max AI model context window: ${this.config.context_window || 200000} tokens
AI model thinking budget: ${this.config.thinking_budget_tokens || 32000} tokens
Desired output tokens: ${this.config.desired_output_tokens || 12000} tokens

Input tokens: ${promptTokens}
Output tokens: ${responseTokens}
`;
      
      // Save full response
      const reportFilename = `${baseFilename}.txt`;
      const reportPath = path.join(saveDir, reportFilename);
      await this.writeOutputFile(content, saveDir, reportFilename);
      
      // Save thinking content if available and not skipped
      if (thinking) {
        const thinkingFilename = `${baseFilename}_thinking.txt`;
        const thinkingContent = `=== TOOL OUTPUT ===

${thinking}

=== END TOOL OUTPUT ===
${stats}`;
        
        await this.writeOutputFile(thinkingContent, saveDir, thinkingFilename);
        this.emitOutput(`AI thinking saved to: ${path.join(saveDir, thinkingFilename)}\n`);
      }
      
      this.emitOutput(`Report saved to: ${reportPath}\n`);
      return reportPath;
    } catch (error) {
      console.error(`Error saving report:`, error);
      this.emitOutput(`Error saving report: ${error.message}\n`);
      throw error;
    }
  }
}

module.exports = GenericTool;

============================================================
FILE: tool-setup-run.js
SIZE: 32400 bytes
LANGUAGE: JS
============================================================

// Define path functions for filename extraction
const path = {
  basename: function(filepath) {
    // Simple implementation to extract filename from path
    return filepath.split(/[\/\\]/).pop();
  }
};

// Get UI elements
const toolNameElement = document.getElementById('tool-name');
const dialogToolNameElement = document.getElementById('dialog-tool-name');
const closeBtn = document.getElementById('close-btn');
const setupBtn = document.getElementById('setup-btn');
const runBtn = document.getElementById('run-btn');
const clearBtn = document.getElementById('clear-btn');
const forceQuitBtn = document.getElementById('force-quit-btn');
const outputElement = document.getElementById('output');
const elapsedTimeElement = document.getElementById('elapsed-time');

// Dialog elements
const setupDialogOverlay = document.getElementById('setup-dialog-overlay');
const setupDialogClose = document.getElementById('setup-dialog-close');
const setupDialogCancel = document.getElementById('setup-dialog-cancel');
const setupDialogApply = document.getElementById('setup-dialog-apply');
const dialogOptionsContainer = document.getElementById('dialog-options-container');

// Tool state
let toolData = null;
let currentToolOptions = [];
let isRunning = false;
let startTime = null;
let timerInterval = null;
let currentRunId = null;
let setupCompleted = false;
let currentOptionValues = {};
let canClose = true; // Flag to control whether the window can be closed

// Initialize when the window loads
// window.addEventListener('DOMContentLoaded', async () => {
//   // Get tool info from main process
//   try {
//     toolData = await window.electronAPI.getCurrentTool();
    
//     if (toolData) {
//       // Set tool name in both main view and dialog
//       toolNameElement.textContent = toolData.title || toolData.name;
//       dialogToolNameElement.textContent = toolData.title || toolData.name;
//       document.title = `Writer's Toolkit - ${toolData.title || toolData.name}`;
      
//       // Get tool options
//       currentToolOptions = await window.electronAPI.getToolOptions(toolData.name);
//       console.log('Loaded tool options:', currentToolOptions);
      
//       // Disable Run button until setup is completed
//       runBtn.disabled = true;
//     } else {
//       outputElement.textContent = 'Error: No tool selected!';
//     }
//   } catch (error) {
//     console.error('Error loading tool data:', error);
//     outputElement.textContent = `Error loading tool: ${error.message}`;
//   }
  
//   // Apply theme if one is set
//   window.electronAPI.onSetTheme((theme) => {
//     document.body.className = theme === 'light' ? 'light-mode' : 'dark-mode';
//   });
// });
window.addEventListener('DOMContentLoaded', async () => {
  // Get tool info from main process
  try {
    toolData = await window.electronAPI.getCurrentTool();
    
    if (toolData) {
      // Log what we're receiving for debugging
      console.log("Current tool data:", toolData);
      
      // Set tool name in both main view and dialog
      toolNameElement.textContent = toolData.title || toolData.name;
      dialogToolNameElement.textContent = toolData.title || toolData.name;
      document.title = `Writer's Toolkit - ${toolData.title || toolData.name}`;
      
      // Get tool options - wrap in try/catch to prevent hanging
      try {
        currentToolOptions = await window.electronAPI.getToolOptions(toolData.name);
        console.log('Loaded tool options:', currentToolOptions);
        
        // Disable Run button until setup is completed
        runBtn.disabled = true;
      } catch (optionsError) {
        console.error('Error loading tool options:', optionsError);
        outputElement.textContent = `Error loading tool options: ${optionsError.message}`;
        // Add fallback for tool options to prevent UI hanging
        currentToolOptions = [];
      }
    } else {
      outputElement.textContent = 'Error: No tool selected!';
    }
  } catch (error) {
    console.error('Error loading tool data:', error);
    outputElement.textContent = `Error loading tool: ${error.message}`;
  }
  
  // Apply theme if one is set
  window.electronAPI.onSetTheme((theme) => {
    document.body.className = theme === 'light' ? 'light-mode' : 'dark-mode';
  });
});

// Close button handler
closeBtn.addEventListener('click', () => {
  // Check if we're allowed to close while tool is running
  if (!canClose && isRunning) {
    outputElement.textContent += '\nCannot close while tool is running. Use Force Quit if necessary.\n';
    return;
  }

  // Before closing, stop any running tool
  if (isRunning && currentRunId) {
    window.electronAPI.stopTool(currentRunId)
      .then(() => {
        window.electronAPI.closeToolDialog('cancelled');
      })
      .catch(error => {
        console.error('Error stopping tool:', error);
        window.electronAPI.closeToolDialog('cancelled');
      });
  } else {
    window.electronAPI.closeToolDialog('cancelled');
  }
});

// Force Quit button handler - always enabled and immediately quits the app
forceQuitBtn.addEventListener('click', () => {
  console.log('Force quit requested');
  window.electronAPI.quitApp();
});

// Setup button handler - now opens the setup dialog
// setupBtn.addEventListener('click', () => {
//   // Generate form controls for options
//   generateOptionsForm(currentToolOptions);
//   // Show the dialog
//   showSetupDialog();
// });
setupBtn.addEventListener('click', () => {
  try {
    if (!toolData || !toolData.name) {
      outputElement.textContent = "Error: Unable to setup tool - missing tool data";
      return;
    }
    
    // Generate form controls for options
    generateOptionsForm(currentToolOptions || []);
    
    // Show the dialog
    showSetupDialog();
  } catch (error) {
    console.error("Error in setup button handler:", error);
    outputElement.textContent = `Setup error: ${error.message}`;
  }
});

// Setup dialog close button
setupDialogClose.addEventListener('click', () => {
  hideSetupDialog();
});

// Setup dialog cancel button
setupDialogCancel.addEventListener('click', () => {
  hideSetupDialog();
});

// Setup dialog apply button
setupDialogApply.addEventListener('click', () => {
  // Validate the form
  if (!validateOptionsForm()) {
    return; // Don't close dialog if validation fails
  }
  
  // Gather all options from form
  currentOptionValues = gatherOptionValues();
  
  // Display setup information in output area
  outputElement.textContent = `Tool: ${toolData.title || toolData.name}\n\nOptions:\n`;
  
  // Add each option and its value
  for (const [key, value] of Object.entries(currentOptionValues)) {
    outputElement.textContent += `${key}: ${value}\n`;
  }
  
  outputElement.textContent += '\nReady to run. Click the "Run" button to execute.';
  
  // Store the options for the run
  window.electronAPI.setToolOptions(currentOptionValues);
  
  // Enable Run button
  runBtn.disabled = false;
  setupCompleted = true;
  
  // Close the dialog
  hideSetupDialog();
});

// Run button handler
runBtn.addEventListener('click', async () => {
  if (isRunning) {
    outputElement.textContent += '\nTool is already running!';
    return;
  }
  
  if (!setupCompleted) {
    outputElement.textContent += '\nPlease complete Setup first.';
    return;
  }
  
  // Start timing
  startTime = Date.now();
  isRunning = true;
  canClose = false; // Prevent closing the window while tool is running
  startTimer();
  
  // Update UI - disable ALL buttons except Force Quit
  runBtn.disabled = true;
  setupBtn.disabled = true;
  clearBtn.disabled = true;
  closeBtn.disabled = true; // Disable the X close button
  
  // Remove any existing Edit button and select dropdown
  const existingEditButton = document.getElementById('edit-button');
  if (existingEditButton) {
    existingEditButton.remove();
  }
  
  const existingFileSelect = document.getElementById('output-file-select');
  if (existingFileSelect) {
    const container = existingFileSelect.closest('.compact-file-selector');
    if (container) {
      container.remove(); // Remove the entire container
    } else {
      existingFileSelect.remove();
    }
  }
  
  // Clear output and show starting message - clear all previous output
  outputElement.textContent = `Starting ${toolData.title || toolData.name}...\n\n`;
  
  try {
    // Remove any previous output listeners to avoid duplicate output
    window.electronAPI.removeAllListeners('tool-output');
    window.electronAPI.removeAllListeners('tool-finished');
    window.electronAPI.removeAllListeners('tool-error');
    
    // Run the tool
    currentRunId = await window.electronAPI.startToolRun(toolData.name, currentOptionValues);
    console.log('Tool started with run ID:', currentRunId);
    
    // Listen for output messages
    window.electronAPI.onToolOutput((data) => {
      // Only append output for the current run
      if (data.runId === currentRunId) {
        // Append output to the output element
        outputElement.textContent += data.text;
        
        // Auto scroll to bottom
        outputElement.scrollTop = outputElement.scrollHeight;
      }
    });

    // Listen for tool completion
    window.electronAPI.onToolFinished((result) => {
      // Only process completion for the current run
      if (result.runId === currentRunId) {
        console.log('Tool finished:', result);
        isRunning = false;
        canClose = true; // Allow closing the window again
        stopTimer();
        
        // Re-enable buttons
        setupBtn.disabled = false;
        clearBtn.disabled = false;
        closeBtn.disabled = false;

        runBtn.disabled = true;
        // Reset setupCompleted flag to require going through setup again
        setupCompleted = false;        

        // Add completion message to output area
        outputElement.textContent += `\n\nTool finished with exit code: ${result.code}`;
        
        // Create file selector if there are output files
        if (result.createdFiles && result.createdFiles.length > 0) {
          // First, log the files to the output area
          outputElement.textContent += `\n\nFiles created/modified:`;
          const fileList = document.createElement('pre');
          fileList.style.marginTop = '10px';
          fileList.style.whiteSpace = 'pre-wrap';
          fileList.style.fontSize = '12px';
          fileList.style.color = document.body.classList.contains('light-mode') ? '#666666' : '#aaaaaa';
          
          const fileListItems = result.createdFiles.map(file => `- ${file}`).join('\n');
          fileList.textContent = fileListItems;
          outputElement.appendChild(fileList);
          
          // Create a compact selector to place right after elapsed time
          const compactSelector = document.createElement('div');
          compactSelector.className = 'compact-file-selector';
          compactSelector.style.display = 'flex';
          compactSelector.style.alignItems = 'center';
          compactSelector.style.gap = '8px';
          compactSelector.style.marginLeft = '20px'; // More space from elapsed time
          
          // Create Edit button
          const editButton = document.createElement('button');
          editButton.id = 'edit-button';
          editButton.textContent = 'Edit';
          editButton.className = 'action-button';
          editButton.style.padding = '4px 10px';
          editButton.style.fontSize = '13px';
          // Add this line to match the Run button's green color:
          editButton.style.backgroundColor = '#22c55e';
          editButton.style.color = 'white';
          
          // Create select dropdown
          const select = document.createElement('select');
          select.id = 'output-file-select';
          select.style.maxWidth = '250px';
          select.style.fontSize = '13px';
          select.style.appearance = 'auto';
          
          // Add each file as an option
          result.createdFiles.forEach(file => {
            const option = document.createElement('option');
            option.value = file;
            option.textContent = path.basename(file);
            select.appendChild(option);
          });
          
          // Add click handler to the Edit button
          editButton.addEventListener('click', () => {
            const selectedFile = select.value;
            if (selectedFile) {
              const tempOutput = outputElement.textContent;
              
              window.electronAPI.openFileInEditor(selectedFile)
                .then(result => {
                  if (!result.success) {
                    outputElement.textContent = tempOutput + '\nError opening file: ' + 
                      (result.error || 'Unknown error');
                  }
                })
                .catch(error => {
                  console.error('Error opening file in editor:', error);
                  outputElement.textContent = tempOutput + '\nError opening file: ' + error.message;
                });
            }
          });
          
          // Assemble the selector
          compactSelector.appendChild(editButton);
          compactSelector.appendChild(select);
          
          // Insert right after elapsed time
          const elapsedTimeParent = elapsedTimeElement.parentNode;
          if (elapsedTimeParent) {
            if (elapsedTimeElement.nextSibling) {
              elapsedTimeParent.insertBefore(compactSelector, elapsedTimeElement.nextSibling);
            } else {
              elapsedTimeParent.appendChild(compactSelector);
            }
          } else {
            // Fallback - insert before Clear button
            const buttonRow = document.querySelector('.button-row');
            buttonRow.insertBefore(compactSelector, clearBtn);
          }
        }

        currentRunId = null;
      }
    });
    
    // Listen for tool errors
    window.electronAPI.onToolError((error) => {
      // Only process errors for the current run
      if (error.runId === currentRunId) {
        console.error('Tool error:', error);
        outputElement.textContent += `\n\nError: ${error.error}`;
        isRunning = false;
        canClose = true; // Allow closing the window again
        stopTimer();
        
        // Re-enable buttons
        runBtn.disabled = false;
        setupBtn.disabled = false;
        clearBtn.disabled = false;
        closeBtn.disabled = false;
        
        currentRunId = null;
      }
    });
  } catch (error) {
    // Handle errors
    console.error('Error running tool:', error);
    outputElement.textContent += `\nError running tool: ${error.message}`;
    isRunning = false;
    canClose = true; // Allow closing the window again
    stopTimer();
    
    // Re-enable buttons
    runBtn.disabled = false;
    setupBtn.disabled = false;
    clearBtn.disabled = false;
    closeBtn.disabled = false;
  }
});

// Clear button handler - updated to reset elapsed time and disable Run button
clearBtn.addEventListener('click', () => {
  // Clear output area
  outputElement.textContent = 'Output cleared.';
  
  // Reset elapsed time display
  elapsedTimeElement.textContent = 'elapsed: 0m 0s';
  
  // Reset timer variables
  startTime = null;
  if (timerInterval) {
    clearInterval(timerInterval);
    timerInterval = null;
  }
  
  // Remove any existing Edit button and file select dropdown
  const existingEditButton = document.getElementById('edit-button');
  if (existingEditButton) {
    existingEditButton.remove();
  }
  
  const existingFileSelect = document.getElementById('output-file-select');
  if (existingFileSelect) {
    const container = existingFileSelect.closest('.compact-file-selector');
    if (container) {
      container.remove(); // Remove the entire container
    } else {
      existingFileSelect.remove();
    }
  }
  
  // Disable Run button until setup is completed again
  runBtn.disabled = true;
  setupCompleted = false;
});

// Show the setup dialog
function showSetupDialog() {
  setupDialogOverlay.style.display = 'flex';
}

// Hide the setup dialog
function hideSetupDialog() {
  setupDialogOverlay.style.display = 'none';
}

// Generate form controls for tool options
function generateOptionsForm(options) {
  try {
    dialogOptionsContainer.innerHTML = '';
    
    if (!options || options.length === 0) {
      const emptyMessage = document.createElement('p');
      emptyMessage.textContent = 'This tool has no configurable options.';
      dialogOptionsContainer.appendChild(emptyMessage);
      return;
    }
    
    options.forEach(option => {
      try {
        const formGroup = document.createElement('div');
        formGroup.className = 'form-group';

        // only create labels and descriptions for non-boolean fields
        if (option.type !== 'boolean') {
          // Create label
          const label = document.createElement('label');
          label.setAttribute('for', `option-${option.name}`);
          label.textContent = option.label || option.name;
          formGroup.appendChild(label);
          
          // Add description if available
          if (option.description) {
            const description = document.createElement('p');
            description.className = 'option-description';
            description.textContent = option.description;
            formGroup.appendChild(description);
          }
        }

        // Create input based on type
        let input;
        
        switch (option.type) {
          case 'boolean':
            // Remove any previously created label element
            if (formGroup.querySelector('label')) {
              formGroup.removeChild(formGroup.querySelector('label'));
            }
            
            // Create a simple wrapper for the checkbox and label
            const checkboxWrapper = document.createElement('div');
            checkboxWrapper.className = 'checkbox-wrapper';
            
            // Create the checkbox input
            input = document.createElement('input');
            input.type = 'checkbox';
            input.id = `option-${option.name}`;
            input.name = option.name;
            input.checked = option.default === true;
            
            // Create the label that will appear next to the checkbox
            const checkboxLabel = document.createElement('label');
            checkboxLabel.setAttribute('for', `option-${option.name}`);
            checkboxLabel.textContent = option.label;
            checkboxLabel.className = 'checkbox-label';
            
            // Add the checkbox and label to the wrapper
            checkboxWrapper.appendChild(input);
            checkboxWrapper.appendChild(checkboxLabel);
            
            // Add the wrapper to the form group
            formGroup.appendChild(checkboxWrapper);

            // Add description if available
            if (option.description) {
              const description = document.createElement('p');
              description.className = 'option-description';
              description.textContent = option.description;
              formGroup.appendChild(description);
            }
            break;

          case 'number':
            input = document.createElement('input');
            input.type = 'number';
            input.id = `option-${option.name}`;
            input.name = option.name;
            input.value = option.default !== undefined ? option.default : '';
            
            if (option.min !== undefined) input.min = option.min;
            if (option.max !== undefined) input.max = option.max;
            if (option.step !== undefined) input.step = option.step;
            
            formGroup.appendChild(input);
            break;
            
          case 'select':
            input = document.createElement('select');
            input.id = `option-${option.name}`;
            input.name = option.name;
            
            if (option.choices && Array.isArray(option.choices)) {
              option.choices.forEach(choice => {
                const optionEl = document.createElement('option');
                optionEl.value = choice.value;
                optionEl.textContent = choice.label || choice.value;
                
                if (option.default === choice.value) {
                  optionEl.selected = true;
                }
                
                input.appendChild(optionEl);
              });
            }
            
            formGroup.appendChild(input);
            break;
            
          case 'file':
            const fileContainer = document.createElement('div');
            fileContainer.className = 'file-input-container';
            
            input = document.createElement('input');
            input.type = 'text';
            input.id = `option-${option.name}`;
            input.name = option.name;
            input.value = option.default || '';
            input.readOnly = true;
            
            const browseBtn = document.createElement('button');
            browseBtn.type = 'button';
            browseBtn.textContent = 'Browse...';
            browseBtn.className = 'browse-button';

            // File selection handler with better error handling
            browseBtn.addEventListener('click', async (event) => {
              // Prevent default to ensure the event is properly handled
              event.preventDefault();
              event.stopPropagation();
              
              try {
                // Get current tool name for DOCX filtering
                const currentToolName = toolData ? toolData.name : '';
                const isDocxExtractorTool = currentToolName === 'docx_comments';
                
                // Default filters or use option's filters
                let filters = option.filters || [{ name: 'All Files', extensions: ['*'] }];
                
                // If this is NOT the docx comments tool and filters include .docx,
                // remove .docx from the allowed extensions
                if (!isDocxExtractorTool) {
                  filters = filters.map(filter => {
                    // If this filter includes docx, create a new filter without it
                    if (filter.extensions && filter.extensions.includes('docx')) {
                      return {
                        name: filter.name,
                        extensions: filter.extensions.filter(ext => ext !== 'docx')
                      };
                    }
                    return filter;
                  });
                  
                  // Remove any empty extension arrays
                  filters = filters.filter(filter => 
                    filter.extensions && filter.extensions.length > 0
                  );
                  
                  // Ensure we still have at least one filter
                  if (filters.length === 0) {
                    filters = [{ name: 'Text Files', extensions: ['txt'] }];
                  }
                }
                
                console.log('Using filters:', filters);
                
                const filePath = await window.electronAPI.selectFile({
                  title: `Select ${option.label || option.name}`,
                  filters: filters
                });
                
                console.log('Selected file path:', filePath);
                
                if (filePath) {
                  input.value = filePath;
                  
                  // Trigger a change event to ensure validation recognizes the new value
                  const changeEvent = new Event('change', { bubbles: true });
                  input.dispatchEvent(changeEvent);
                  
                  // Clear any error message
                  const errorElement = document.getElementById(`error-${option.name}`);
                  if (errorElement) {
                    errorElement.style.display = 'none';
                  }
                }
              } catch (error) {
                console.error('Error selecting file:', error);
                outputElement.textContent += `\nError selecting file: ${error.message}\n`;
              }
            });
            
            fileContainer.appendChild(input);
            fileContainer.appendChild(browseBtn);
            formGroup.appendChild(fileContainer);
            break;
            
          case 'directory':
            const dirContainer = document.createElement('div');
            dirContainer.className = 'file-input-container';
            
            input = document.createElement('input');
            input.type = 'text';
            input.id = `option-${option.name}`;
            input.name = option.name;
            input.value = option.default || '';
            input.readOnly = true;
            
            const browseDirBtn = document.createElement('button');
            browseDirBtn.type = 'button';
            browseDirBtn.textContent = 'Browse...';
            browseDirBtn.className = 'browse-button';
            
            browseDirBtn.addEventListener('click', async (event) => {
              event.preventDefault();
              event.stopPropagation();
              
              try {
                const dirPath = await window.electronAPI.selectDirectory({
                  title: `Select ${option.label || option.name}`
                });
                
                console.log('Selected directory path:', dirPath);
                
                if (dirPath) {
                  input.value = dirPath;
                  
                  // Trigger change event
                  const changeEvent = new Event('change', { bubbles: true });
                  input.dispatchEvent(changeEvent);
                  
                  // Clear any error message
                  const errorElement = document.getElementById(`error-${option.name}`);
                  if (errorElement) {
                    errorElement.style.display = 'none';
                  }
                }
              } catch (error) {
                console.error('Error selecting directory:', error);
                outputElement.textContent += `\nError selecting directory: ${error.message}\n`;
              }
            });
            
            dirContainer.appendChild(input);
            dirContainer.appendChild(browseDirBtn);
            formGroup.appendChild(dirContainer);
            break;
            
          case 'textarea':
            input = document.createElement('textarea');
            input.id = `option-${option.name}`;
            input.name = option.name;
            input.rows = option.rows || 4;
            input.value = option.default || '';
            formGroup.appendChild(input);
            break;
            
          case 'text':
          default:
            input = document.createElement('input');
            input.type = 'text';
            input.id = `option-${option.name}`;
            input.name = option.name;
            input.value = option.default || '';
            formGroup.appendChild(input);
            break;
        }
        
        // Special handling for save_dir option
        if (option.name === 'save_dir') {
          // Get current project path from main process
          window.electronAPI.getProjectInfo()
            .then(info => {
              if (info && info.current_project_path) {
                // Set the input value to the project path
                input.value = info.current_project_path;
                console.log('*** Set save_dir default to:', info.current_project_path);
                
                // Also update our stored options
                if (currentOptionValues) {
                  currentOptionValues[option.name] = info.current_project_path;
                }
              }
            })
            .catch(error => console.error('Error fetching project info:', error));
        }
        
        // Add error message container
        const errorMessage = document.createElement('div');
        errorMessage.id = `error-${option.name}`;
        errorMessage.className = 'error-message';
        errorMessage.style.display = 'none';
        formGroup.appendChild(errorMessage);
        
        // Add required attribute if specified
        if (option.required) {
          input.dataset.required = 'true';
          
          // Add input validation event
          input.addEventListener('change', () => {
            validateInput(input, errorMessage, option);
          });
          
          input.addEventListener('blur', () => {
            validateInput(input, errorMessage, option);
          });
        }
        
        // Add the form group to the container
        dialogOptionsContainer.appendChild(formGroup);
      } catch (optionError) {
        // Handle errors for individual options
        console.error(`Error creating option ${option.name}:`, optionError);
        
        // Add an error message to the form
        const errorElement = document.createElement('div');
        errorElement.style.color = 'red';
        errorElement.textContent = `Error loading option ${option.name}: ${optionError.message}`;
        dialogOptionsContainer.appendChild(errorElement);
      }
    });
  } catch (formError) {
    // Handle overall form generation errors
    console.error("Error generating options form:", formError);
    
    // Clear and show error
    dialogOptionsContainer.innerHTML = '';
    const errorMessage = document.createElement('p');
    errorMessage.style.color = 'red';
    errorMessage.textContent = `Failed to create options form: ${formError.message}`;
    dialogOptionsContainer.appendChild(errorMessage);
  }
}

function validateInput(input, errorElement, option) {
  if (option.required && !input.value.trim()) {
    errorElement.textContent = 'This field is required';
    errorElement.style.display = 'block';
    return false;
  } 
  
  // Add number validation:
  if (option.type === 'number') {
    const value = parseFloat(input.value);
    if (!isNaN(value)) {
      if (option.min !== undefined && value < option.min) {
        errorElement.textContent = `Value must be at least ${option.min}`;
        errorElement.style.display = 'block';
        return false;
      }
      
      if (option.max !== undefined && value > option.max) {
        errorElement.textContent = `Value must be at most ${option.max}`;
        errorElement.style.display = 'block';
        return false;
      }
    }
  }
  
  errorElement.style.display = 'none';
  return true;
}

// Validate the options form
function validateOptionsForm() {
  let isValid = true;
  
  currentToolOptions.forEach(option => {
    if (option.required) {
      const input = document.getElementById(`option-${option.name}`);
      const errorElement = document.getElementById(`error-${option.name}`);
      
      if (!input.value.trim()) {
        errorElement.textContent = 'This field is required';
        errorElement.style.display = 'block';
        isValid = false;
      } else {
        errorElement.style.display = 'none';
      }
    }
  });
  
  return isValid;
}

// Gather all option values from the form
function gatherOptionValues() {
  const values = {};
  
  currentToolOptions.forEach(option => {
    const inputElement = document.getElementById(`option-${option.name}`);
    
    if (inputElement) {
      if (option.type === 'boolean') {
        values[option.name] = inputElement.checked;
      } else if (option.type === 'number') {
        values[option.name] = inputElement.value ? parseFloat(inputElement.value) : '';
      } else {
        values[option.name] = inputElement.value;
      }
    }
  });
  
  return values;
}

// Timer functions
function startTimer() {
  // Update immediately
  updateElapsedTime();
  
  // Then update every second
  timerInterval = setInterval(updateElapsedTime, 1000);
}

function stopTimer() {
  if (timerInterval) {
    clearInterval(timerInterval);
    timerInterval = null;
  }
}

function updateElapsedTime() {
  if (!startTime) return;
  
  const currentTime = Date.now();
  const elapsedMs = currentTime - startTime;
  
  const minutes = Math.floor(elapsedMs / 60000);
  const seconds = Math.floor((elapsedMs % 60000) / 1000);
  
  elapsedTimeElement.textContent = `elapsed: ${minutes}m ${seconds}s`;
}

============================================================
FILE: tool-system.js
SIZE: 51752 bytes
LANGUAGE: JS
============================================================

// tool-system.js
const fs = require('fs');
const path = require('path');

// Basic logging setup that works even if logToFile isn't defined in this context
function safeLog(message) {
  // Log to console first (works in development)
  console.log(message);
  
  // Try to log to file if the function exists in global scope (from main.js)
  if (typeof global.logToFile === 'function') {
    global.logToFile(`[tool-system.js] ${message}`);
  } else {
    // Fallback file logging if needed
    try {
      const fs = require('fs');
      const path = require('path');
      const os = require('os');
      const logPath = path.join(os.homedir(), 'writers-toolkit-debug.log');
      const timestamp = new Date().toISOString();
      const logLine = `${timestamp}: [tool-system.js] ${message}\n`;
      fs.appendFileSync(logPath, logLine);
    } catch (e) {
      // Can't do anything if this fails
    }
  }
}

// Log module loading
safeLog('Module loading started');

// Log require attempts
try {
  safeLog('Loading base modules...');
  const { app } = require('electron');
  safeLog('Base modules loaded successfully');
} catch (error) {
  safeLog(`ERROR loading base modules: ${error.message}`);
}

const GeminiAPIService = require('./client');

const toolRegistry = require('./registry');

function loadToolClass(toolName) {
  const hyphenatedName = toolName.replace(/_/g, '-');
  
  // Get the directory where tool-system.js is located
  const baseDir = __dirname;
  // console.log(`Base directory for tool loading: ${baseDir}`);
  
  // Safe logging that works in any context
  function log(message) {
    // console.log(message);
    if (typeof global.logToFile === 'function') {
      global.logToFile(`[tool-system] ${message}`);
    }
  }
  
  log(`Loading tool: ${toolName} (${hyphenatedName}.js)`);
  log(`Base directory for tool loading: ${baseDir}`);
  
  try {
    // Use path.resolve to get absolute path to the module
    const modulePath = path.resolve(baseDir, `${hyphenatedName}.js`);
    log(`Resolved tool ${toolName} to: ${modulePath}`);
    
    // Check if file exists
    if (fs.existsSync(modulePath)) {
      // log(`File exists at: ${modulePath}`);
      const module = require(modulePath);
      // log(`Successfully loaded module: ${hyphenatedName}.js`);
      return module;
    } else {
      log(`ERROR: Tool file not found at: ${modulePath}`);
      
      // Try an alternative location as a last resort
      const altPath = path.resolve(baseDir, '..', `${hyphenatedName}.js`);
      log(`Trying alternative path: ${altPath}`);
      
      if (fs.existsSync(altPath)) {
        log(`File exists at alternative path: ${altPath}`);
        const module = require(altPath);
        log(`Successfully loaded module from alternative path: ${hyphenatedName}.js`);
        return module;
      }
      
      throw new Error(`Tool file not found: ${hyphenatedName}.js`);
    }
  } catch (error) {
    log(`ERROR loading tool ${toolName}: ${error.message}`);
    log(`Stack trace: ${error.stack}`);
    throw error;
  }
}

// AI based tools:
const TokensWordsCounter = loadToolClass('tokens-words-counter');
const ManuscriptToOutlineCharactersWorld = loadToolClass('manuscript-to-outline-characters-world');
const NarrativeIntegrity = loadToolClass('narrative-integrity');
const DevelopmentalEditing = loadToolClass('developmental-editing');
const LineEditing = loadToolClass('line-editing');
const CopyEditing = loadToolClass('copy_editing');
const ProofreaderMechanical = loadToolClass('proofreader-mechanical');
const CharacterAnalyzer = loadToolClass('character-analyzer');
const TenseConsistencyChecker = loadToolClass('tense-consistency-checker');
const AdjectiveAdverbOptimizer = loadToolClass('adjective-adverb-optimizer');
const DanglingModifierChecker = loadToolClass('dangling-modifier-checker');
const RhythmAnalyzer = loadToolClass('rhythm-analyzer');
const CrowdingLeapingEvaluator = loadToolClass('crowding-leaping-evaluator');
const PunctuationAuditor = loadToolClass('punctuation-auditor');
const ConflictAnalyzer = loadToolClass('conflict-analyzer');
const ForeshadowingTracker = loadToolClass('foreshadowing-tracker');
const PlotThreadTracker = loadToolClass('plot-thread-tracker');
const KdpPublishingPrep = loadToolClass('kdp-publishing-prep');
const DrunkClaude = loadToolClass('drunk-claude');
const BrainstormTool = loadToolClass('brainstorm');
const OutlineWriter = loadToolClass('outline-writer');
const WorldWriter = loadToolClass('world-writer');
const ChapterWriter = loadToolClass('chapter-writer');

// non-AI tools:
const DocxComments = loadToolClass('docx-comments');
const EpubConverter = loadToolClass('epub-converter');

const TOOL_DEFS = [
  { id: 'tokens_words_counter', title: `Tokens & Words Counter`, description: `This is a free call to test that your ANTHROPIC_API_KEY is working properly!  Also, use it to count the approximate tokens and words in text files (mostly for manuscript.txt).  This helps to estimate Claude API usage and context window requirements for your writing, and may help with API Settings for larger manuscripts.`, Class: TokensWordsCounter, options: [
    {
      "name": "input_file",
      "label": "Input File",
      "type": "file",
      "description": "Count tokens & words in text file.",
      "required": true,
      "default": "manuscript.txt",
      "filters": [
        {
          "name": "Text Files",
          "extensions": [
            "txt"
          ]
        }
      ]
    }
  ]},
  { id: 'manuscript_to_outline_characters_world', title: `Manuscript.txt to create: outline, characters, and world files`, description: `Works in reverse to create: outline, characters, and world files given a manuscript. May be useful for pantsers, and old manuscript files.`, Class: ManuscriptToOutlineCharactersWorld, options: [
    {
      "name": "manuscript_file",
      "label": "MANUSCRIPT_FILE",
      "type": "file",
      "description": "File containing the manuscript/narrative to use",
      "required": true,
      "default": "manuscript.txt",
      "group": "Input Files"
    }
  ]},
  { id: 'narrative_integrity', title: `Narrative Integrity`, description: `Focused on consistency issues within the entire manuscript, or consistency between the manuscript and the world document and/or the outline.\nThis tool supports various consistency checks: world, internal, development, and unresolved.\nConfigurable options enable targeted analysis of character, setting, timeline, and thematic consistency, producing detailed reports with examples and recommendations for resolving discrepancies.`, Class: NarrativeIntegrity, options: [
    {
      "name": "manuscript_file",
      "label": "MANUSCRIPT_FILE",
      "type": "file",
      "description": "File containing the manuscript/narrative to analyze",
      "required": true,
      "default": "manuscript.txt",
      "group": "Input Files"
    },
    {
      "name": "world_file",
      "label": "world_file",
      "type": "file",
      "description": "File containing the world details (required)",
      "required": false,
      "default": "",
      "group": "Input Files"
    },
    {
      "name": "outline_file",
      "label": "outline_file",
      "type": "file",
      "description": "File containing the story outline (optional)",
      "required": false,
      "default": "",
      "group": "Input Files"
    },
    {
      "name": "check_type",
      "label": "Check Type",
      "type": "select",
      "description": "Select type of integrity check to perform",
      "required": false,
      "default": "internal",
      "group": "Analysis Options",
      "choices": [
        { "value": "world", "label": "World Integrity" },
        { "value": "internal", "label": "Internal Integrity" },
        { "value": "development", "label": "Development Integrity" },
        { "value": "unresolved", "label": "Unresolved Elements" },
        { "value": "all", "label": "All Checks" }
      ]
    }
  ]},
  { id: 'developmental_editing', title: `Developmental Editing`, description: `Performs developmental editing for your manuscript, with all chapter numbers/headers removed.`, Class: DevelopmentalEditing, options: [
    {
      "name": "manuscript_file",
      "label": "Manuscript File",
      "type": "file",
      "description": "Fiction manuscript file to analyze",
      "required": true,
      "default": "manuscript.txt",
      "filters": [
        {
          "name": "Text Files",
          "extensions": [
            "txt"
          ]
        }
      ],
      "group": "Input Files"
    },
    {
      "name": "language",
      "label": "Language",
      "type": "text",
      "description": "Language for proofreading (e.g., English, Spanish, French)",
      "required": false,
      "default": "English",
      "group": "Settings"
    }
  ]},
  { id: 'line_editing', title: `Line Editing`, description: `Performs line editing for a specified chapter in your manuscript, as this can be an intensive task.`, Class: LineEditing, options: [
    {
      "name": "manuscript_file",
      "label": "Manuscript File",
      "type": "file",
      "description": "Fiction manuscript file to analyze",
      "required": true,
      "default": "manuscript.txt",
      "filters": [
        {
          "name": "Text Files",
          "extensions": [
            "txt"
          ]
        }
      ],
      "group": "Input Files"
    },
    {
      "name": "chapter_number",
      "label": "Chapter Number",
      "type": "text",
      "description": "The chapter number to analyze (e.g. '1', '5', '20')",
      "required": true,
      "default": "1",
      "group": "Analysis Options"
    }
  ]},
  { id: 'copy_editing', title: `Copy Editing`, description: `Performs copy editing for an entire manuscript, with all chapter numbers/headers removed.`, Class: CopyEditing, options: [
    {
      "name": "manuscript_file",
      "label": "Manuscript File",
      "type": "file",
      "description": "Fiction manuscript file to analyze",
      "required": true,
      "default": "manuscript.txt",
      "filters": [
        {
          "name": "Text Files",
          "extensions": [
            "txt"
          ]
        }
      ],
      "group": "Input Files"
    },
    {
      "name": "language",
      "label": "Language",
      "type": "text",
      "description": "Language for proofreading (e.g., English, Spanish, French)",
      "required": false,
      "default": "English",
      "group": "Settings"
    }
  ]},
  { id: 'proofreader_mechanical', title: `Proofreader Mechanical`, description: `Performs proofreading for an entire manuscript. Mechanical checks for spelling, typos, punctuation, and grammar.`, Class: ProofreaderMechanical, options: [
    {
      "name": "manuscript_file",
      "label": "Manuscript File",
      "type": "file",
      "description": "Manuscript file to proofread.",
      "required": true,
      "default": "manuscript.txt",
      "filters": [
        {
          "name": "Text Files",
          "extensions": ["txt"]
        }
      ],
      "group": "Input Files"
    },
    {
      "name": "language",
      "label": "Language",
      "type": "text",
      "description": "Language for proofreading (e.g., English, Spanish, French)",
      "required": false,
      "default": "English",
      "group": "Settings"
    }
  ]},
  { id: 'proofreader_plot_consistency', title: `Proofreader Plot Consistency`, description: `Focused solely on plot inconsistencies.`, Class: ProofreaderMechanical, options: [
    {
      "name": "manuscript_file",
      "label": "Manuscript File",
      "type": "file",
      "description": "Manuscript file to proofread.",
      "required": true,
      "default": "manuscript.txt",
      "filters": [
        {
          "name": "Text Files",
          "extensions": ["txt"]
        }
      ],
      "group": "Input Files"
    },
    {
      "name": "language",
      "label": "Language",
      "type": "text",
      "description": "Language for proofreading (e.g., English, Spanish, French)",
      "required": false,
      "default": "English",
      "group": "Settings"
    }
  ]},
  { id: 'plot_thread_tracker', title: `Plot Thread Tracker`, description: `Manuscript analysis utility for identifying and tracking distinct plot threads\u2014revealing how they interconnect, converge, and diverge throughout the narrative.\n It uses text-based representations (with optional ASCII art visualization) and supports configurable analysis depth (basic, detailed, or comprehensive) to produce detailed reports with progression maps, thread connections, and narrative assessments, including manuscript excerpts and recommendations for strengthening the plot architecture.`, Class: PlotThreadTracker, options: [
    {
      "name": "manuscript_file",
      "label": "MANUSCRIPT_FILE",
      "type": "file",
      "description": "File containing the manuscript to analyze",
      "required": true,
      "default": "manuscript.txt",
      "group": "Input Files"
    },
    {
      "name": "outline_file",
      "label": "outline_file",
      "type": "file",
      "description": "File containing the story outline (optional)",
      "required": false,
      "default": "",
      "group": "Input Files"
    },
    {
      "name": "ascii_art",
      "label": "ascii_art",
      "type": "boolean",
      "description": "Include simple ASCII art visualization in the output",
      "required": false,
      "default": false,
      "group": "Output Configuration"
    },
    {
      "name": "analysis_depth",
      "label": "analysis_depth",
      "type": "text",
      "description": "Depth of plot thread analysis to perform (default: comprehensive)",
      "required": false,
      "default": "comprehensive",
      "group": "Analysis Options"
    },
    {
      "name": "thread_focus",
      "label": "thread_focus",
      "type": "text",
      "description": "Optional list of specific plot threads to focus on (e.g., 'romance' 'mystery'). \nAlternative default: [\"romance\", \"mystery\"]",
      "required": false,
      "default": null,
      "group": "Output Configuration"
    }
  ]},
  { id: 'tense_consistency_checker', title: `Tense Consistency Checker`, description: `Examines the manuscript to evaluate verb tense consistency. It identifies shifts between past and present tense that might confuse readers, focusing on unintentional changes in narrative flow. With customizable analysis levels and configurable chapter markers, it generates a detailed report with examples, explanations, and suggestions for improving consistency.`, Class: TenseConsistencyChecker, options: [
    {
      "name": "manuscript_file",
      "label": "MANUSCRIPT_FILE",
      "type": "file",
      "description": "File containing the manuscript to analyze (required)",
      "required": true,
      "default": "manuscript.txt",
      "group": "Input Files"
    },
    {
      "name": "analysis_level",
      "label": "analysis_level",
      "type": "text",
      "description": "Level of tense analysis detail:\nbasic, standard, detailed",
      "required": false,
      "default": "detailed",
      "group": "Analysis Options"
    },
    {
      "name": "chapter_markers",
      "label": "CHAPTER_MARKERS",
      "type": "text",
      "description": "Text that marks the start of chapters (default: 'Chapter')",
      "required": false,
      "default": "Chapter",
      "group": "Analysis Options"
    }
  ]},
  { id: 'character_analyzer', title: `Character Analyzer`, description: `Analyzes manuscript, outline, and world files to identify and compare character appearances. It extracts a master character list that details which files each character appears in, examines consistency across documents, and highlights discrepancies in names, roles, or relationships. The analysis produces a detailed report with sections and recommendations to improve character coherence. This is needed because AI rough draft writing has a tendency to add new characters! AI just loves new characters, especially those that whisper and hear echoes.`, Class: CharacterAnalyzer, options: [
    {
      "name": "manuscript_file",
      "label": "MANUSCRIPT_FILE",
      "type": "file",
      "description": "File containing the manuscript to analyze (required)",
      "required": true,
      "default": "manuscript.txt",
      "group": "Input Files"
    },
    {
      "name": "outline_file",
      "label": "OUTLINE_FILE",
      "type": "file",
      "description": "File containing the story outline (optional)",
      "required": false,
      "default": "",
      "group": "Input Files"
    },
    {
      "name": "world_file",
      "label": "WORLD_FILE",
      "type": "file",
      "description": "File containing the story world/lore information (optional)",
      "required": false,
      "default": "",
      "group": "Input Files"
    }
  ]},
  { id: 'adjective_adverb_optimizer', title: `Adjective Adverb Optimizer`, description: `Analyzes manuscript adjective and adverb usage to pinpoint unnecessary modifiers and overused qualifiers, offering specific suggestions for replacing weak descriptive patterns with stronger verbs and nouns, in line with Ursula K. Le Guin's guidance.`, Class: AdjectiveAdverbOptimizer, options: [
    {
      "name": "manuscript_file",
      "label": "MANUSCRIPT_FILE",
      "type": "file",
      "description": "File containing the manuscript to analyze",
      "required": true,
      "default": "manuscript.txt",
      "group": "Input Files"
    },
    {
      "name": "analysis_level",
      "label": "analysis_level",
      "type": "text",
      "description": "Level of analysis detail (default: standard)\nChoices: basic, standard, detailed",
      "required": false,
      "default": "all",
      "group": "Analysis Options"
    },
    {
      "name": "focus_areas",
      "label": "focus_areas",
      "type": "text",
      "description": "Specific areas to focus analysis on (default: all areas)\nChoices: qualifiers, adverbs, adjectives, imagery",
      "required": false,
      "default": "all",
      "group": "Analysis Options"
    }
  ]},
  { id: 'dangling_modifier_checker', title: `Dangling Modifier Checker`, description: `Manuscript analysis software that detects dangling and misplaced modifiers.\nIt examines text to pinpoint instances where descriptive phrases don\u2019t logically connect to their intended subjects, potentially causing confusion or unintended humor.\nWith customizable analysis level, sensitivity, and specific modifier types, it generates a detailed report complete with examples, explanations, and revision suggestions to enhance clarity and precision.`, Class: DanglingModifierChecker, options: [
    {
      "name": "manuscript_file",
      "label": "Select Manuscript file",
      "type": "file",
      "description": "File containing the manuscript to analyze",
      "required": true,
      "default": "manuscript.txt",
      "group": "Input Files"
    },
    {
      "name": "analysis_level",
      "label": "Select Analysis Level",
      "type": "select",
      "description": "Level of analysis detail (default: all)",
      "required": true,
      "default": "all",
      "group": "Analysis Options",
      "choices": [
        {
          "value": "basic",
          "label": "basic"
        },
        {
          "value": "standard",
          "label": "standard"
        },
        {
          "value": "detailed",
          "label": "detailed"
        },
        {
          "value": "all",
          "label": "all"
        }
      ]
    },
    {
      "name": "modifier_types",
      "label": "Select Modifier Types",
      "type": "select",
      "description": "Specific modifier types to focus on (default: all types)",
      "required": true,
      "default": "all",
      "group": "Analysis Options",
      "choices": [
        {
          "value": "dangling",
          "label": "dangling"
        },
        {
          "value": "misplaced",
          "label": "misplaced"
        },
        {
          "value": "squinting",
          "label": "squinting"
        },
        {
          "value": "limiting",
          "label": "limiting"
        },
        {
          "value": "all",
          "label": "all"
        }
      ]
    },
    {
      "name": "sensitivity",
      "label": "Select Sensitivity Level",
      "type": "select",
      "description": "Sensitivity level for modifier detection (default: medium)",
      "required": true,
      "default": "medium",
      "group": "Analysis Options",
      "choices": [
        {
          "value": "low",
          "label": "low"
        },
        {
          "value": "medium",
          "label": "medium"
        },
        {
          "value": "high",
          "label": "high"
        }
      ]
    }
  ]},
  { id: 'rhythm_analyzer', title: `Rhythm Analyzer`, description: `Manuscript analysis utility for evaluating the rhythm and flow of prose.\nIt measures sentence length variations, detects monotonous patterns, and highlights sections where the writing\u2019s rhythm doesn\u2019t match the intended mood.\n Configurable analysis levels, selectable scene types, and adjustable sensitivity settings allow it to generate a detailed report with examples, explanations, and suggestions for enhancing overall narrative rhythm.`, Class: RhythmAnalyzer, options: [
    {
      "name": "manuscript_file",
      "label": "MANUSCRIPT_FILE",
      "type": "file",
      "description": "File containing the manuscript to analyze",
      "required": true,
      "default": "manuscript.txt",
      "group": "Input Files"
    },
    {
      "name": "analysis_level",
      "label": "analysis_level",
      "type": "text",
      "description": "Level of analysis detail (default: standard)\nChoices: basic, standard, detailed",
      "required": false,
      "default": "all",
      "group": "Analysis Options"
    },
    {
      "name": "scene_types",
      "label": "scene_types",
      "type": "text",
      "description": "Specific scene types to focus analysis on (default: all types)\nChoices: action, dialogue, description, exposition",
      "required": false,
      "default": "all",
      "group": "Analysis Options"
    },
    {
      "name": "rhythm_sensitivity",
      "label": "rhythm_sensitivity",
      "type": "text",
      "description": "Sensitivity level for rhythm analysis (default: medium)\nChoices: low, medium, high",
      "required": false,
      "default": "medium",
      "group": "Analysis Options"
    }
  ]},
  { id: 'crowding_leaping_evaluator', title: `Crowding Leaping Evaluator`, description: `Manuscript pacing evaluator that examines narrative structure for pacing issues.\nIt identifies overly dense sections (crowding) and abrupt transitions or time jumps (leaping) based on concepts inspired by Ursula K. Le Guin.\n With configurable analysis levels and sensitivity settings, it produces a detailed report\u2014including optional text-based visualizations\u2014that offers feedback and suggestions for improving narrative rhythm and clarity.`, Class: CrowdingLeapingEvaluator, options: [
    {
      "name": "manuscript_file",
      "label": "MANUSCRIPT_FILE",
      "type": "file",
      "description": "File containing the manuscript to analyze",
      "required": true,
      "default": "manuscript.txt",
      "group": "Input Files"
    },
    {
      "name": "include_visualization",
      "label": "include_visualization",
      "type": "boolean",
      "description": "Include a text-based visualization of pacing patterns",
      "required": false,
      "default": false,
      "group": "Output Configuration"
    },
    {
      "name": "analysis_level",
      "label": "analysis_level",
      "type": "text",
      "description": "Level of analysis detail (default: standard)\nChoices: basic, standard, detailed",
      "required": false,
      "default": "all",
      "group": "Analysis Options"
    },
    {
      "name": "focus_areas",
      "label": "focus_areas",
      "type": "text",
      "description": "Specific areas to focus on (default: all areas)\nChoices: crowding, leaping, transitions, pacing",
      "required": false,
      "default": "all",
      "group": "Analysis Options"
    },
    {
      "name": "sensitivity",
      "label": "sensitivity",
      "type": "text",
      "description": "Sensitivity level for pattern detection (default: medium)\nChoices: low, medium, high",
      "required": false,
      "default": "all",
      "group": "Analysis Options"
    }
  ]},
  { id: 'punctuation_auditor', title: `Punctuation Auditor`, description: `Manuscript analysis utility focused on evaluating punctuation effectiveness.\nIt detects issues such as run-on sentences, missing commas, and irregular punctuation patterns that may hinder clarity and flow.\nConfigurable analysis levels, strictness settings, and selectable punctuation elements enable it to generate a detailed report with examples, explanations, and recommendations for enhancing punctuation and overall readability.`, Class: PunctuationAuditor, options: [
    {
      "name": "manuscript_file",
      "label": "MANUSCRIPT_FILE",
      "type": "file",
      "description": "File containing the manuscript to analyze",
      "required": true,
      "default": "manuscript.txt",
      "group": "Input Files"
    },
    {
      "name": "analysis_level",
      "label": "analysis_level",
      "type": "text",
      "description": "Level of analysis detail (default: standard)\nChoices: basic, standard, detailed",
      "required": false,
      "default": "all",
      "group": "Analysis Options"
    },
    {
      "name": "elements",
      "label": "elements",
      "type": "text",
      "description": "Specific punctuation elements to focus on (default: all elements)\nChoices: commas, periods, semicolons, dashes, parentheses, colons, run-ons",
      "required": false,
      "default": "all",
      "group": "Analysis Options"
    },
    {
      "name": "strictness",
      "label": "strictness",
      "type": "text",
      "description": "Strictness level for punctuation analysis (default: medium)\nChoices: low, medium, high",
      "required": false,
      "default": "all",
      "group": "Analysis Options"
    }
  ]},
  { id: 'conflict_analyzer', title: `Conflict Analyzer`, description: `Manuscript conflict analysis utility that examines conflict patterns at different narrative levels.\nIt identifies conflict nature, escalation, and resolution at scene, chapter, and arc levels.\nWith customizable analysis levels and selectable conflict types, it produces a detailed report featuring examples, assessments, and recommendations for strengthening narrative tension and coherence.`, Class: ConflictAnalyzer, options: [
    {
      "name": "manuscript_file",
      "label": "MANUSCRIPT_FILE",
      "type": "file",
      "description": "File containing the manuscript to analyze",
      "required": true,
      "default": "manuscript.txt",
      "group": "Input Files"
    },
    {
      "name": "outline_file",
      "label": "outline_file",
      "type": "file",
      "description": "File containing the story outline (optional)",
      "required": false,
      "default": "",
      "group": "Input Files"
    },
    {
      "name": "analysis_level",
      "label": "analysis_level",
      "type": "text",
      "description": "Level of conflict analysis to perform (default: all)\nChoices: scene, chapter, arc, all",
      "required": false,
      "default": "all",
      "group": "Analysis Options"
    },
    {
      "name": "conflict_types",
      "label": "conflict_types",
      "type": "text",
      "description": "Specific conflict types to analyze (default: all main types)\nChoices: internal, interpersonal, environmental, societal, cosmic",
      "required": false,
      "default": "all",
      "group": "Analysis Options"
    }
  ]},
  { id: 'foreshadowing_tracker', title: `Foreshadowing Tracker`, description: `Manuscript analysis utility for identifying foreshadowing elements and tracking their payoffs.\n It pinpoints explicit clues, subtle hints, and Chekhov's Gun elements to evaluate how well narrative setups are resolved.\n With customizable options to select foreshadowing types and organization modes (chronological or by type), it generates detailed reports featuring examples, assessments, and recommendations for fulfilling narrative promises.`, Class: ForeshadowingTracker, options: [
    {
      "name": "manuscript_file",
      "label": "MANUSCRIPT_FILE",
      "type": "file",
      "description": "File containing the manuscript to analyze",
      "required": true,
      "default": "manuscript.txt",
      "group": "Input Files"
    },
    {
      "name": "outline_file",
      "label": "outline_file",
      "type": "file",
      "description": "File containing the story outline (optional)",
      "required": false,
      "default": "",
      "group": "Input Files"
    },
    {
      "name": "chronological",
      "label": "chronological",
      "type": "boolean",
      "description": "Sort foreshadowing elements chronologically rather than by type",
      "required": false,
      "default": false,
      "group": "Output Configuration"
    },
    {
      "name": "foreshadowing_type",
      "label": "foreshadowing_type",
      "type": "text",
      "description": "Type of foreshadowing to analyze (default: all)\nChoices: explicit, implicit, chekhov, all",
      "required": false,
      "default": "all",
      "group": "Analysis Options"
    }
  ]},
  { id: 'kdp_publishing_prep', title: `KDP Publishing Preparation`, description: `Analyzes manuscript in preparation for KDP publishing.`, Class: KdpPublishingPrep, options: [
    {
      "name": "manuscript_file",
      "label": "Manuscript File",
      "type": "file",
      "description": "Your completed manuscript text file (.txt)",
      "required": true,
      "default": "manuscript.txt",
      "group": "Input Files"
    },
    {
      "name": "book_type",
      "label": "Book Type",
      "type": "select",
      "description": "Select the type of book",
      "required": true,
      "default": "fiction",
      "choices": [
        {
          "value": "fiction",
          "label": "Fiction"
        },
        {
          "value": "nonfiction",
          "label": "Non-Fiction"
        }
      ],
      "group": "Book Information"
    },
    {
      "name": "existing_title",
      "label": "Existing Title (Optional)",
      "type": "text",
      "description": "If you already have a title, enter it here for evaluation",
      "required": false,
      "group": "Book Information"
    },
    {
      "name": "title_ideas",
      "label": "Title Ideas/Concepts (Optional)",
      "type": "text",
      "description": "Any title themes or concepts you want incorporated",
      "required": false,
      "group": "Book Information"
    },
    {
      "name": "target_audience",
      "label": "Target Audience (Optional)",
      "type": "text",
      "description": "Describe your intended audience (age group, interests, etc.)",
      "required": false,
      "group": "Book Information"
    },
    {
      "name": "include_html",
      "label": "Include HTML Description",
      "type": "boolean",
      "description": "Generate an HTML-formatted description for KDP",
      "default": true,
      "group": "Output Options"
    }
  ]},
  { id: 'drunk_claude', title: `Drunk Claude`, description: `Claude pretends to be drunk while critiquing your manuscript. Sometimes insightful, other times just an annoying drunk.`, Class: DrunkClaude, options: [
    {
      "name": "manuscript_file",
      "label": "MANUSCRIPT_FILE",
      "type": "file",
      "description": "File containing the manuscript to analyze",
      "required": true,
      "default": "manuscript.txt",
      "group": "Input Files"
    }
  ]},
  { id: 'brainstorm', title: `Brainstorm`, description: `Helps generate initial story ideas, prompts, and creative angles. Appends more ideas to the existing 'ideas.txt' file.`, Class: BrainstormTool, options: [
    {
      "name": "ideas_file",
      "label": "IDEAS_FILE",
      "type": "file",
      "description": "Path to ideas.txt file containing the concept and/or characters",
      "required": true,
      "default": "ideas.txt",
      "group": "Input Files"
    },
    {
      "name": "continue",
      "label": "CONTINUE",
      "type": "boolean",
      "description": "Continue building on existing ideas in the ideas file",
      "required": false,
      "default": false,
      "group": "Operation Mode"
    },
    {
      "name": "lang",
      "label": "LANG",
      "type": "text",
      "description": "Language for writing (default: English)",
      "required": false,
      "default": "English",
      "group": "Content Configuration"
    },
    {
      "name": "title",
      "label": "TITLE",
      "type": "text",
      "description": "Suggested title for the writing (optional)",
      "required": false,
      "default": null,
      "group": "Content Configuration"
    },
    {
      "name": "genre",
      "label": "GENRE",
      "type": "text",
      "description": "Suggested genre for the writing (optional)",
      "required": false,
      "default": null,
      "group": "Content Configuration"
    },
    {
      "name": "num_characters",
      "label": "NUM_CHARACTERS",
      "type": "number",
      "description": "Number of main characters to generate (default: 5)",
      "required": false,
      "default": 5,
      "group": "Content Configuration"
    },
    {
      "name": "worldbuilding_depth",
      "label": "WORLDBUILDING_DEPTH",
      "type": "number",
      "description": "Depth of worldbuilding detail (1-5, where 5 is most detailed) (default: 3)",
      "required": false,
      "default": 3,
      "group": "Content Configuration"
    },
    {
      "name": "character_relationships",
      "label": "CHARACTER_RELATIONSHIPS",
      "type": "boolean",
      "description": "Include detailed character relationships",
      "required": false,
      "default": false,
      "group": "Content Configuration"
    },
    {
      "name": "concept_only",
      "label": "CONCEPT_ONLY",
      "type": "boolean",
      "description": "Generate only the concept file",
      "required": false,
      "default": false,
      "group": "Operation Mode"
    },
    {
      "name": "characters_only",
      "label": "CHARACTERS_ONLY",
      "type": "boolean",
      "description": "Generate only the characters file",
      "required": false,
      "default": false,
      "group": "Operation Mode"
    },
    {
      "name": "allow_new_characters",
      "label": "ALLOW_NEW_CHARACTERS",
      "type": "boolean",
      "description": "Allow creation of new characters not in the ideas file",
      "required": false,
      "default": false,
      "group": "Content Configuration"
    }
  ]},
  { id: 'outline_writer', title: `Outline Writer`, description: `Generates a plot outline from your brainstorming file.  You can provide your own outline skeleton and let the AI fill in details.`, Class: OutlineWriter, options: [
    {
      "name": "premise_file",
      "label": "PREMISE_FILE",
      "type": "file",
      "description": "File containing the story premise (required)",
      "required": true,
      "default": "ideas.txt",
      "group": "Input Files"
    },
    {
      "name": "example_outline",
      "label": "EXAMPLE_OUTLINE",
      "type": "text",
      "description": "Example outline for reference",
      "required": false,
      "default": null,
      "group": "Input Files"
    },
    {
      "name": "concept_file",
      "label": "CONCEPT_FILE",
      "type": "file",
      "description": "File containing detailed concept information (optional)",
      "required": false,
      "default": null,
      "group": "Input Files"
    },
    {
      "name": "characters_file",
      "label": "CHARACTERS_FILE",
      "type": "file",
      "description": "File containing character descriptions (optional)",
      "required": false,
      "default": null,
      "group": "Input Files"
    },
    {
      "name": "sections",
      "label": "SECTIONS",
      "type": "number",
      "description": "Number of main parts/sections in the outline (default: 5)",
      "required": false,
      "default": 5,
      "group": "Output Configuration"
    },
    {
      "name": "chapters",
      "label": "CHAPTERS",
      "type": "number",
      "description": "Number of chapters in the outline (default: 25)",
      "required": false,
      "default": 25,
      "group": "Output Configuration"
    },
    {
      "name": "lang",
      "label": "LANG",
      "type": "text",
      "description": "Language for writing (default: English)",
      "required": false,
      "default": "English",
      "group": "Output Configuration"
    },
    {
      "name": "title",
      "label": "TITLE",
      "type": "text",
      "description": "Suggested title for the novel (optional)",
      "required": false,
      "default": null,
      "group": "Output Configuration"
    },
    {
      "name": "genre",
      "label": "GENRE",
      "type": "text",
      "description": "Suggested genre for the novel (optional)",
      "required": false,
      "default": null,
      "group": "Output Configuration"
    },
    {
      "name": "detailed",
      "label": "DETAILED",
      "type": "boolean",
      "description": "Generate a more detailed outline with chapter summaries",
      "required": false,
      "default": false,
      "group": "Output Configuration"
    }
  ]},
  { id: 'world_writer', title: `World Writer`, description: `Extract and develop characters and world elements from a novel outline.  It requires: title, POV, and characters.txt and outline.txt.`, Class: WorldWriter, options: [
    {
      "name": "lang",
      "label": "LANG",
      "type": "text",
      "description": "Language for writing (default: English)",
      "required": false,
      "default": "English",
      "group": "Content Configuration"
    },
    {
      "name": "title",
      "label": "TITLE",
      "type": "text",
      "description": "Title of story",
      "required": true,
      "default": "",
      "group": "Content Configuration"
    },
    {
      "name": "pov",
      "label": "POV",
      "type": "text",
      "description": "Point of view",
      "required": true,
      "default": "third person perspective",
      "group": "Content Configuration"
    },
    {
      "name": "characters_file",
      "label": "CHARACTERS_FILE",
      "type": "file",
      "description": "Characters",
      "required": true,
      "default": "characters.txt",
      "group": "Input Files"
    },
    {
      "name": "outline_file",
      "label": "OUTLINE_FILE",
      "type": "file",
      "description": "Path to the outline file generated by outline_writer.py",
      "required": true,
      "default": null,
      "group": "Input Files"
    },
    {
      "name": "detailed",
      "label": "DETAILED",
      "type": "boolean",
      "description": "Generate more detailed character and world profiles",
      "required": false,
      "default": false,
      "group": "Content Configuration"
    }
  ]},
  { id: 'chapter_writer', title: `Chapter Writer`, description: `Uses the outline, chapters list, world document, and any existing manuscript to write rough draft chapters`, Class: ChapterWriter, options: [
    {
      "name": "chapters_to_write",
      "label": "chapters_to_write",
      "type": "file",
      "description": "Path to a file containing a list of chapters to write sequentially, and the format is \"9. Chapter Title\" per line. \nIt may contain one or more chapters. \nIt must match the chapter format in the outline.",
      "required": false,
      "default": "chapters.txt",
      "group": "Input Files"
    },
    {
      "name": "manuscript",
      "label": "manuscript",
      "type": "file",
      "description": "Path to manuscript file",
      "required": true,
      "default": "manuscript.txt",
      "group": "Input Files"
    },
    {
      "name": "outline",
      "label": "outline",
      "type": "file",
      "description": "Path to outline file",
      "required": true,
      "default": "outline.txt",
      "group": "Input Files"
    },
    {
      "name": "world",
      "label": "world",
      "type": "file",
      "description": "Path to world file",
      "required": false,
      "default": "",
      "group": "Input Files"
    },
    {
      "name": "lang",
      "label": "lang",
      "type": "text",
      "description": "Language for writing",
      "required": false,
      "default": "English",
      "group": "Input Files"
    },
    {
      "name": "chapter_delay",
      "label": "chapter_delay",
      "type": "number",
      "description": "Delay in seconds between processing multiple chapters (default: 15 seconds)",
      "required": false,
      "default": 15,
      "group": "Input Files"
    },
    {
      "name": "no_dialogue_emphasis",
      "label": "no_dialogue_emphasis",
      "type": "boolean",
      "description": "Turn off the additional dialogue emphasis (dialogue emphasis is ON by default)",
      "required": false,
      "default": true,
      "group": "Input Files"
    },
    {
      "name": "no_append",
      "label": "no_append",
      "type": "boolean",
      "description": "Disable auto-appending new chapters to manuscript file",
      "required": false,
      "default": false,
      "group": "Input Files"
    },
    {
      "name": "backup",
      "label": "backup",
      "type": "boolean",
      "description": "Create backup of manuscript file before appending (default: False)",
      "required": false,
      "default": false,
      "group": "Output Configuration"
    },
    {
      "name": "show_token_stats",
      "label": "show_token_stats",
      "type": "boolean",
      "description": "Show tokens stats but do not call API\nYou just want to double check the settings/numbers.",
      "required": false,
      "default": false,
      "group": "Claude API Configuration"
    },
    {
      "name": "request",
      "label": "request",
      "type": "text",
      "description": "Single chapter format: \"Chapter 9: Title\"   or  \"9: Title\"   or  \"9. Title\"",
      "required": false,
      "default": null,
      "group": "Input Files"
    }
  ]},
  { id: 'docx_comments', title: 'DOCX Text/Comments Extractor', description: 'Extracts comments and associated text from DOCX files and saves them to a text file', Class: DocxComments, options: [
      {
        "name": "docx_file",
        "label": "DOCX File",
        "type": "file",
        "description": "Word document file containing comments to extract and match to text",
        "required": true,
        "default": "",
        "filters": [
          {
            "name": "DOCX Files",
            "extensions": ["docx"]
          }
        ],
        "group": "Input Files"
      }
  ]},
  { id: 'epub_converter', title: 'EPUB to TXT Converter', description: 'Converts EPUB files to plain text format while preserving structure', Class: EpubConverter, options: [
      {
        "name": "epub_file",
        "label": "EPUB File",
        "type": "file",
        "description": "EPUB file to convert to plain text",
        "required": true,
        "filters": [
          {
            "name": "EPUB Files",
            "extensions": ["epub"]
          }
        ]
      }
  ]}
];

module.exports = TOOL_DEFS;


function getAbsoluteToolPath(toolName) {
  // Convert name variations (with underscore or hyphen)
  const hyphenatedName = toolName.replace(/_/g, '-');
  
  // Build possible paths at root level
  const possiblePaths = [
    `./${toolName}.js`,
    `./${hyphenatedName}.js`
  ];
  
  // Log paths for debugging
  console.log(`Possible paths for tool ${toolName}:`);
  possiblePaths.forEach(p => console.log(` - ${p}`));
  
  // Return all possible paths to try
  return possiblePaths;
}

function getToolPath(toolName) {
  try {
    // Get the app path
    const appPath = app.getAppPath();
    console.log(`App path: ${appPath}`);
    
    // Check if running from asar archive
    if (appPath.includes('.asar')) {
      // For unpacked files, we need to use .asar.unpacked path
      const unpackedPath = appPath.replace('.asar', '.asar.unpacked');
      const toolUnpackedPath = path.join(unpackedPath, 'src', 'tools', `${toolName}.js`);
      
      const fs = require('fs');
      if (fs.existsSync(toolUnpackedPath)) {
        console.log(`Found tool at: ${toolUnpackedPath}`);
        return toolUnpackedPath;
      }
      
      // Try with hyphens instead of underscores (tokens-words-counter vs tokens_words_counter)
      const hyphenatedName = toolName.replace(/_/g, '-');
      const hyphenatedPath = path.join(unpackedPath, 'src', 'tools', `${hyphenatedName}.js`);
      
      if (fs.existsSync(hyphenatedPath)) {
        console.log(`Found tool with hyphenated name at: ${hyphenatedPath}`);
        return hyphenatedPath;
      }
      
      console.warn(`Tool not found at unpacked path: ${toolUnpackedPath}`);
    }
    
    // Development fallback
    return `./tools/${toolName}`;
  } catch (error) {
    console.error(`Error resolving path for tool ${toolName}:`, error);
    return `./tools/${toolName}`;
  }
}

async function initializeToolSystem(settings) {
  console.log('Initializing tool system...');
  
  if (typeof global.logToFile === 'function') {
    global.logToFile('[tool-system] Starting tool system initialization');
  }
  
  try {
    // Create AI API service with the provided settings
    const geminiAPIService = new GeminiAPIService(settings);
    console.log('Created GeminiAPIService instance');
    
    // Define which tools are non-AI and don't need AI API service
    const nonAiToolIds = ['docx_comments', 'epub_converter'];
    
    // Register each tool with proper configuration
    let toolCount = 0;
    TOOL_DEFS.forEach(def => {
      if (typeof global.logToFile === 'function') {
        global.logToFile(`[tool-system] Registering tool #${toolCount + 1}: ${def.id}`);
      }
      
      // Create tool config with all properties from definition
      const toolConfig = {
        name: def.id,
        title: def.title,
        description: def.description,
        options: def.options || [],
        ...settings
      };
      
      console.log(`Creating instance of tool: ${def.id}`);
      
      // Create tool instance
      let instance;
      
      // Check if this is a non-AI tool
      if (nonAiToolIds.includes(def.id)) {
        // Non-AI tools don't get AI API service
        instance = new def.Class(def.id, toolConfig);
        console.log(`Initialized non-AI tool ${def.id} without AI API service`);
      } else {
        // AI tools get AI API service as first parameter
        console.log(`Passing GeminiAPIService to AI tool ${def.id}`);
        instance = new def.Class(GeminiAPIService, toolConfig);
        
        // Verify the service was stored
        console.log(`Tool ${def.id} has GeminiAPIService: ${!!instance.GeminiAPIService}`);
        
        // If the tool doesn't properly store GeminiAPIService, add it here
        if (!instance.GeminiAPIService) {
          console.log(`Manually setting GeminiAPIService for tool ${def.id}`);
          instance.GeminiAPIService = GeminiAPIService;
        }
        
        console.log(`Initialized AI tool ${def.id} with AI API service`);
      }
      
      // Add to registry
      toolRegistry.registerTool(def.id, instance);
      
      // Verify the tool in registry
      const registeredTool = toolRegistry.getTool(def.id);
      console.log(`Verified tool ${def.id} in registry has GeminiAPIService: ${!!registeredTool.GeminiAPIService}`);
      
      toolCount++;
    });
    
    // Log registration summary
    const allTools = toolRegistry.getAllToolIds();
    // console.log(`Registered ${allTools.length} built-in tools:`, allTools);
    
    return { GeminiAPIService, toolRegistry };
  } catch (error) {
    console.error(`[tool-system] ERROR during initialization: ${error.message}`);
    throw error;
  }
}

/**
 * Execute a tool by ID
 * @param {string} toolId - Tool ID
 * @param {Object} options - Tool options
 * @returns {Promise<Object>} - Tool execution result
 */
async function executeToolById(toolId, options) {
  console.log(`Executing tool: ${toolId} with options:`, options);
  
  // Get the tool implementation
  const tool = toolRegistry.getTool(toolId);
  
  if (!tool) {
    console.error(`Tool not found: ${toolId}`);
    throw new Error(`Tool not found: ${toolId}`);
  }
  
  // Store the original GeminiAPIService in case we need to restore it
  const originalGeminiAPIService = tool.GeminiAPIService;
  
  try {
    console.log('*** Client before recreate:', !!tool.GeminiAPIService?.client);
    
    // Only try to recreate if tool has a GeminiAPIService
    if (tool.GeminiAPIService && typeof tool.GeminiAPIService.recreate === 'function') {
      tool.GeminiAPIService.recreate();
    } else {
      console.log(`Tool ${toolId} does not have a valid AI API service (has GeminiAPIService: ${!!tool.GeminiAPIService})`);
    }
    
    console.log('*** Client after recreate:', !!tool.GeminiAPIService?.client);
    
    // Execute the tool
    console.log(`Starting execution of tool: ${toolId}`);
    const result = await tool.execute(options);
    console.log(`Tool execution complete: ${toolId}`);
    
    // Close the client after successful execution
    if (tool.GeminiAPIService && typeof tool.GeminiAPIService.close === 'function') {
      try {
        tool.GeminiAPIService.close();
      } catch (error) {
        console.warn(`Error closing AI API service for tool ${toolId}:`, error);
      } finally {
        // Don't set to null here - this might be causing the problem!
        // tool.GeminiAPIService = null;
      }
    }
    
    return result;
  } catch (error) {
    console.error(`Error executing tool ${toolId}:`, error);
    
    // Ensure the client is closed even if execution fails
    if (tool && tool.GeminiAPIService && typeof tool.GeminiAPIService.close === 'function') {
      try {
        tool.GeminiAPIService.close();
      } catch (closeError) {
        console.warn(`Error closing AI API service after execution error:`, closeError);
      } finally {
        // Don't set to null here either
        // tool.GeminiAPIService = null;
      }
    }
    
    throw error;
  }
}

/**
 * Reinitialize the AI API API service with updated settings
 * @param {Object} settings - AI API settings
 * @returns {Object} - New AI API service instance
 */
// In tool-system.js, update the reinitializeGeminiAPIService function (around line 1559):

/**
 * Reinitialize the AI API service with updated settings
 * @param {Object} settings - AI API settings
 * @returns {Object} - New AI API service instance
 */
function reinitializeGeminiAPIService(settings) {
  // Create a new AI API service with the updated settings
  const GeminiAPIService = new GeminiAPIService(settings);
  
  // Update the service in all registered tools
  for (const toolId of toolRegistry.getAllToolIds()) {
    const tool = toolRegistry.getTool(toolId);
    
    // Close any existing client first
    if (tool.GeminiAPIService) {
      try {
        tool.GeminiAPIService.close();
      } catch (error) {
        console.warn(`Error closing AI API service during reinitialization:`, error);
      } finally {
        tool.GeminiAPIService = null;  // This ALWAYS happens
      }
    }
    
    tool.GeminiAPIService = GeminiAPIService;
  }
  
  return GeminiAPIService;
}

module.exports = {
  initializeToolSystem,
  executeToolById,
  reinitializeGeminiAPIService,
  toolRegistry
};


============================================================
FILE: upload_gemini25.js
SIZE: 14386 bytes
LANGUAGE: JS
============================================================

const { GoogleGenAI, HarmCategory, HarmBlockThreshold } = require('@google/genai');
const fs = require('fs');
const path = require('path');

async function main() {
  const apiKeyFromEnv = process.env.GEMINI_API_KEY;
  if (!apiKeyFromEnv) {
    console.error("ERROR: GEMINI_API_KEY environment variable is not set.");
    process.exit(1);
  }

  const ai = new GoogleGenAI({ apiKey: apiKeyFromEnv });

  const manuscriptFilePath = 'manuscript.txt';
  let manuscriptContent = ''; // For size log

  try {
    if (!fs.existsSync(manuscriptFilePath)) {
      console.error(`ERROR: Manuscript file not found at: ${manuscriptFilePath}`);
      process.exit(1);
    }
    manuscriptContent = fs.readFileSync(manuscriptFilePath, 'utf8');
    console.log(`Successfully read content from ${manuscriptFilePath} (Size: ${Buffer.byteLength(manuscriptContent, 'utf8')} bytes).`);
  } catch (fileReadError) {
    console.error(`ERROR: Failed to read file '${manuscriptFilePath}'.`);
    console.error("File read error details:", fileReadError.message);
    process.exit(1);
  }

  let uploadedFileMetadata;
  try {
    console.log(`\n--- Uploading File to Gemini via ai.files.upload: ${manuscriptFilePath} ---`);
    const uploadStartTime = new Date();

    const uploadParams = {
      file: manuscriptFilePath,
      config: {
        mimeType: 'text/plain',
        displayName: `Manuscript: ${path.basename(manuscriptFilePath)}`
      }
    };

    let uploadResponse;

    if (ai.files && typeof ai.files.upload === 'function') {
      console.log("Using ai.files.upload() with params:", JSON.stringify(uploadParams, null, 2));
      uploadResponse = await ai.files.upload(uploadParams);
    } else {
      console.error("CRITICAL ERROR: 'ai.files.upload' is NOT a function on the initialized 'ai' object. Cannot proceed with file upload.");
      process.exit(1);
    }

    if (uploadResponse && uploadResponse.uri && uploadResponse.mimeType) {
      uploadedFileMetadata = uploadResponse;
    } else {
      console.error("ERROR: Uploaded file response from 'ai.files.upload' is not in the expected 'File' object format or is missing 'uri'/'mimeType'.");
      console.error("Received response:", JSON.stringify(uploadResponse, null, 2));
      process.exit(1);
    }

    const uploadEndTime = new Date();
    const uploadDurationMs = uploadEndTime.getTime() - uploadStartTime.getTime();
    console.log(`File uploaded successfully via ai.files in ${(uploadDurationMs / 1000).toFixed(2)} seconds.`);
    console.log(`Uploaded File URI: ${uploadedFileMetadata.uri}`);
    console.log(`Uploaded File MIME Type: ${uploadedFileMetadata.mimeType}`);
    if (uploadedFileMetadata.name) console.log(`Uploaded File Name (ID): ${uploadedFileMetadata.name}`);
    if (uploadedFileMetadata.displayName) console.log(`Uploaded File Display Name: ${uploadedFileMetadata.displayName}`);
    if (uploadedFileMetadata.sizeBytes) console.log(`Uploaded File Size (from API): ${uploadedFileMetadata.sizeBytes} bytes`);
    console.log(`--- End of File Upload ---`);

  } catch (uploadError) {
    console.error(`\nERROR: Failed to upload file '${manuscriptFilePath}' to Gemini via ai.files.`);
    console.error("File upload error details:", uploadError.message);
    if (uploadError.stack) console.error("Stack:", uploadError.stack);
    if (uploadError.response && uploadError.response.data) {
        console.error("API Error Data:", JSON.stringify(uploadError.response.data, null, 2));
    } else if (uploadError.cause) {
        console.error("Cause:", uploadError.cause);
    }
    process.exit(1);
  }

  const modelName = 'gemini-2.5-pro-preview-05-06';
  const generationConfiguration = {
    responseMimeType: 'text/plain',
  };

  const contentsForRequest = [ /* ... same as before ... */
    {
      role: 'user',
      parts: [
        {
          fileData: {
            mimeType: uploadedFileMetadata.mimeType,
            fileUri: uploadedFileMetadata.uri,
          },
        },
        {
          text: `\n\n---\nINSTRUCTIONS:\nYour responses must be in PLAIN TEXT ONLY.
ABSOLUTELY DO NOT use any Markdown formatting (such as **, *, #, lists with -, etc.) in any part of your response.

You will proofread the creative fiction manuscript provided above the '--- INSTRUCTIONS:' line (which is now an uploaded file).
Focus ONLY on grammar, spelling, and punctuation issues.

DO NOT include any introductory or concluding remarks (e.g., "Okay, here's a proofread...", "Overall, the manuscript is...").
DO NOT repeat any parts of the manuscript that are correct or do not have issues.
Your response should ONLY consist of the identified issues, formatted as follows for EACH issue found:

Original: [The complete original sentence from the manuscript with the error, exactly as it appears, with no extra quotation marks added by you around the sentence itself.]
Issue(s): [A brief description of the specific grammar, spelling, or punctuation problem(s) in that sentence.]
Correction: [The complete corrected sentence.]

After each "Correction:", add two newlines before presenting the "Original:" of the next identified issue.

For example, if the manuscript contained these lines:
Its a lovely day. The dog runned fast. See the cat.

Your response should be formatted exactly like this:

Original: Its a lovely day.
Issue(s): Spelling - "Its" should be "It's" (contraction of "it is" or "it has").
Correction: It's a lovely day.


Original: The dog runned fast.
Issue(s): Grammar - Incorrect past tense of "run".
Correction: The dog ran fast.

Now, please provide the proofread for the manuscript above using this exact format.
`,
        },
      ],
    }
  ];


  const instructionsTextForLogging = contentsForRequest[0].parts[1].text;
  console.log(`\n--- Sending Prompt to Model (${modelName}) ---`);
  console.log("(Prompt references the uploaded manuscript file)");
  console.log(`Instructions Sent to Model:\n${instructionsTextForLogging}`);
  console.log(`--- End of Instructions Sent ---`);

  let timerInterval;

  try {
    if (!(ai.models && typeof ai.models.generateContentStream === 'function')) {
      console.error("CRITICAL ERROR: 'ai.models.generateContentStream' is NOT a function.");
      process.exit(1);
    }

    const apiCallStartTime = new Date();
    console.log(`\nAPI Call Start Time: ${apiCallStartTime.toLocaleTimeString()}\n`);
    process.stdout.write("elapsed: 0m 0s");
    const updateTimer = () => {
      const now = new Date();
      const elapsedMs = now.getTime() - apiCallStartTime.getTime();
      const totalSeconds = Math.floor(elapsedMs / 1000);
      const minutes = Math.floor(totalSeconds / 60);
      const seconds = totalSeconds % 60;
      process.stdout.cursorTo(0);
      process.stdout.clearLine(0);
      process.stdout.write(`elapsed: ${minutes}m ${seconds}s`);
    };
    timerInterval = setInterval(updateTimer, 1000);

    let lastUsageMetadata = null;
    const responseStream = await ai.models.generateContentStream({
      model: modelName,
      contents: contentsForRequest,
      generationConfig: generationConfiguration,
      safetySettings: [
        { category: HarmCategory.HARM_CATEGORY_HARASSMENT, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE },
        { category: HarmCategory.HARM_CATEGORY_HATE_SPEECH, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE },
        { category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE },
        { category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE },
      ],
    });

    clearInterval(timerInterval);
    process.stdout.write('\n');

    const callEndTime = new Date();
    console.log(`\nAPI Call End Time (stream initiated): ${callEndTime.toLocaleTimeString()}\n`);
    const durationMs = callEndTime.getTime() - apiCallStartTime.getTime();
    const durationSeconds = durationMs / 1000;
    const displayTotalSeconds = Math.floor(durationSeconds);
    const displayMinutes = Math.floor(displayTotalSeconds / 60);
    const displayRemainingSeconds = displayTotalSeconds % 60;
    console.log(`Time to initiate stream: ${displayMinutes}m ${displayRemainingSeconds}s`);

    console.log("\nCall to ai.models.generateContentStream has returned, processing stream...");
    console.log("\n--- Gemini Response Stream ---");
    let output = "";
    let chunkCount = 0;
    const streamProcessingStartTime = new Date();

    for await (const chunk of responseStream) {
      chunkCount++;
      if (chunk.usageMetadata) {
        lastUsageMetadata = chunk.usageMetadata;
      }
      // ... (rest of stream processing logic)
      if (chunk && chunk.candidates && chunk.candidates.length > 0 &&
          chunk.candidates[0].content && chunk.candidates[0].content.parts &&
          chunk.candidates[0].content.parts.length > 0 &&
          typeof chunk.candidates[0].content.parts[0].text === 'string') {
        const textContent = chunk.candidates[0].content.parts[0].text;
        output += textContent;
        process.stdout.write(textContent);
      } else if (chunk && chunk.error) {
        console.error(`\nERROR in stream chunk ${chunkCount}:`, JSON.stringify(chunk.error));
        break;
      } else {
        console.warn(`\nSkipping unrecognized or non-text chunk structure in stream (chunk ${chunkCount}):`, JSON.stringify(chunk));
      }
    }
    process.stdout.write('\n');


    if (lastUsageMetadata) {
      console.log(`\n--- Usage Statistics (from last relevant chunk) ---`);
      console.log(`Prompt Token Count: ${lastUsageMetadata.promptTokenCount}`);
      console.log(`Candidates Token Count: ${lastUsageMetadata.candidatesTokenCount}`);
      console.log(`Total Token Count: ${lastUsageMetadata.totalTokenCount}`);
      if (lastUsageMetadata.thoughtsTokenCount !== undefined) {
        console.log(`Thoughts Token Count: ${lastUsageMetadata.thoughtsTokenCount}`);
      }
      console.log(`--- End Usage Statistics ---`);
    } else {
      console.log("\nNo usage metadata was found in the response stream.");
    }

    const streamProcessingEndTime = new Date();
    const streamDurationMs = streamProcessingEndTime.getTime() - streamProcessingStartTime.getTime();
    const streamDurationSeconds = streamDurationMs / 1000;

    if (chunkCount === 0) {
        console.log("WARNING: Stream completed with 0 chunks containing parsable text.");
    }
    console.log(`--- End of Stream (processed ${chunkCount} chunks in ${streamDurationSeconds.toFixed(2)} seconds) ---`);

    const totalEndTime = new Date();
    const totalDurationMs = totalEndTime.getTime() - apiCallStartTime.getTime();
    const totalDurationSeconds = totalDurationMs / 1000;
    const wholeSeconds = Math.floor(totalDurationSeconds);
    console.log(`\nTotal operation time (API call + stream processing): ${Math.floor(wholeSeconds / 60)}m ${wholeSeconds % 60}s.`);

  } catch (error) {
    if (timerInterval) {
        clearInterval(timerInterval);
        process.stdout.write('\n');
    }
    console.error("\nERROR during 'ai.models.generateContentStream' call or stream processing:");
    console.error("Error message:", error.message);
    if (error.stack) console.error("Stack:", error.stack);
    if (error.cause) console.error("Cause:", error.cause);
    if (error.response) {
        console.error("API Response (if available from error object):", JSON.stringify(error.response, null, 2));
    }
  } finally {
    // if (uploadedFileMetadata && uploadedFileMetadata.name) {
    //   console.log(`\n--- Attempting to delete uploaded file: ${uploadedFileMetadata.name} ---`);
    //   try {
    //     if (ai.files && typeof ai.files.delete === 'function') {
    //       const deleteParams = { name: uploadedFileMetadata.name };
    //       console.log("Calling ai.files.delete() with params:", JSON.stringify(deleteParams));
    //       await ai.files.delete(deleteParams);
    //       console.log(`File ${uploadedFileMetadata.name} deleted successfully.`);
    //     } else {
    //       console.warn("WARN: 'ai.files.delete' is not a function. Cannot delete uploaded file.");
    //     }
    //   } catch (deleteError) {
    //     console.error(`ERROR: Failed to delete file '${uploadedFileMetadata.name}'.`);
    //     console.error("File deletion error details:", deleteError.message);
    //     if (deleteError.stack) console.error("Deletion Stack:", deleteError.stack);
    //   }
    //   console.log(`--- End of File Deletion Attempt ---`);
    // }

    // --- NEW: List files at the very end ---
    console.log(`\n--- Listing all project files (after potential deletion) ---`);
    try {
      if (ai.files && typeof ai.files.list === 'function') {
        // The example shows using a 'config' object for pageSize, but it's optional for default listing
        // const listParams = { config: { 'pageSize': 10 } }; // Optional: for pagination control
        const listParams = {}; // Default parameters (lists all, with default page size)
        console.log("Calling ai.files.list() with params:", JSON.stringify(listParams));
        const listResponsePager = await ai.files.list(listParams); // Returns a Pager<File>

        let filesFound = false;
        // The Pager object needs to be iterated using `for await...of`
        for await (const file of listResponsePager) {
          filesFound = true;
          console.log(`  - Name: ${file.name}, DisplayName: ${file.displayName || 'N/A'}, URI: ${file.uri}, Size: ${file.sizeBytes || 'N/A'} bytes, MIME: ${file.mimeType}`);
        }
        if (!filesFound) {
          console.log("  No files found for this project.");
        }
      } else {
        console.warn("WARN: 'ai.files.list' is not a function. Cannot list project files.");
      }
    } catch (listError) {
      console.error(`ERROR: Failed to list project files.`);
      console.error("File listing error details:", listError.message);
      if (listError.stack) console.error("Listing Stack:", listError.stack);
    }
    console.log(`--- End of File Listing ---`);
    // --- END NEW ---
  }
}

main().catch(error => {
  console.error("\n--- A FATAL UNHANDLED ERROR OCCURRED IN main() ---");
  console.error("Error message:", error.message);
  if (error.stack) console.error("Stack trace:", error.stack);
  if (error.cause) console.error("Cause:", error.cause);
  process.exit(1);
});

============================================================
FILE: world-writer.js
SIZE: 15532 bytes
LANGUAGE: JS
============================================================

// world-writer.js
const BaseTool = require('./base-tool');
const path = require('path');
const fileCache = require('./file-cache');
const appState = require('./state.js');
const fs = require('fs/promises');

/**
 * WorldWriter Tool
 * Extract and develop characters and world elements from a novel outline.
 * It requires: title, POV, and characters.txt and outline.txt.
 */
class WorldWriter extends BaseTool {
  /**
   * Constructor
   * @param {Object} GeminiAPIService - Claude API service
   * @param {Object} config - Tool configuration
   */
  constructor(GeminiAPIService, config = {}) {
    super('world_writer', config);
    this.GeminiAPIService = GeminiAPIService;
    // console.log('WorldWriter Tool initialized with config:', config);
  }
  
  /**
   * Execute the tool
   * @param {Object} options - Tool options
   * @returns {Promise<Object>} - Execution result
   */
  async execute(options) {
    console.log('Executing WorldWriter with options:', options);
    
    // Clear the cache for this tool
    const toolName = 'world_writer';
    fileCache.clear(toolName);
    
    // Extract options
    const title = options.title;
    const pov = options.pov;
    const charactersFile = options.characters_file;
    const outlineFile = options.outline_file;
    const language = options.lang || 'English';
    const detailed = options.detailed || false;
    
    const saveDir = options.save_dir || appState.CURRENT_PROJECT_PATH;
    const outputFiles = [];
    
    // Validate save directory
    if (!saveDir) {
      const errorMsg = 'Error: No save directory specified and no current project selected.\n' +
                      'Please select a project or specify a save directory.';
      this.emitOutput(errorMsg);
      throw new Error('No save directory available');
    }
    
    // Validate required fields
    if (!title) {
      const errorMsg = 'Error: Title is required.\n';
      this.emitOutput(errorMsg);
      throw new Error('Title is required');
    }
    
    if (!pov) {
      const errorMsg = 'Error: Point of view (pov) is required.\n';
      this.emitOutput(errorMsg);
      throw new Error('Point of view is required');
    }
    
    try {
      // Read characters file (required)
      this.emitOutput(`Reading characters file: ${charactersFile}\n`);
      const charactersContent = await this.readInputFile(this.ensureAbsolutePath(charactersFile, saveDir));
      
      // Read outline file (required)
      this.emitOutput(`Reading outline file: ${outlineFile}\n`);
      const outlineContent = await this.readInputFile(this.ensureAbsolutePath(outlineFile, saveDir));
      
      // Create prompt
      const prompt = this.createPrompt(
        title,
        pov,
        charactersContent,
        outlineContent,
        language,
        detailed
      );
      
      // Count tokens in prompt
      this.emitOutput(`Counting tokens in prompt...\n`);
      const promptTokens = await this.GeminiAPIService.countTokens(prompt);
      
      // Calculate available tokens after prompt
      const contextWindow = this.config.context_window || 200000;
      const desiredOutputTokens = this.config.desired_output_tokens || 12000;
      const configuredThinkingBudget = this.config.thinking_budget_tokens || 32000;
      
      const availableTokens = contextWindow - promptTokens;
      
      // For API call, max_tokens must respect the API limit
      const maxTokens = Math.min(availableTokens, 128000); // Limited by beta feature
      
      // Thinking budget must be LESS than max_tokens to leave room for visible output
      let thinkingBudget = maxTokens - desiredOutputTokens;
      if (thinkingBudget > 32000) {
        this.emitOutput("Warning: thinking budget is larger than 32K, set to 32K.\n");
        thinkingBudget = 32000;
      }
      
      // Display token stats
      this.emitOutput(`\nToken stats:\n`);
      this.emitOutput(`Max AI model context window: [${contextWindow}] tokens\n`);
      this.emitOutput(`Input prompt tokens: [${promptTokens}] ...\n`);
      this.emitOutput(`                     = characters + outline + prompt instructions\n`);
      this.emitOutput(`Available tokens: [${availableTokens}]  = ${contextWindow} - ${promptTokens} = context_window - prompt\n`);
      this.emitOutput(`Desired output tokens: [${desiredOutputTokens}]\n`);
      this.emitOutput(`AI model thinking budget: [${thinkingBudget}] tokens  = ${maxTokens} - ${desiredOutputTokens}\n`);
      this.emitOutput(`Max output tokens (max_tokens): [${maxTokens}] tokens  = min(${availableTokens}, 128000)\n`);
      this.emitOutput(`                                = can not exceed: 'betas=["output-128k-2025-02-19"]'\n`);
      
      // Check if prompt is too large for the configured thinking budget
      if (thinkingBudget < configuredThinkingBudget) {
        this.emitOutput(`Error: prompt is too large to have a ${configuredThinkingBudget} thinking budget!\n`);
        this.emitOutput(`Run aborted!\n`);
        throw new Error(`Prompt is too large for ${configuredThinkingBudget} thinking budget - run aborted`);
      }
      
      // Call Claude API with streaming
      this.emitOutput(`\nGenerating world document (including characters) for novel: ${title}\n`);
      this.emitOutput(`Sending request to Claude API (streaming)...\n`);
      
      // Add a message about waiting
      this.emitOutput(`****************************************************************************\n`);
      this.emitOutput(`*  Generating world document with character profiles...\n`);
      this.emitOutput(`*  This process typically takes several minutes.\n`);
      this.emitOutput(`*  \n`);
      this.emitOutput(`*  It's recommended to keep this window the sole 'focus'\n`);
      this.emitOutput(`*  and to avoid browsing online or running other apps, as these API\n`);
      this.emitOutput(`*  network connections are often flakey, like delicate echoes of whispers.\n`);
      this.emitOutput(`*  \n`);
      this.emitOutput(`*  So breathe, remove eye glasses, stretch, relax, and be like water 🥋 🧘🏽‍♀️\n`);
      this.emitOutput(`****************************************************************************\n\n`);
      
      const startTime = Date.now();
      let fullResponse = "";
      let thinkingContent = "";
      
      // Create system prompt to avoid markdown
      const systemPrompt = "NO Markdown! Never respond with Markdown formatting, plain text only.";
      
      try {
        // Use streaming API call
        await this.GeminiAPIService.streamWithThinking(
          prompt,
          {
            model: "claude-3-7-sonnet-20250219",
            system: systemPrompt,
            max_tokens: maxTokens,
            thinking: {
              type: "enabled",
              budget_tokens: thinkingBudget
            },
            betas: ["output-128k-2025-02-19"]
          },
          // Callback for thinking content
          (thinkingDelta) => {
            thinkingContent += thinkingDelta;
          },
          // Callback for response text - simply accumulate without progress indicators
          (textDelta) => {
            fullResponse += textDelta;
          }
        );
      } catch (error) {
        this.emitOutput(`\nAPI Error: ${error.message}\n`);
        throw error;
      }
      
      // Calculate time elapsed
      const elapsed = (Date.now() - startTime) / 1000;
      const minutes = Math.floor(elapsed / 60);
      const seconds = elapsed % 60;
      
      this.emitOutput(`\nWorld document completed in: ${minutes}m ${seconds.toFixed(2)}s.\n`);
      
      // Count words in response
      const wordCount = this.countWords(fullResponse);
      this.emitOutput(`World document has approximately ${wordCount} words.\n`);
      
      // Count tokens in response
      const responseTokens = await this.GeminiAPIService.countTokens(fullResponse);
      this.emitOutput(`World document token count: ${responseTokens}\n`);
      
      // Save the world document to a file
      const timestamp = new Date().toISOString().replace(/[-:.]/g, '').substring(0, 15);
      const worldFilename = `world_${timestamp}.txt`;
      const worldPath = path.join(saveDir, worldFilename);
      
      await this.writeOutputFile(fullResponse, saveDir, worldFilename);
      this.emitOutput(`World document saved to: ${worldPath}\n`);
      
      // Add to output files list
      outputFiles.push(worldPath);
      
      // Add to the file cache
      fileCache.addFile(toolName, worldPath);
      
      // Save thinking content if available and not skipped
      if (thinkingContent) {
        const thinkingFilename = `world_thinking_${timestamp}.txt`;
        
        // Create stats for thinking file
        const stats = `
Stats:
Prompt tokens: ${promptTokens}
Elapsed time: ${minutes} minutes, ${seconds.toFixed(2)} seconds
Word count: ${wordCount}
`;
        
        const thinkingContent2 = `=== PROMPT USED (EXCLUDING REFERENCE CONTENT) ===
Generating world document (including characters) for novel: ${title}

=== AI'S THINKING PROCESS ===

${thinkingContent}

=== END AI'S THINKING PROCESS ===
${stats}

Files saved to: ${saveDir}
###`;
        
        await this.writeOutputFile(thinkingContent2, saveDir, thinkingFilename);
        const thinkingPath = path.join(saveDir, thinkingFilename);
        this.emitOutput(`AI thinking saved to: ${thinkingPath}\n`);
        
        // Add thinking file to output files and cache
        outputFiles.push(thinkingPath);
        fileCache.addFile(toolName, thinkingPath);
      }
      
      this.emitOutput(`\nFiles saved to: ${saveDir}\n`);
      this.emitOutput(`###\n`);
      
      // Return the result
      return {
        success: true,
        outputFiles,
        stats: {
          wordCount,
          tokenCount: responseTokens,
          elapsedTime: `${minutes}m ${seconds.toFixed(2)}s`
        }
      };
      
    } catch (error) {
      console.error('Error in WorldWriter:', error);
      this.emitOutput(`\nError: ${error.message}\n`);
      throw error;
    }
  }
  
  /**
   * Create prompt for world document generation
   * @param {string} title - Novel title
   * @param {string} pov - Point of view
   * @param {string} charactersContent - Characters content
   * @param {string} outlineContent - Outline content
   * @param {string} language - Language
   * @param {boolean} detailed - Whether to generate detailed profiles
   * @returns {string} - Prompt for Claude API
   */
  createPrompt(
    title,
    pov,
    charactersContent,
    outlineContent,
    language,
    detailed
  ) {
    // Start with the basic world prompt
    let prompt = `You are a skilled novelist, worldbuilder, and character developer helping to create a comprehensive world document in fluent, authentic ${language}.
This document will include both the world elements and detailed character profiles for a novel based on the outline below.

=== OUTLINE ===
${outlineContent}
=== END OUTLINE ===

Create a detailed world document with the following sections:

----------------------------------------------
WORLD: ${title}
----------------------------------------------

1. SETTING OVERVIEW:
   - Time period and era
   - General geography and environment
   - Notable locations mentioned in the outline

2. SOCIAL STRUCTURE:
   - Government or ruling systems
   - Social classes or hierarchies
   - Cultural norms and values

3. HISTORY:
   - Major historical events that impact the story
   - Historical figures relevant to the plot
   - Timeline of important developments

4. TECHNOLOGY AND MAGIC:
   - Level of technological development
   - Technological systems or devices crucial to the plot
   - If applicable: magic systems, supernatural elements, or fantastic creatures

5. ECONOMY:
   - Economic systems
   - Resources and trade
   - Economic conflicts relevant to the story

6. THEMES AND SYMBOLS:
   - Recurring motifs and symbols
   - Philosophical or moral questions explored
   - Cultural or religious symbolism

7. RULES OF THE WORLD:
   - Laws (both legal and natural/supernatural)
   - Limitations and constraints
   - Unique aspects of how this world functions

8. CHARACTER PROFILES:
`;

    // Add character profile instructions
    prompt += `
   For each of the following characters, create a detailed profile but do NOT change the character names:

    === CHARACTERS ===
    ${charactersContent}
    === END CHARACTERS ===

   Include for each character:

   a) CHARACTER NAME: [Full name]
   b) ROLE: [Protagonist, Antagonist, Supporting Character, etc.]
   c) AGE: [Age or age range]
   d) PHYSICAL DESCRIPTION: [Detailed physical appearance]
   e) BACKGROUND: [Personal history relevant to the story]
   f) PERSONALITY: [Core personality traits, strengths, and flaws]
   g) MOTIVATIONS: [What drives this character? What do they want?]
   h) CONFLICTS: [Internal struggles and external conflicts]
   i) RELATIONSHIPS: [Important relationships with other characters]
   j) ARC: [How this character changes throughout the story]
   k) NOTABLE QUOTES: [3-5 examples of how this character might speak]`;

    // Add detailed character profile elements if requested
    if (detailed) {
      prompt += `
   l) SKILLS & ABILITIES: [Special skills, knowledge, or supernatural abilities]
   m) HABITS & QUIRKS: [Distinctive behaviors and mannerisms]
   n) SECRETS: [What this character is hiding]
   o) FEARS & WEAKNESSES: [What makes this character vulnerable]
   p) SYMBOLIC ELEMENTS: [Any symbolic elements associated with this character]
   q) NARRATIVE FUNCTION: [How this character serves the themes and plot]
`;
    }

    // Add formatting instructions
    prompt += `
IMPORTANT FORMATTING INSTRUCTIONS:
- Write in ${pov}
- Make the existing character profiles deep and psychologically nuanced
- Ensure the existing character motivations are complex and realistic
- Ensure the existing characters have traits and backgrounds that naturally arise from the world of the story
- Ensure the existing characters will create interesting dynamics and conflicts with each other
- Keep all details consistent with the outline and list of characters
- Focus on elements that directly impact the characters and plot
- Provide enough detail to give the world depth while leaving room for creative development
- Ensure the world elements support and enhance the narrative
- Separate each major section with a line of dashes (------)
- Separate each character profile with a line of dashes (------)
- Be consistent in formatting throughout the document
- Use plain text formatting with NO markdown in your outputs
- Do NOT change nor add to character names
`;

    return prompt;
  }
  
  /**
   * Count words in text
   * @param {string} text - Text to count words in
   * @returns {number} - Word count
   */
  countWords(text) {
    return text.replace(/(\r\n|\r|\n)/g, ' ').split(/\s+/).filter(word => word.length > 0).length;
  }
  
  /**
   * Ensure file path is absolute
   * @param {string} filePath - File path (may be relative or absolute)
   * @param {string} basePath - Base path to prepend for relative paths
   * @returns {string} - Absolute file path
   */
  ensureAbsolutePath(filePath, basePath) {
    if (!filePath) return filePath;
    
    // Check if the path is already absolute
    if (path.isAbsolute(filePath)) {
      return filePath;
    }
    
    // Make the path absolute by joining with the base path
    return path.join(basePath, filePath);
  }
}

module.exports = WorldWriter;

============================================================
FILE: api-settings.html
SIZE: 3503 bytes
LANGUAGE: HTML
============================================================

<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Claude API Settings</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      background-color: #121212;
      color: #ffffff;
      margin: 0;
      padding: 20px;
    }
    
    .container {
      max-width: 600px;
      margin: 0 auto;
    }
    
    h1 {
      font-size: 24px;
      margin-bottom: 20px;
    }
    
    .settings-container {
      margin-bottom: 30px;
      /* This will be populated dynamically */
    }
    
    .setting-group {
      margin-bottom: 20px;
    }
    
    .setting-label {
      display: block;
      margin-bottom: 5px;
      font-size: 14px;
      color: #aaaaaa;
    }
    
    input[type="number"], input[type="text"], select {
      width: 100%;
      padding: 8px;
      margin-bottom: 15px;
      background-color: #2a2a2a;
      color: #ffffff;
      border: 1px solid #333333;
      border-radius: 4px;
      font-size: 16px;
      box-sizing: border-box;
    }
    
    .button-container {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
      margin-top: 20px;
    }
    
    button {
      padding: 8px 20px;
      border: none;
      border-radius: 4px;
      font-size: 14px;
      cursor: pointer;
    }
    
    .cancel-button {
      background-color: transparent;
      color: #aaaaaa;
      border: 1px solid #444444;
    }
    
    .save-button {
      background-color: #4a89dc;
      color: white;
    }
    
    .error-text {
      color: #f44336;
      font-size: 12px;
      margin-top: -10px;
      margin-bottom: 10px;
      display: none;
    }
    
    /* Light mode styles */
    body.light-mode {
      background-color: #f5f5f5;
      color: #222222;
    }
    
    body.light-mode .setting-label {
      color: #666666;
    }
    
    body.light-mode input[type="number"],
    body.light-mode input[type="text"],
    body.light-mode select {
      background-color: #ffffff;
      color: #222222;
      border: 1px solid #cccccc;
    }
    
    body.light-mode .cancel-button {
      color: #666666;
      border: 1px solid #cccccc;
    }
    
    body.light-mode .warning-banner {
      background-color: rgba(220, 53, 69, 0.85);
    }
    
    body.light-mode .setting-description {
      color: #666666 !important;
    }
    
    /* Warning banner for API settings */
    .warning-banner {
      background-color: rgba(220, 53, 69, 0.9);
      color: white;
      padding: 10px 15px;
      border-radius: 4px;
      margin-bottom: 20px;
      font-size: 14px;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .warning-icon {
      font-size: 20px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Claude API Settings</h1>
    
    <div class="warning-banner">
      <span class="warning-icon">⚠️</span>
      <span>Warning: Changing API settings may affect cost and response quality; proceed with caution.</span>
    </div>
    
    <div id="settings-container" class="settings-container">
      <!-- Settings will be dynamically generated here -->
      <div class="loading-message">Loading settings...</div>
    </div>
    
    <div class="button-container">
      <button id="cancel-btn" class="cancel-button">Cancel</button>
      <button id="save-btn" class="save-button">Save</button>
    </div>
  </div>

  <script src="api-settings.js"></script>
</body>
</html>

============================================================
FILE: editor-dialog.html
SIZE: 4837 bytes
LANGUAGE: HTML
============================================================

<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Editor</title>
  <link rel="stylesheet" href="styles.css">
  <style>
    .editor-container {
      height: 100vh;
      display: flex;
      flex-direction: column;
      margin: 0;
      padding: 0;
      overflow: hidden;
    }

    .editor-header {
      display: flex;
      justify-content: flex-end;
      align-items: center;
      padding: 8px;
      border-bottom: 1px solid #333;
    }
    
    .editor-close-btn {
      background: none;
      border: none;
      font-size: 24px;
      cursor: pointer;
      color: #fff;
      padding: 0 5px;
      line-height: 24px;
    }
    
    .editor-body {
      flex: 1;
      overflow: auto;
      padding: 15px;
      display: flex;
      flex-direction: column;
    }

    #editor {
      background-color: #121824;
      border-radius: 6px;
      padding: 15px;
      font-family: monospace;
      color: #e2e2e2;
      flex: 1;
      overflow: auto;
      white-space: pre-wrap;
      resize: none;
      border: none;
      outline: none;
      margin-top: 20px;
      margin-bottom: 20px;
    }

    .button-row {
      display: flex;
      gap: 10px;
      margin-top: 15px;
      margin-bottom: 15px;
    }
    
    .button-row button {
      padding: 8px 16px;
      border-radius: 4px;
      border: none;
      cursor: pointer;
      font-weight: bold;
    }
    
    .save-as-btn {
      background-color: #3b82f6;
      color: white;
    }
    
    .status-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 12px;
      font-size: 12px;
      font-family: monospace;
      background-color: #1a1a1a;
      color: #aaa;
      min-height: 20px;
      gap: 5px;
    }

    #position, #statistics {
      flex: 0 0 auto;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    #position {
      text-align: left;
      min-width: 100px;
      max-width: 180px;
    }

    #statistics {
      text-align: right;
      min-width: 200px;
      max-width: 260px;
      padding-left: 10px;
    }

    .current-file-display {
      font-size: 12px;
      color: #888;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      flex: 1 1 auto;
      text-align: center;
      margin: 0 10px;
      min-width: 0;
      max-width: calc(100% - 480px);
    }
    
    /* Light mode styles */
    body.light-mode #editor {
      background-color: #f1f5f9;
      color: #334155;
      border: 1px solid #e2e8f0;
    }
    
    body.light-mode .status-bar {
      background-color: #f0f0f0;
      color: #666;
    }
    
    body.light-mode .current-file-display {
      color: #666;
    }
    
    body.light-mode .editor-close-btn {
      color: #333;
    }
    
    .select-wrapper {
      position: relative;
      min-width: 60px;
      max-width: 100px;
      flex: 0 0 auto;
    }

    select {
      padding: 6px 8px;
      background-color: #2a2a2a;
      color: white;
      border: 1px solid #444;
      border-radius: 4px;
      cursor: pointer;
      appearance: none;
      padding-right: 20px;
      font-size: 14px;
      width: 100%;
    }

    body.light-mode select {
      background-color: white;
      color: #333;
      border: 1px solid #ccc;
    }

    .select-wrapper::after {
      content: "▼";
      font-size: 10px;
      position: absolute;
      top: 50%;
      right: 8px;
      transform: translateY(-50%);
      pointer-events: none;
      color: #888;
    }
  </style>
</head>
<body class="dark-mode">
  <div class="editor-container">
    <div class="editor-header">
      <button class="editor-close-btn" id="close-btn">×</button>
    </div>
    
    <div class="editor-body">
      <div class="button-row">
        <button id="btnSaveAs" class="save-as-btn">Save As</button>
        
        <div class="select-wrapper">
          <select id="fontSize">
            <option value="12">12px</option>
            <option value="14" selected>14px</option>
            <option value="16">16px</option>
            <option value="18">18px</option>
            <option value="20">20px</option>
          </select>
        </div>
        
        <div class="select-wrapper">
          <select id="wordWrap">
            <option value="on" selected>Wrap: On</option>
            <option value="off">Wrap: Off</option>
          </select>
        </div>
      </div>
      
      <textarea id="editor" spellcheck="false"></textarea>
      
      <div class="status-bar">
        <span id="position">Line: 1, Column: 1</span>
        <span id="currentFile" class="current-file-display">No file opened</span>
        <span id="statistics">Words: 0 & Characters: 0</span>
      </div>
    </div>
  </div>
  
  <script src="editor-dialog.js"></script>
</body>
</html>

============================================================
FILE: index.html
SIZE: 3648 bytes
LANGUAGE: HTML
============================================================

<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Writer's Toolkit</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body class="dark-mode">
  <header>

    <div class="header-left">
      <button id="theme-toggle" class="icon-button">
        <!-- Sun icon - shown in dark mode -->
        <svg id="sun-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <circle cx="12" cy="12" r="5"></circle>
          <line x1="12" y1="1" x2="12" y2="3"></line>
          <line x1="12" y1="21" x2="12" y2="23"></line>
          <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
          <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
          <line x1="1" y1="12" x2="3" y2="12"></line>
          <line x1="21" y1="12" x2="23" y2="12"></line>
          <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
          <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
        </svg>
        
        <!-- Moon icon - shown in light mode -->
        <svg id="moon-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
          <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
        </svg>
      </button>
    </div>    

    <div class="header-center">
      <h1>Writer's Toolkit</h1>
    </div>
    
    <div class="header-right">
      <button id="api-settings-btn" class="text-button">API Settings</button>
      <button id="quit-button" class="text-button">Quit</button>
    </div>
  </header>
  
<main>
  <!-- Project section -->
  <section class="card">
    <div class="card-header">
      <h2>Current Project</h2>
      <button id="select-project-btn" class="action-button">Select Project</button>
      <button id="import-docx-btn" class="action-button">Import/Convert .docx to .txt</button>
      <button id="export-txt-btn" class="action-button">Export/Convert .txt to .docx</button>
    </div>
    <div class="project-info">
      <h3 id="current-project-name">No project selected</h3>
      <p id="current-project-path" class="project-path"></p>
    </div>
  </section>
  
  <!-- AI Tools section -->
  <section class="card">
    <h2>Run an AI based tool:</h2>
    
    <div class="form-group">
      <label for="ai-tool-select">&nbsp;</label>
      <div class="select-wrapper">
        <select id="ai-tool-select">
          <!-- AI Tools will be populated by JavaScript -->
        </select>
      </div>
    </div>
    
    <p id="ai-tool-description" class="tool-description">
      Select a tool to see its description.
    </p>

    <div class="button-container">
      <button id="ai-setup-run-btn" class="action-button center-button">Setup & Run</button>
    </div>
  </section>

  <!-- Non-AI Tools section -->
  <section class="card">
    <h2>Run a non-AI tool:</h2>
    
    <div class="form-group">
      <label for="non-ai-tool-select">&nbsp;</label>
      <div class="select-wrapper">
        <select id="non-ai-tool-select">
          <!-- Non-AI Tools will be populated by JavaScript -->
        </select>
      </div>
    </div>
    
    <p id="non-ai-tool-description" class="tool-description">
      Select a tool to see its description.
    </p>

    <div class="button-container">
      <button id="non-ai-setup-run-btn" class="action-button center-button">Setup & Run</button>
    </div>
  </section>
</main>
  
  <script src="renderer.js"></script>
</body>
</html>

============================================================
FILE: project-dialog.html
SIZE: 3652 bytes
LANGUAGE: HTML
============================================================

<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Select Project</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      background-color: #121212;
      color: #ffffff;
      margin: 0;
      padding: 20px;
    }
    
    .container {
      max-width: 600px;
      margin: 0 auto;
    }
    
    h1 {
      font-size: 24px;
      margin-bottom: 20px;
    }
    
    .card {
      background-color: #1e1e1e;
      border-radius: 8px;
      border: 1px solid #333333;
      padding: 20px;
      margin-bottom: 20px;
    }
    
    .card-header {
      margin-bottom: 15px;
      font-weight: bold;
    }
    
    select {
      width: 100%;
      padding: 10px;
      margin-bottom: 15px;
      background-color: #2a2a2a;
      color: #ffffff;
      border: 1px solid #333333;
      border-radius: 4px;
      font-size: 16px;
    }
    
    input {
      width: 100%;
      padding: 10px;
      margin-bottom: 15px;
      background-color: #2a2a2a;
      color: #ffffff;
      border: 1px solid #333333;
      border-radius: 4px;
      font-size: 16px;
      box-sizing: border-box;
    }
    
    .button-container {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
    }
    
    button {
      padding: 10px 15px;
      border: none;
      border-radius: 4px;
      font-size: 14px;
      cursor: pointer;
    }
    
    .primary-button {
      background-color: #4a89dc;
      color: white;
    }
    
    .primary-button:hover {
      background-color: #5c9ce6;
    }
    
    .primary-button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    
    .secondary-button {
      background-color: transparent;
      color: #4a89dc;
      border: 1px solid #4a89dc;
    }
    
    .secondary-button:hover {
      background-color: rgba(74, 137, 220, 0.1);
    }
    
    .info-text {
      font-size: 12px;
      color: #888888;
      margin-top: 10px;
    }
    /* Light mode styles */
    body.light-mode {
      background-color: #f5f5f5;
      color: #222222;
    }

    body.light-mode .card {
      background-color: #ffffff;
      border: 1px solid #e0e0e0;
    }

    body.light-mode select, 
    body.light-mode input {
      background-color: #ffffff;
      color: #222222;
      border: 1px solid #cccccc;
    }

    body.light-mode .info-text {
      color: #666666;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Select or Create a Project</h1>
    
    <div class="card">
      <div class="card-header">Select Existing Project</div>
      <select id="project-select">
        <option value="">Select a project...</option>
        <!-- Projects will be populated here by JavaScript -->
      </select>
      <div class="button-container">
        <button id="open-project-btn" class="primary-button">Open Selected Project</button>
      </div>
    </div>
    
    <div class="card">
      <div class="card-header">Create New Project</div>
      <input type="text" id="new-project-name" placeholder="Enter new project name...">
      <div class="button-container">
        <button id="create-project-btn" class="primary-button">Create Project</button>
      </div>
    </div>
    
    <div class="info-text">
      All projects are stored in the "~/writing" directory. You must select or create a project to continue.
    </div>
    
    <div class="button-container" style="margin-top: 20px;">
      <button id="cancel-btn" class="secondary-button">Cancel</button>
    </div>
  </div>

  <script src="project-dialog.js"></script>
</body>
</html>

============================================================
FILE: renderer/editor/index.html
SIZE: 3443 bytes
LANGUAGE: HTML
============================================================

<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta http-equiv="Content-Security-Policy" content="default-src 'self'; style-src 'self' 'unsafe-inline'; script-src 'self'">
  <title>Writer's Toolkit - Editor</title>
  <!-- Link to main application styles -->
  <!-- <link rel="stylesheet" href="../../styles.css"> -->
  <!-- Additional editor-specific styles -->
  <link rel="stylesheet" href="editor-specific.css">
</head>
<body class="dark-mode">
  <div class="toolbar">
    <div class="toolbar-left">
      <button id="theme-toggle" class="icon-button">
        <!-- Sun icon - shown in dark mode -->
        <svg id="sun-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <circle cx="12" cy="12" r="5"></circle>
          <line x1="12" y1="1" x2="12" y2="3"></line>
          <line x1="12" y1="21" x2="12" y2="23"></line>
          <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
          <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
          <line x1="1" y1="12" x2="3" y2="12"></line>
          <line x1="21" y1="12" x2="23" y2="12"></line>
          <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
          <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
        </svg>
        
        <!-- Moon icon - shown in light mode -->
        <svg id="moon-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
        </svg>
      </button>
    </div>

    <div class="toolbar-center">
      <button id="btnNew" class="action-button">New</button>
      <button id="btnOpen" class="action-button">Open</button>
      <button id="btnSave" class="action-button">Save</button>
      <button id="btnSaveAs" class="action-button">Save As</button>
      
      <div class="select-wrapper">
        <select id="fontSize">
          <option value="12">12px</option>
          <option value="14" selected>14px</option>
          <option value="16">16px</option>
          <option value="18">18px</option>
          <option value="20">20px</option>
        </select>
      </div>
      
      <div class="select-wrapper">
        <select id="wordWrap">
          <option value="on" selected>Wrap: On</option>
          <option value="off">Wrap: Off</option>
        </select>
      </div>
      
      <div class="find-container">
        <input type="text" id="find-input" placeholder="Find..." class="find-input">
        <button id="find-next-btn" class="action-button">search</button>
        <button id="clear-search-btn" class="action-button">clear</button>
      </div>
    </div>
    
    <div class="toolbar-right">
      <button id="quit-button" class="text-button">Quit</button>
    </div>
  </div>
  
  <main>
    <div class="editor-container">
      <textarea id="editor" spellcheck="false">// Start typing here...</textarea>
      <div class="status-bar">
        <span id="position">Line: 1, Column: 1</span>
        <span id="currentFile" class="current-file-display">No file opened</span>
        <span id="statistics">Words: 4 & Characters: 23</span>
      </div>
    </div>
  </main>

  <script src="renderer.js"></script>
</body>
</html>


============================================================
FILE: tool-setup-run.html
SIZE: 8839 bytes
LANGUAGE: HTML
============================================================

<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Tool Setup</title>
  <link rel="stylesheet" href="styles.css">
  <style>
    .tool-container {
      height: 100vh;
      display: flex;
      flex-direction: column;
      margin: 0;
      padding: 0;
      overflow: hidden;
    }

    .tool-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0px 0px;
      border-bottom: 1px solid #333;
    }

    #tool-title {
      font-size: 12px; /* Reduce from likely 24px */
      margin: 0; /* Remove any margin */
    }    
    
    .tool-close-btn {
      background: none;
      border: none;
      font-size: 24px;
      cursor: pointer;
      color: #fff;
    }
    
    .tool-body {
      flex: 1;
      overflow: auto;
      padding: 15px;
      display: flex;
      flex-direction: column;
    }

    .tool-output {
      background-color: #121824;
      border-radius: 6px;
      padding: 15px;
      font-family: monospace;
      font-size: 20px;
      color: #e2e2e2;
      flex: 1;
      overflow: auto;
      white-space: pre-wrap;
      margin-top: 20px;
      margin-bottom: 20px;
    }

    .button-row {
      display: flex;
      gap: 10px;
      margin-top: 15px;
      margin-bottom: 15px;
    }
    
    .button-row button {
      padding: 8px 16px;
      border-radius: 4px;
      border: none;
      cursor: pointer;
      font-weight: bold;
    }
    
    .setup-btn {
      background-color: #3b82f6;
      color: white;
    }
    
    .run-btn {
      background-color: #22c55e;
      color: white;
    }
    
    .clear-btn {
      background-color: #6b7280;
      color: white;
    }
    
    .force-quit-btn {
      background-color: #ef4444;
      color: white;
    }
    
    .elapsed-time {
      color: #9ca3af;
      margin-left: 15px;
      display: flex;
      align-items: center;
      margin-right: 20px;
    }
    
    /* Setup dialog styles */
    .setup-dialog-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(0, 0, 0, 0.7);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    
    .setup-dialog {
      background-color: #1e1e1e;
      border-radius: 8px;
      border: 1px solid #333;
      padding: 20px;
      width: 80%;
      max-width: 600px;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
    }
    
    .setup-dialog-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      padding-bottom: 10px;
      border-bottom: 1px solid #333;
    }
    
    .setup-dialog-title {
      font-size: 20px;
      font-weight: 500;
    }
    
    .setup-dialog-close {
      background: none;
      border: none;
      font-size: 20px;
      cursor: pointer;
      color: inherit;
    }
    
    .setup-dialog-body {
      margin-bottom: 20px;
    }
    
    .setup-dialog-footer {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
      margin-top: 20px;
    }
    
    .form-group {
      margin-bottom: 15px;
    }
    
    .form-group label {
      display: block;
      margin-bottom: 5px;
      font-weight: bold;
    }
    
    .form-group input[type="text"],
    .form-group input[type="number"],
    .form-group textarea,
    .form-group select {
      width: 100%;
      padding: 8px;
      border-radius: 4px;
      border: 1px solid #374151;
      background-color: #1f2937;
      color: #e5e7eb;
    }

    .option-heading {
      font-weight: 600;
      font-size: 14px;
      margin-bottom: 4px;
    }

    .option-description {
      font-size: 12px;
      color: #9ca3af;
      margin-bottom: 8px;
    }

    .checkbox-wrapper {
      display: flex;
      align-items: center;
      margin-bottom: 5px;
      margin-top: 20px;
    }

    .checkbox-wrapper input[type="checkbox"] {
      margin-right: 8px;
    }

    .checkbox-label {
      font-weight: normal;
      margin-bottom: 0;
    }

    .file-input-container {
      display: flex;
      align-items: center;
      width: 100%;
      margin-bottom: 10px;
    }
    
    .file-input-container input {
      flex-grow: 1;
      margin-right: 8px;
    }
    
    .browse-button {
      min-width: 90px;
      padding: 6px 12px;
      background-color: #3b82f6;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-weight: bold;
      white-space: nowrap;
    }
    
    .browse-button:hover {
      background-color: #2563eb;
    }
    
    .error-message {
      color: #ef4444;
      font-size: 12px;
      margin-top: 4px;
      display: block;
    }

    /* Target the specific buttons when disabled */
    #setup-btn:disabled,
    #run-btn:disabled, 
    #clear-btn:disabled {
      cursor: not-allowed !important;
    }
    
    /* Light mode styles */
    body.light-mode .setup-dialog {
      background-color: #f5f5f5;
      border: 1px solid #ddd;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
    }
    
    body.light-mode .setup-dialog-header {
      border-bottom: 1px solid #ddd;
    }
    
    body.light-mode .form-group input[type="text"],
    body.light-mode .form-group input[type="number"],
    body.light-mode .form-group textarea,
    body.light-mode .form-group select {
      border: 1px solid #cccccc;
      background-color: #ffffff;
      color: #222222;
    }
    
    body.light-mode .option-description {
      color: #666666;
    }
    
    body.light-mode .tool-output {
      background-color: #f1f5f9;
      color: #334155;
      border: 1px solid #e2e8f0;
    }
    
    body.light-mode .browse-button {
      background-color: #3b82f6;
      color: white;
    }
    
    body.light-mode .browse-button:hover {
      background-color: #2563eb;
    }
    
    body.light-mode .elapsed-time {
      color: #64748b;
    }
    
    /* Dialog buttons */
    .cancel-button {
      background-color: transparent;
      color: #aaaaaa;
      border: 1px solid #444444;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      font-weight: bold;
    }
    
    .action-button {
      background-color: #4a89dc;
      color: white;
      padding: 8px 16px;
      border-radius: 4px;
      border: none;
      cursor: pointer;
      font-weight: bold;
    }
    
    body.light-mode .cancel-button {
      color: #666666;
      border: 1px solid #cccccc;
    }

    /* Fix for the main tool close button in the header */
    body.light-mode .tool-close-btn {
      color: #333; /* Dark gray color for visibility against light background */
    }

    /* Fix for the setup dialog close button */
    body.light-mode .setup-dialog-close {
      color: #333; /* Dark gray color for visibility against light background */
    }

    .native-select {
      max-width: 250px;
      font-size: 13px;
      appearance: auto;
    }

    body.dark-mode .native-select {
      color: #ffffff;
    }

    body.light-mode .native-select {
      color: #333333;
    }
  </style>
</head>
<body class="dark-mode">
  <div class="tool-container">
    <div class="tool-header">
      <h2 id="tool-title">Writing Tool: <span id="tool-name"></span></h2>
      <button class="tool-close-btn" id="close-btn">×</button>
    </div>
    
    <div class="tool-body">
      <div class="button-row">
        <button id="setup-btn" class="setup-btn">Setup</button>
        <button id="run-btn" class="run-btn" disabled>Run</button>
        <span id="elapsed-time" class="elapsed-time">elapsed: 0m 0s</span>
        <div style="flex-grow: 1;"></div>
        <button id="clear-btn" class="clear-btn">Clear</button>
        <button id="force-quit-btn" class="force-quit-btn">Force Quit</button>
      </div>
      
      <div id="output" class="tool-output">
Tool output will appear here...
Please click 'Setup' before running the tool.
      </div>
    </div>
  </div>
  
  <!-- Setup Dialog Overlay -->
  <div id="setup-dialog-overlay" class="setup-dialog-overlay" style="display: none;">
    <div class="setup-dialog">
      <div class="setup-dialog-header">
        <div class="setup-dialog-title">Configure Tool: <span id="dialog-tool-name"></span></div>
        <button id="setup-dialog-close" class="setup-dialog-close">×</button>
      </div>
      <div class="setup-dialog-body">
        <div id="dialog-options-container">
          <!-- Tool options will be dynamically generated here -->
        </div>
      </div>
      <div class="setup-dialog-footer">
        <button id="setup-dialog-cancel" class="cancel-button">Cancel</button>
        <button id="setup-dialog-apply" class="action-button">Apply</button>
      </div>
    </div>
  </div>
  
  <script src="tool-setup-run.js"></script>
</body>
</html>

============================================================
FILE: renderer/editor/editor-specific.css
SIZE: 6833 bytes
LANGUAGE: CSS
============================================================

/* editor-styles.css - Specific styles for Writer's Toolkit Editor */

/* Basic layout */
body {
  margin: 0;
  padding: 0;
  display: flex;
  flex-direction: column;
  height: 100vh;
  overflow: hidden;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
}

/* Toolbar sizing and layout - prevent stretching */
.toolbar {
  display: flex;
  align-items: center;
  padding: 8px 10px;
  background-color: #1a1a1a;
  border-bottom: 1px solid #333;
  gap: 8px;
  flex-wrap: nowrap;
  justify-content: flex-start;
  min-height: 42px;
}

body.light-mode .toolbar {
  background-color: #f0f0f0;
  border-bottom: 1px solid #ddd;
}

/* Ensure toolbar sections have proper sizing */
.toolbar-left {
  width: auto;
  min-width: 40px;
  flex: 0 0 auto;
}

.toolbar-center {
  display: flex;
  align-items: center;
  gap: 8px;
  flex-grow: 1;
  flex-wrap: nowrap;
  overflow-x: auto;
  padding-right: 10px;
}

.toolbar-center::-webkit-scrollbar {
  height: 4px;
}

.toolbar-center::-webkit-scrollbar-thumb {
  background-color: #555;
  border-radius: 2px;
}

.toolbar-center::-webkit-scrollbar-track {
  background-color: transparent;
}

.toolbar-right {
  display: flex;
  align-items: center;
  gap: 10px;
  flex: 0 0 auto;
}

/* Button sizing - prevent overly wide buttons */
.action-button {
  background-color: #4a89dc;
  color: white;
  border: none;
  padding: 6px 12px;
  border-radius: 4px;
  font-size: 14px;
  cursor: pointer;
  min-width: 60px;
  max-width: 80px;
  white-space: nowrap;
  text-align: center;
  flex: 0 0 auto;
}

.action-button:hover {
  background-color: #5c9ce6;
}

/* Clear button sizing */
#clear-search-btn {
  background-color: #666;
  min-width: 50px;
  max-width: 60px;
}

#clear-search-btn:hover {
  background-color: #777;
}

/* Theme toggle button */
.icon-button {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 34px;
  height: 34px;
  min-width: 34px;
  border-radius: 50%;
  background-color: transparent;
  color: #4a89dc;
  border: none;
  cursor: pointer;
  flex: 0 0 auto;
}

.icon-button:hover {
  background-color: rgba(74, 137, 220, 0.1);
}

/* Quit button */
.text-button {
  background: none;
  border: none;
  color: #4a89dc;
  padding: 6px 10px;
  font-size: 14px;
  cursor: pointer;
  white-space: nowrap;
  flex: 0 0 auto;
}

.text-button:hover {
  color: #5c9ce6;
}

/* Select dropdown sizing */
.select-wrapper {
  position: relative;
  min-width: 60px;
  max-width: 100px;
  flex: 0 0 auto;
}

select {
  padding: 6px 8px;
  background-color: #2a2a2a;
  color: white;
  border: 1px solid #444;
  border-radius: 4px;
  cursor: pointer;
  appearance: none;
  padding-right: 20px;
  font-size: 14px;
  width: 100%;
}

body.light-mode select {
  background-color: white;
  color: #333;
  border: 1px solid #ccc;
}

.select-wrapper::after {
  content: "▼";
  font-size: 10px;
  position: absolute;
  top: 50%;
  right: 8px;
  transform: translateY(-50%);
  pointer-events: none;
  color: #888;
}

/* Find input and button - prevent excessive stretching */
.find-container {
  display: flex;
  align-items: center;
  gap: 4px;
  flex: 0 0 auto;
  max-width: 300px;
}

.find-input {
  padding: 6px 10px;
  border-radius: 4px;
  border: 1px solid #444;
  background-color: #2a2a2a;
  color: white;
  font-size: 14px;
  min-width: 120px;
  max-width: 180px;
  width: 100%;
}

body.light-mode .find-input {
  background-color: white;
  color: #333;
  border: 1px solid #ccc;
}

/* Editor area */
main {
  flex-grow: 1;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  padding: 10px;
}

.editor-container {
  flex-grow: 1;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

#editor {
  width: 100%;
  flex-grow: 1;
  resize: none;
  font-family: monospace;
  padding: 10px;
  font-size: 14px;
  line-height: 1.5;
  border: none;
  outline: none;
  background-color: #121824;
  color: white;
  overflow: auto;
}

body.light-mode #editor {
  background-color: #f9f9f9;
  color: #333;
}

/* Status bar - use flexbox properly */
.status-bar {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px 12px;
  font-size: 12px;
  font-family: monospace;
  background-color: #1a1a1a;
  color: #aaa;
  min-height: 20px;
  gap: 5px; /* Add gap between flex items */
}

body.light-mode .status-bar {
  background-color: #f0f0f0;
  color: #666;
}

/* Status elements sizing */
#position, #statistics {
  flex: 0 0 auto;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

#position {
  text-align: left;
  min-width: 100px;
  max-width: 180px;
}

#statistics {
  text-align: right;
  min-width: 200px;
  max-width: 260px;
  padding-left: 10px;
}

/* Current file display in status bar */
.current-file-display {
  font-size: 12px;
  color: #888;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  flex: 1 1 auto;
  text-align: center;
  margin: 0 10px;
  min-width: 0;
  max-width: calc(100% - 480px); /* Ensure there's space for position and statistics */
}

body.light-mode .current-file-display {
  color: #666;
}

/* Theme-specific icon visibility */
body.dark-mode #sun-icon {
  display: block;
}

body.dark-mode #moon-icon {
  display: none;
}

body.light-mode #sun-icon {
  display: none;
}

body.light-mode #moon-icon {
  display: block;
}

/* Notification popup */
.notification {
  position: fixed;
  bottom: 20px;
  right: 20px;
  padding: 10px 20px;
  background-color: #4a89dc;
  color: white;
  border-radius: 4px;
  opacity: 0;
  transition: opacity 0.3s;
  z-index: 1000;
}

/* Media query for narrow screens */
@media (max-width: 900px) {
  .toolbar {
    flex-wrap: wrap;
    gap: 5px;
    padding: 5px;
  }
  
  .toolbar-center {
    order: 3;
    width: 100%;
    margin-top: 5px;
    justify-content: space-between;
  }
  
  .action-button {
    min-width: 50px;
    padding: 5px 10px;
    font-size: 13px;
  }
  
  .find-input {
    min-width: 80px;
  }
  
  /* Status bar adjustments for smaller screens */
  #statistics {
    min-width: 180px; /* Ensure we have enough room for character/word counts */
  }
  
  .current-file-display {
    max-width: calc(100% - 380px);
  }
}

/* Specific fix for extra small screens */
@media (max-width: 600px) {
  .toolbar-center {
    justify-content: flex-start;
    overflow-x: auto;
  }
  
  .find-container {
    max-width: 200px;
  }
  
  .find-input {
    max-width: 100px;
  }
  
  /* Adjust status bar for very small screens */
  .status-bar {
    flex-wrap: nowrap;
    overflow-x: hidden;
  }
  
  #position {
    min-width: 90px;
    max-width: 120px;
  }
  
  #statistics {
    min-width: 160px;
    max-width: 180px;
  }
  
  .current-file-display {
    max-width: calc(100% - 300px);
    margin: 0 5px;
  }
}


============================================================
FILE: styles.css
SIZE: 7064 bytes
LANGUAGE: CSS
============================================================

/* Global styles */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
}

:root {
  --primary-color: #4a89dc;
  --primary-hover: #5c9ce6;
  --text-color-light: #ffffff;
  --text-color-dark: #222222;
  --bg-color-light: #ffffff;
  --bg-color-dark: #121212;
  --card-bg-light: #f5f5f5;
  --card-bg-dark: #1e1e1e;
  --border-color-light: #e0e0e0;
  --border-color-dark: #333333;
}

body {
  transition: background-color 0.3s ease, color 0.3s ease;
  padding: 20px;
  min-height: 100vh;
}

body.light-mode {
  background-color: var(--bg-color-light);
  color: var(--text-color-dark);
}

body.dark-mode {
  background-color: var(--bg-color-dark);
  color: var(--text-color-light);
}

/* Header styles */
header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-bottom: 20px;
}

.header-left, .header-right {
  flex: 1;
}

.header-right {
  display: flex;
  justify-content: flex-end;
  gap: 10px;
}

h1 {
  font-size: 32px;
  font-weight: 500;
}

.header-center {
  flex: 2;
  text-align: center;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 15px;
}

.header-center h1 {
  font-size: 32px;
  font-weight: 500;
  margin: 0;
}

.timestamp {
  font-size: 14px;
  color: #888;
  white-space: nowrap;
  margin-top: 10px;
}

body.dark-mode .timestamp {
  color: #aaa;
}

body.light-mode .timestamp {
  color: #666;
}

/* Button styles */
button {
  cursor: pointer;
  border: none;
  background: none;
  transition: all 0.2s ease;
}

button:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

.icon-button {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 40px;
  height: 40px;
  border-radius: 50%;
  color: var(--primary-color);
  background-color: rgba(74, 137, 220, 0.1);
}

body.light-mode .icon-button {
  color: var(--primary-color);
  background-color: rgba(74, 137, 220, 0.1);
}

body.dark-mode .icon-button {
  color: var(--primary-color);
}

.icon-button:hover {
  background-color: rgba(74, 137, 220, 0.2);
}

.text-button {
  padding: 8px 16px;
  border-radius: 4px;
  font-size: 14px;
  color: var(--primary-color);
}

.text-button:hover {
  color: var(--primary-hover);
}

.action-button {
  padding: 10px 20px;
  border-radius: 4px;
  font-size: 16px;
  color: white;
  background-color: var(--primary-color);
  transition: background-color 0.2s ease;
  min-width: 150px;
  text-align: center;
}

.action-button:hover:not(:disabled) {
  background-color: var(--primary-hover);
}

.button-container {
  display: flex;
  justify-content: space-between;
  width: 100%;
  padding: 0 15%;
  box-sizing: border-box;
  margin-top: 20px;
}

#open-editor-btn {
  margin-left: 10px;
  background-color: #5c9ce6;
}

#open-editor-btn:hover {
  background-color: #4a89dc;
}

.center-button {
  margin: 20px auto;
  display: block;
}

/* Card styles */
.card {
  margin-bottom: 20px;
  padding: 20px;
  border-radius: 8px;
  border: 1px solid var(--border-color-dark);
  background-color: var(--card-bg-dark);
}

body.light-mode .card {
  border: 1px solid var(--border-color-light);
  background-color: var(--card-bg-light);
}

.card-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 15px;
}

.project-info h3 {
  font-size: 20px;
  font-weight: 400;
  margin-bottom: 5px;
}

.project-path {
  font-size: 14px;
  color: #888;
}

/* Form elements */
.form-group {
  margin-bottom: 15px;
}

label {
  display: block;
  margin-bottom: 5px;
  font-size: 14px;
}

.select-wrapper {
  position: relative;
}

select {
  width: 100%;
  padding: 10px;
  border-radius: 4px;
  border: 1px solid var(--border-color-dark);
  background-color: #2a2a2a;
  color: var(--text-color-light);
  appearance: none;
  font-size: 16px;
}

body.light-mode select {
  border: 1px solid var(--border-color-light);
  background-color: #f0f0f0;
  color: var(--text-color-dark);
}

.select-wrapper::after {
  content: '▼';
  position: absolute;
  right: 10px;
  top: 50%;
  transform: translateY(-50%);
  pointer-events: none;
}

.tool-description {
  margin: 20px 0;
  font-size: 14px;
  color: #999;
  line-height: 1.5;
}

body.light-mode .tool-description {
  color: #555;
}

/* Add these to your existing styles.css file */

/* Theme toggle icon styles */
.icon-button svg {
  color: var(--primary-color);
}

/* Adjust icon visibility based on theme */
body.dark-mode #sun-icon {
  display: block;
}

body.dark-mode #moon-icon {
  display: none;
}

body.light-mode #sun-icon {
  display: none;
}

body.light-mode #moon-icon {
  display: block;
}

/* Make sure the button itself has good contrast in both modes */
.icon-button {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 40px;
  height: 40px;
  border-radius: 50%;
  background-color: rgba(74, 137, 220, 0.1);
  transition: background-color 0.2s ease;
}

.icon-button:hover {
  background-color: rgba(74, 137, 220, 0.2);
}

/* Project info styles */
.project-info h3 {
  font-size: 20px;
  font-weight: 400;
  margin-bottom: 5px;
}

.project-info h3.no-project {
  color: #f44336;
  font-weight: bold;
}

.project-path {
  font-size: 14px;
  color: #888;
}

.card-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 15px;
}

/* Improved Select Styles */
.form-group {
  margin-bottom: 15px;
}

label {
  display: block;
  margin-bottom: 5px;
  font-size: 14px;
}

.select-wrapper {
  position: relative;
}

.select-wrapper::after {
  content: '▼';
  position: absolute;
  right: 10px;
  top: 50%;
  transform: translateY(-50%);
  pointer-events: none;
  color: #888;
}

.action-button, #setup-run-btn, #open-editor-btn {
  width: 210px; /* Fixed width for all buttons */
  text-align: center;
  padding: 10px 0; /* Vertical padding only */
  margin: 0; /* Remove any existing margins */
  flex: 0 0 auto; /* Prevent flex growth/shrinking */
}

/* Add styling for the project actions container */
.project-actions {
  margin-top: 15px;
  display: flex;
  justify-content: flex-start;
}

/* Style the import button in its new location */
.project-actions .action-button {
  background-color: #7e57c2;
  margin-top: 5px;
}

.project-actions .action-button:hover {
  background-color: #6a43b5;
}

/* Style the header buttons container */
.header-buttons {
  display: flex;
  gap: 10px;
  align-items: center;
}

#select-project-btn {
  background-color: firebrick;
}
#select-project-btn:hover {
  background-color: indianred;
}

#import-docx-btn {
  background-color: #7e57c2;
}
#import-docx-btn:hover {
  background-color: #6a43b5;
}

#export-txt-btn {
  background-color: #7e57c2;
}
#export-txt-btn:hover {
  background-color: #6a43b5;
}

#ai-setup-run-btn {
  background-color: goldenrod;
}
#ai-setup-run-btn:hover {
  background-color: darkgoldenrod;
}

#non-ai-setup-run-btn {
  background-color: forestgreen;
}
#non-ai-setup-run-btn:hover {
  background-color: green;
}


============================================================
FILE: package.json
SIZE: 2476 bytes
LANGUAGE: JSON
============================================================

{
  "name": "writers-toolkit",
  "version": "2.0.0",
  "description": "A toolkit for writers with AI assistance and a text editor",
  "main": "main.js",
  "files": [
    "resources/**/*",
    "*.js",
    "*.html",
    "*.css",
    "preload.js"
  ],
  "scripts": {
    "start": "electron-forge start",
    "start-editor": "electron editor-main.js",
    "build": "electron-builder",
    "package": "electron-forge package",
    "make": "electron-forge make"
  },
  "author": "Chris Smith",
  "license": "ISC",
  "dependencies": {
    "@anthropic-ai/sdk": "^0.39.0",
    "@google/genai": "^0.13.0",
    "argparse": "^2.0.1",
    "chalk": "^4.1.2",
    "cheerio": "^1.0.0",
    "cli-progress": "^3.12.0",
    "commander": "^13.1.0",
    "docx": "^9.4.1",
    "dotenv": "^16.5.0",
    "electron-squirrel-startup": "^1.0.1",
    "electron-store": "^8.1.0",
    "glob": "^8.1.0",
    "inquirer": "^8.2.5",
    "jsdom": "^26.1.0",
    "luxon": "^3.6.1",
    "mammoth": "^1.9.0",
    "marked": "^15.0.11",
    "mime": "^4.0.7",
    "uuid": "^11.1.0",
    "xmldom": "^0.6.0",
    "xpath": "^0.0.34"
  },
  "devDependencies": {
    "@electron-forge/cli": "^7.8.0",
    "@electron-forge/maker-dmg": "^7.8.0",
    "@electron-forge/maker-squirrel": "^7.8.0",
    "@electron-forge/maker-zip": "^7.8.0",
    "@electron-forge/plugin-auto-unpack-natives": "^7.8.0",
    "@electron-forge/plugin-fuses": "^7.8.0",
    "@electron/fuses": "^1.8.0",
    "@types/node": "^22.15.17",
    "electron": "^26.0.0",
    "png-to-ico": "^2.1.8"
  },
  "build": {
    "appId": "com.slipthetrap.writerstoolkit",
    "productName": "Writer's Toolkit",
    "files": [
      "**/*",
      "!**/node_modules/*/{CHANGELOG.md,README.md,README,readme.md,readme}",
      "!**/node_modules/*/{test,__tests__,tests,powered-test,example,examples}",
      "!**/node_modules/.bin",
      "!**/*.{iml,o,hprof,orig,pyc,pyo,rbc,swp,csproj,sln,xproj}",
      "!.editorconfig",
      "!**/._*",
      "!**/{.DS_Store,.git,.hg,.svn,CVS,RCS,SCCS,__pycache__,thumbs.db,.gitignore,.gitattributes}",
      "!**/{appveyor.yml,.travis.yml,circle.yml}",
      "!**/{npm-debug.log,yarn.lock,.yarn-integrity,.yarn-metadata.json}"
    ],
    "directories": {
      "buildResources": "resources"
    },
    "asar": false,
    "mac": {
      "target": "dmg",
      "artifactName": "${productName}-${version}-mac.${ext}"
    },
    "win": {
      "target": "squirrel",
      "artifactName": "${productName}-${version}-win.${ext}"
    }
  }
}
